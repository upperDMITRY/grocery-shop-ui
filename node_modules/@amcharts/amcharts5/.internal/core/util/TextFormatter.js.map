{"version":3,"file":"TextFormatter.js","sourceRoot":"","sources":["../../../../../src/.internal/core/util/TextFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import { Color } from \"./Color\"\nimport type { ITextStyle } from \"../render/backend/Renderer\"\nimport * as $type from \"./Type\";\n\n/**\n * Defines an interface for an object that holds a chunk of text.\n */\nexport interface ITextChunk {\n\n\t/**\n\t * Type of the chunk.\n\t */\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\n\n\t/**\n\t * Text.\n\t */\n\t\"text\": string\n\n}\n\nexport class TextFormatter {\n\n\tpublic static prefix = \"__amcharts__\";\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic static escape(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, this.prefix + \"1\").\n\t\t\treplace(/([^\\/]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").\n\t\t\treplace(/\\]\\]/g, this.prefix + \"2\").\n\t\t\treplace(/\\{\\{/g, this.prefix + \"3\").\n\t\t\treplace(/\\}\\}/g, this.prefix + \"4\").\n\t\t\treplace(/\\'\\'/g, this.prefix + \"5\");\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic static unescape(text: string): string {\n\t\treturn text.\n\t\t\treplace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").\n\t\t\treplace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").\n\t\t\treplace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").\n\t\t\treplace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").\n\t\t\treplace(new RegExp(this.prefix + \"5\", \"g\"), \"'\");\n\t}\n\n\t/**\n\t * Cleans up the text text for leftover double square brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Cleaned up text\n\t */\n\tpublic static cleanUp(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, \"[\").\n\t\t\treplace(/\\]\\]/g, \"]\").\n\t\t\treplace(/\\{\\{/g, \"{\").\n\t\t\treplace(/\\}\\}/g, \"}\").\n\t\t\treplace(/\\'\\'/g, \"'\");\n\t}\n\n\t/**\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\n\t *\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\n\t * also single out text blocks enclosed within single quotes that no\n\t * formatting should be applied to, and they should be displayed as is.\n\t *\n\t * Default for the above is `false`, so that you can use single quote in text\n\t * without escaping it.\n\t *\n\t * If enabled, single quotes can be escaped by doubling it - adding two\n\t * single quotes, which will be replaced by a one single quote in the final\n\t * output.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text          Text to chunk\n\t * @param quotedBlocks  Use quoted blocks\n\t * @param noFormatting  Formatting blocks will be treated as regular text\n\t * @return Array of string chunks\n\t */\n\tpublic static chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\n\n\t\t// Init result\n\t\tlet res: ITextChunk[] = [];\n\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\n\t\ttext = this.escape(text);\n\n\t\t// Deal with style blocks\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\tlet chunk = chunks[i];\n\n\t\t\t// Empty?\n\t\t\tif (chunk === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((i % 2) === 0) {\n\n\t\t\t\t// Text outside quotes\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\n\t\t\t\t// \"value\"\n\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Placeholder?\n\t\t\t\t\tif (chunk2 === $type.PLACEHOLDER) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or value\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"value\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// A text within doublequotes\n\t\t\t\t// All chunks are \"text\"\n\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or text\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isImage(chunk2)) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Checks if supplied format contains image information and should be\n\t * formatted as such.\n\t * I.e.: `[img: myImage.png]`\n\t *\n\t * @ignore\n\t * @param  text  Format\n\t * @return true if it is an image\n\t */\n\tpublic static isImage(text: string): boolean {\n\t\treturn text.match(/img[ ]?:/) ? true : false;\n\t}\n\n\tpublic static getTextStyle(style: string): ITextStyle {\n\n\t\t// let textStyle: string[] = [];\n\t\t// let textFill: string | undefined;\n\t\tlet format: ITextStyle = {};\n\n\t\tif (style == \"\" || style == \"[ ]\") {\n\t\t\treturn {};\n\t\t}\n\n\t\t// TODO: cache\n\t\t// let cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n\t\t// if (cached) {\n\t\t// \treturn cached;\n\t\t// }\n\n\t\t// Pre-process quoted text\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\t\tif (q) {\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n\t\t\t}\n\t\t}\n\n\t\t// Get style parts\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n\n\t\t// Empty?\n\t\tif (!b) {\n\t\t\treturn {};\n\t\t}\n\n\t\t//console.log(b)\n\n\t\t// Check each part\n\t\tfor (let i: number = 0; i < b.length; i++) {\n\n\t\t\tif (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n\t\t\t\t(<any>format).fontWeight = b[i];\n\t\t\t}\n\t\t\telse if (b[i] == \"/\") {\n\t\t\t\t// Just closing tag\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if (!b[i].match(/:/)) {\n\t\t\t\t// Color\n\t\t\t\tformat.fill = Color.fromString(b[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst p = b[i].split(/:[ ]*/);\n\t\t\t\t(<any>format)[p[0]] = p[1];\n\t\t\t\t//textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n\t\t\t\t//b[i] = b[i].replace(/\\+/g, \" \");\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO: cache\n\t\t// registry.setCache(\"translateStyleShortcuts_\" + style, res);\n\n\t\treturn format;\n\t}\n\n}\n"]}