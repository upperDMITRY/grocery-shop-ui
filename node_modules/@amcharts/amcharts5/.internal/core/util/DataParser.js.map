{"version":3,"file":"DataParser.js","sourceRoot":"","sources":["../../../../../src/.internal/core/util/DataParser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as $type from \"./Type\"\nimport * as $object from \"./Object\"\n\nexport interface IJSONParserOptions {\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class JSONParser {\n\n\t/**\n\t * Parses JSON string.\n\t * \n\t * @param   input    JSON\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: IJSONParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\t\ttry {\n\t\t\tif ($type.isString(input)) {\n\t\t\t\tlet data  = JSON.parse(input);\n\t\t\t\tif (options.reverse && $type.isArray(data)) {\n\t\t\t\t\tdata.reverse();\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if ($type.isArray(input) || $type.isObject(input)) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow(\"Unable to parse JSON data\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprotected static _applyDefaults(options?: IJSONParserOptions): IJSONParserOptions {\n\t\tconst normalized: IJSONParserOptions = {};\n\t\tconst defaults = {\n\t\t\treverse: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\t}\n}\n\n\nexport interface ICSVParserOptions {\n\n\t/**\n\t * Delimiter used for columns.\n\t * \n\t * @default \",\"\n\t */\n\tdelimiter?: string;\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n\t/**\n\t * Skip first X rows.\n\t *\n\t * @default 0\n\t */\n\tskipRows?: number;\n\n\t/**\n\t * Skip empty rows.\n\t *\n\t * @default true\n\t */\n\tskipEmpty?: boolean;\n\n\t/**\n\t * Use the first row to name the columns.\n\t * \n\t * @default false\n\t */\n\tuseColumnNames?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class CSVParser {\n\n\t/**\n\t * Parses CSV string.\n\t * \n\t * @param   input    CSV\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: ICSVParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\n\t\t// Get CSV data as array\n\t\tlet data = this.CSVToArray(input, options.delimiter!);\n\n\t\t// Init resuling array\n\t\tlet res: any[] = [],\n\t\t\tcols: string[] = [],\n\t\t\tcol: string,\n\t\t\ti: number;\n\n\t\t// Skip rows\n\t\tfor (i = 0; i < options.skipRows!; i++) {\n\t\t\tdata.shift();\n\t\t}\n\n\t\t// First row holds column names?\n\t\tif (options.useColumnNames) {\n\t\t\tcols = data.shift();\n\n\t\t\t// Normalize column names\n\t\t\tfor (let x = 0; x < cols.length; x++) {\n\t\t\t\t// trim\n\t\t\t\tcol = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n\n\t\t\t\t// Check for empty\n\t\t\t\tif (\"\" === col) {\n\t\t\t\t\tcol = \"col\" + x;\n\t\t\t\t}\n\n\t\t\t\tcols[x] = col;\n\t\t\t}\n\t\t}\n\n\t\t// Iterate through the result set\n\t\tlet row;\n\t\twhile (true) {\n\t\t\trow = options.reverse ? data.pop() : data.shift();\n\n\t\t\tif (!row) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dataPoint: any = {};\n\t\t\tfor (i = 0; i < row.length; i++) {\n\t\t\t\tcol = undefined === cols[i] ? \"col\" + i : cols[i];\n\t\t\t\tdataPoint[col] = row[i];\n\t\t\t}\n\t\t\tres.push(dataPoint);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic static CSVToArray(data: string, delimiter: string): any[] {\n\n\t\t// Check to see if the delimiter is defined. If not,\n\t\t// then default to comma.\n\t\tdelimiter = (delimiter || ',');\n\n\t\t// Create a regular expression to parse the CSV values.\n\t\tlet objPattern = new RegExp(\n\t\t\t(\n\t\t\t\t// Delimiters.\n\t\t\t\t\"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n\t\t\t\t// Quoted fields.\n\t\t\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n\t\t\t\t// Standard fields.\n\t\t\t\t\"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"\n\t\t\t),\n\t\t\t\"gi\"\n\t\t);\n\n\n\t\t// Create an array to hold our data. Give the array\n\t\t// a default empty first row.\n\t\tlet arrData: any[] = [\n\t\t\t[]\n\t\t];\n\n\t\t// Create an array to hold our individual pattern\n\t\t// matching groups.\n\t\tlet arrMatches = null;\n\n\t\t// Keep looping over the regular expression matches\n\t\t// until we can no longer find a match.\n\t\twhile (true) {\n\t\t\tarrMatches = objPattern.exec(data);\n\n\t\t\tif (!arrMatches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get the delimiter that was found.\n\t\t\tlet strMatchedDelimiter = arrMatches[1];\n\n\t\t\t// Check to see if the given delimiter has a length\n\t\t\t// (is not the start of string) and if it matches\n\t\t\t// field delimiter. If id does not, then we know\n\t\t\t// that this delimiter is a row delimiter.\n\t\t\tif (\n\t\t\t\tstrMatchedDelimiter.length &&\n\t\t\t\t(strMatchedDelimiter !== delimiter)\n\t\t\t) {\n\n\t\t\t\t// Since we have reached a new row of data,\n\t\t\t\t// add an empty row to our data array.\n\t\t\t\tarrData.push([]);\n\n\t\t\t}\n\n\t\t\t// Now that we have our delimiter out of the way,\n\t\t\t// let's check to see which kind of value we\n\t\t\t// captured (quoted or unquoted).\n\t\t\tlet strMatchedValue;\n\t\t\tif (arrMatches[2]) {\n\n\t\t\t\t// We found a quoted value. When we capture\n\t\t\t\t// this value, unescape any double quotes.\n\t\t\t\tstrMatchedValue = arrMatches[2].replace(\n\t\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"),\n\t\t\t\t\t\"\\\"\"\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// We found a non-quoted value.\n\t\t\t\tstrMatchedValue = arrMatches[3];\n\n\t\t\t}\n\n\t\t\t// Now that we have our value string, let's add\n\t\t\t// it to the data array.\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\n\t\t}\n\n\t\t// Return the parsed data.\n\t\treturn (arrData);\n\t}\n\n\tprotected static _applyDefaults(options?: ICSVParserOptions): ICSVParserOptions {\n\t\tconst normalized: ICSVParserOptions = {};\n\t\tconst defaults = {\n\t\t\tdelimiter: \",\",\n\t\t\treverse: false,\n\t\t\tskipRows: 0,\n\t\t\tskipEmpty: true,\n\t\t\tuseColumnNames: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\n\t}\n\n}"]}