{"version":3,"file":"ColorSet.js","sourceRoot":"","sources":["../../../../../src/.internal/core/util/ColorSet.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,MAAM,EAAmC,MAAM,UAAU,CAAC;AACnE,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAoFhC;;;;GAIG;AACH;IAA8B,4BAAM;IAApC;;IAgGA,CAAC;IAzFA,qCAAqC;;;;;eAErC;YACC,yDAAyD;YACzD,iBAAM,oBAAoB,WAAE,CAAC;QAC9B,CAAC;;;;;;eAED;YACC,iBAAM,cAAc,WAAE,CAAC;YACvB,IAAI,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;gBAC/B,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,CAAA;aACzD;QACF,CAAC;;IAED;;OAEG;;;;;eACH;YACC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;YACrE,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;YAC5C,IAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACpF,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;gBAClC,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;aAC5C;YACD,4BAA4B;YAC5B,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAE,CAAC;YAC1C,oDAAoD;YACpD,IAAM,KAAK,GAAG,CAAC,CAAC;YAChB,IAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,CAAE,CAAC;YAC7C,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAChC,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBACjC,IAAI,KAAK,EAAE;oBACV,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;iBACtB;qBACI;oBACJ,IAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAE,CAAC,KAAK,EAAE,CAAC;oBAC/B,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAK,CAAC;oBAC/C,OAAO,CAAC,GAAG,CAAC;wBAAE,CAAC,IAAI,CAAC,CAAC;oBAErB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,IAAK,CAAC;oBACtD,gCAAgC;oBAChC,IAAI,CAAC,GAAG,CAAC;wBAAE,CAAC,GAAG,CAAC,CAAC;oBACjB,IAAI,CAAC,GAAG,CAAC;wBAAE,CAAC,GAAG,CAAC,CAAC;oBAEjB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,SAAS,IAAI,CAAC,CAAC,GAAG,IAAK,CAAC;oBACrD,gCAAgC;oBAChC,OAAO,CAAC,GAAG,CAAC;wBAAE,CAAC,IAAI,CAAC,CAAC;oBACrB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;iBACpC;aACD;QACF,CAAC;;IAED;;;;;;;OAOG;;;;;eACH,UAAgB,KAAa;YAC5B,IAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YACtC,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAC1C,IAAI,KAAK,IAAI,MAAM,CAAC,MAAM,EAAE;gBAC3B,IAAI,CAAC,cAAc,EAAE,CAAC;gBACtB,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;aAC5B;YAED,OAAO,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,UAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACxF,CAAC;;IAED;;;;OAIG;;;;;eACH;YACC,IAAI,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;YACpD,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;YAClE,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;QACnC,CAAC;;IAED;;;OAGG;;;;;eACH;YACC,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,CAAC;QAC3D,CAAC;;IA9FD;;;;eAAkC,UAAU;OAAC;IAC7C;;;;eAA0C,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;OAAC;IA8F1F,eAAC;CAAA,AAhGD,CAA8B,MAAM,GAgGnC;SAhGY,QAAQ","sourcesContent":["import { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\";\nimport { Color } from \"./Color\";\n\n\nexport interface IColorSetSettings extends IEntitySettings {\n\n\t/**\n\t * List of colors in the set.\n\t */\n\tcolors?: Color[];\n\n\t/**\n\t * A step size when using `next()`.\n\t *\n\t * E.g. setting to `2` will make it return every second color in the list.\n\t *\n\t * @default 1\n\t */\n\tstep?: number;\n\n\t/**\n\t * Start iterating colors from specific index.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * If set to `true`, color set will reuse existing colors from the list\n\t * inestead of generating new ones.\n\t *\n\t * @default false\n\t */\n\treuse?: boolean;\n\n\t/**\n\t * A base color to generate new colors from if `colors` is not specified.\n\t * @type {[type]}\n\t */\n\tbaseColor?: Color;\n\n\t/**\n\t * A set of tranformation to apply to base list of colors when the set runs\n\t * out of colors and generates additional ones.\n\t */\n\tpassOptions?: IColorSetStepOptions;\n\n\t/**\n\t * If set, each returned color will be applied saturation.\n\t */\n\tsaturation?: number;\n\n\t// count?: number;\n}\n\nexport interface IColorSetPrivate extends IEntityPrivate {\n\n\tcurrentStep?: number;\n\tcurrentPass?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tnumColors?: number;\n\n}\n\nexport interface IColorSetStepOptions {\n\n\t/**\n\t * Value to add to \"hue\".\n\t */\n\thue?: number;\n\n\t/**\n\t * Value to add to \"saturation\".\n\t */\n\tsaturation?: number;\n\n\t/**\n\t * Value to add to \"lightness\".\n\t */\n\tlightness?: number;\n\n}\n\n\n/**\n * An object which holds list of colors and can generate new ones.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\n */\nexport class ColorSet extends Entity {\n\tpublic static className: string = \"ColorSet\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([ColorSet.className]);\n\n\tdeclare public _settings: IColorSetSettings;\n\tdeclare public _privateSettings: IColorSetPrivate;\n\n\t//protected _currentPass: number = 0;\n\n\tprotected _afterNew() {\n\t\t// Applying themes because color set will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t}\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\t\tif (this.isDirty(\"startIndex\")) {\n\t\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0))\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic generateColors(): void {\n\t\tthis.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1)\n\t\tconst pass = this.getPrivate(\"currentPass\");\n\t\tconst colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\t\tif (!this.getPrivate(\"numColors\")) {\n\t\t\tthis.setPrivate(\"numColors\", colors.length);\n\t\t}\n\t\t//const len = colors.length;\n\t\tconst len = this.getPrivate(\"numColors\")!;\n\t\t//const start = len - this.getPrivate(\"numColors\")!;\n\t\tconst start = 0;\n\t\tconst passOptions = this.get(\"passOptions\")!;\n\t\tconst reuse = this.get(\"reuse\");\n\t\tfor (let i = start; i < len; i++) {\n\t\t\tif (reuse) {\n\t\t\t\tcolors.push(colors[i])\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst hsl = colors[i]!.toHSL();\n\t\t\t\tlet h = hsl.h + (passOptions.hue || 0) * pass!;\n\t\t\t\twhile (h > 1) h -= 1;\n\n\t\t\t\tlet s = hsl.s + (passOptions.saturation || 0) * pass!;\n\t\t\t\t//if (s > 1) s -= Math.floor(s);\n\t\t\t\tif (s > 1) s = 1;\n\t\t\t\tif (s < 0) s = 0;\n\n\t\t\t\tlet l = hsl.l + (passOptions.lightness || 0) * pass!;\n\t\t\t\t//if (l > 1) l -= Math.floor(l);\n\t\t\t\twhile (l > 1) l -= 1;\n\t\t\t\tcolors.push(Color.fromHSL(h, s, l));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a [[Color]] at specific index.\n\t *\n\t * If there's no color at this index, a new color is generated.\n\t *\n\t * @param   index  Index\n\t * @return         Color\n\t */\n\tpublic getIndex(index: number): Color {\n\t\tconst colors = this.get(\"colors\", []);\n\t\tconst saturation = this.get(\"saturation\");\n\t\tif (index >= colors.length) {\n\t\t\tthis.generateColors();\n\t\t\treturn this.getIndex(index);\n\t\t}\n\n\t\treturn saturation != null ? Color.saturate(colors[index], saturation!) : colors[index];\n\t}\n\n\t/**\n\t * Returns next [[Color]] in the list.\n\t *\n\t * If the list is out of colors, new ones are generated dynamically.\n\t */\n\tpublic next() {\n\t\tlet currentStep = this.getPrivate(\"currentStep\", 0);\n\t\tthis.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n\t\treturn this.getIndex(currentStep);\n\t}\n\n\t/**\n\t * Resets counter to the start of the list, so the next call for `next()` will\n\t * return the first color.\n\t */\n\tpublic reset() {\n\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t}\n}\n"]}