{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { CategoryAxis } from \"./CategoryAxis\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Category-based date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\r\n * @important\r\n */\n\nvar CategoryDateAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryDateAxis, _super);\n\n  function CategoryDateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_itemMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.fields.push(\"category\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var _this = this; // temp\n\n\n      this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n      var renderer = this.get(\"renderer\");\n      var len = this.dataItems.length;\n      var startIndex = this.startIndex();\n\n      if (startIndex > 0) {\n        startIndex--;\n      }\n\n      var endIndex = this.endIndex();\n\n      if (endIndex < len) {\n        endIndex++;\n      }\n\n      var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n      var frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n      startIndex = Math.floor(startIndex / frequency) * frequency;\n      this._frequency = frequency;\n\n      for (var j = 0; j < len; j++) {\n        this.dataItems[j].hide();\n      }\n\n      var startTime = Number(this.dataItems[startIndex].get(\"category\"));\n      var endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n      var realDuration = endTime - startTime - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration(); // if all items are on axis\n\n      var gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n      var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n        gridInterval = __assign({}, baseInterval);\n      }\n\n      var formats = this.get(\"dateFormats\");\n      var previousValue = -Infinity;\n      var previousIndex = -Infinity;\n      var previousUnitValue = -Infinity;\n      var format;\n      var selectedItems = [];\n      var changed = false;\n\n      for (var i = startIndex; i < endIndex; i++) {\n        var dataItem = this.dataItems[i];\n        var index = dataItem.get(\"index\");\n        var skip = false;\n        var value = Number(dataItem.get(\"category\"));\n        var date = new Date(value);\n        var unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n        format = formats[gridInterval.timeUnit];\n        var added = false;\n\n        if (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n              format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n\n              if (index - frequency * 0.5 < previousIndex) {\n                selectedItems.pop();\n              }\n\n              selectedItems.push({\n                format: format,\n                dataItem: dataItem\n              });\n              changed = true;\n              added = true;\n              previousIndex = index;\n              previousUnitValue = unitValue;\n            }\n          }\n        }\n\n        var shouldAdd = false;\n\n        if (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n          if (index - previousIndex >= frequency) {\n            shouldAdd = true;\n          }\n        } else {\n          if (unitValue % gridInterval.count === 0) {\n            if (unitValue != previousUnitValue) {\n              shouldAdd = true;\n            }\n          }\n        }\n\n        if (!added && shouldAdd) {\n          if (index - frequency * 0.7 < previousIndex) {\n            if (changed) {\n              skip = true;\n            }\n          }\n\n          if (!skip) {\n            selectedItems.push({\n              format: format,\n              dataItem: dataItem\n            });\n            previousIndex = index;\n            previousUnitValue = unitValue;\n          }\n\n          changed = false;\n        }\n\n        previousValue = value;\n      }\n\n      if (selectedItems.length > 0) {\n        var f_1 = selectedItems[0].dataItem.get(\"index\", 0);\n        $array.each(selectedItems, function (item) {\n          var dataItem = item.dataItem;\n          var format = item.format;\n\n          _this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          var value = Number(dataItem.get(\"category\"));\n          var date = new Date(value);\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", _this._root.dateFormatter.format(date, format));\n          }\n\n          f_1++;\n\n          _this._prepareDataItem(dataItem, f_1, frequency);\n        });\n      }\n    }\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(position) {\n      //@todo number formatter + tag\n      var dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\n      if (dataItem) {\n        var format = this.get(\"dateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n        return this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n      }\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_updateTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(tooltip, position) {\n      tooltip.label.set(\"text\", this.getTooltipText(position));\n    }\n  });\n  Object.defineProperty(CategoryDateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"CategoryDateAxis\"\n  });\n  Object.defineProperty(CategoryDateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: CategoryAxis.classNames.concat([CategoryDateAxis.className])\n  });\n  return CategoryDateAxis;\n}(CategoryAxis);\n\nexport { CategoryDateAxis };","map":{"version":3,"sources":["../../../../../../src/.internal/charts/xy/axes/CategoryDateAxis.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport { CategoryAxis, ICategoryAxisSettings, ICategoryAxisPrivate, ICategoryAxisDataItem, ICategoryAxisEvents } from \"./CategoryAxis\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport type { Tooltip } from \"../../../core/render/Tooltip\";\n\nexport interface ICategoryDateAxisSettings<R extends AxisRenderer> extends ICategoryAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\n\t */\n\ttooltipDateFormat?: string;\n\n}\n\nexport interface ICategoryDateAxisDataItem extends ICategoryAxisDataItem {\n}\n\nexport interface ICategoryDateAxisPrivate extends ICategoryAxisPrivate {\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n}\n\nexport interface ICategoryDateAxisEvents extends ICategoryAxisEvents {\n}\n\n\n/**\n * Category-based date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\n * @important\n */\nexport class CategoryDateAxis<R extends AxisRenderer> extends CategoryAxis<R> {\n\tpublic static className: string = \"CategoryDateAxis\";\n\tpublic static classNames: Array<string> = CategoryAxis.classNames.concat([CategoryDateAxis.className]);\n\n\tdeclare public _settings: ICategoryDateAxisSettings<R>;\n\tdeclare public _privateSettings: ICategoryDateAxisPrivate;\n\tdeclare public _dataItemSettings: ICategoryDateAxisDataItem;\n\tdeclare public _events: ICategoryDateAxisEvents;\n\n\tprotected _frequency: number = 1;\n\n\tprotected _itemMap: { [index: string]: DataItem<ICategoryDateAxisDataItem> } = {};\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.fields.push(\"category\");\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _prepareAxisItems() {\n\t\t// temp\n\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\n\t\tconst renderer = this.get(\"renderer\");\n\t\tconst len = this.dataItems.length;\n\n\t\tlet startIndex = this.startIndex();\n\t\tif (startIndex > 0) {\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tlet endIndex = this.endIndex();\n\t\tif (endIndex < len) {\n\t\t\tendIndex++;\n\t\t}\n\n\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1 / Number.MAX_SAFE_INTEGER);\n\n\t\tlet frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\n\t\tthis._frequency = frequency;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tthis.dataItems[j].hide();\n\t\t}\n\n\t\tlet startTime = Number(this.dataItems[startIndex].get(\"category\"));\n\t\tlet endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n\n\t\tlet realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\n\n\t\t// if all items are on axis\n\t\tlet gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\")!);\n\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\tgridInterval = { ...baseInterval };\n\t\t}\n\n\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\tlet previousValue = -Infinity;\n\t\tlet previousIndex = -Infinity;\n\t\tlet previousUnitValue = -Infinity;\n\t\tlet format: string;\n\n\t\tlet selectedItems: Array<{ format: string, dataItem: DataItem<ICategoryDateAxisDataItem> }> = [];\n\t\tlet changed = false;\n\n\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\tlet dataItem = this.dataItems[i];\n\t\t\tlet index = dataItem.get(\"index\")!;\n\t\t\tlet skip = false;\n\n\t\t\tlet value = Number(dataItem.get(\"category\"));\n\t\t\tlet date = new Date(value);\n\t\t\tlet unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n\n\t\t\tformat = formats[gridInterval.timeUnit];\n\t\t\tlet added = false;\n\n\t\t\tif (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\n\t\t\t\t\tif ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\n\t\t\t\t\t\tif (index - frequency * 0.5 < previousIndex) {\n\t\t\t\t\t\t\tselectedItems.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tselectedItems.push({ format: format, dataItem: dataItem });\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\tpreviousIndex = index;\n\t\t\t\t\t\tpreviousUnitValue = unitValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet shouldAdd = false;\n\t\t\tif (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n\t\t\t\tif (index - previousIndex >= frequency) {\n\t\t\t\t\tshouldAdd = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (unitValue % gridInterval.count === 0) {\n\t\t\t\t\tif (unitValue != previousUnitValue) {\n\t\t\t\t\t\tshouldAdd = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!added && shouldAdd) {\n\t\t\t\tif (index - frequency * 0.7 < previousIndex) {\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skip) {\n\t\t\t\t\tselectedItems.push({ format: format, dataItem: dataItem });\n\t\t\t\t\tpreviousIndex = index;\n\t\t\t\t\tpreviousUnitValue = unitValue;\n\t\t\t\t}\n\t\t\t\tchanged = false;\n\n\t\t\t}\n\n\t\t\tpreviousValue = value;\n\n\t\t}\n\n\t\tif (selectedItems.length > 0) {\n\t\t\tlet f = selectedItems[0].dataItem.get(\"index\", 0);\n\n\t\t\t$array.each(selectedItems, (item) => {\n\t\t\t\tconst dataItem = item.dataItem;\n\t\t\t\tconst format = item.format;\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tlet value = Number(dataItem.get(\"category\"));\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\t\t\t\tf++;\n\t\t\t\tthis._prepareDataItem(dataItem, f, frequency);\n\t\t\t})\n\n\t\t}\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tlet dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\n\t\tif (dataItem) {\n\t\t\tlet format = this.get(\"dateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\t\treturn this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n\t\t}\n\t}\n\n\tprotected _updateTooltipText(tooltip: Tooltip, position: number) {\n\t\ttooltip.label.set(\"text\", this.getTooltipText(position));\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}