{"ast":null,"code":"import { isNumber } from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\nexport function round(value, precision, floor) {\n  if (!isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\nexport function ceil(value, precision) {\n  if (!isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\nexport function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\nexport function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\nexport function fitToRange(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Returns sine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\nexport function sin(angle) {\n  return Math.sin(RADIANS * angle);\n}\n/**\r\n * Returns tan of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\nexport function tan(angle) {\n  return Math.tan(RADIANS * angle);\n}\n/**\r\n * Returns cosine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\nexport function cos(angle) {\n  return Math.cos(RADIANS * angle);\n}\n// 0 to 360\nexport function normalizeAngle(value) {\n  value = value % 360;\n  if (value < 0) {\n    value += 360;\n  }\n  return value;\n}\n// TODO this doesn't work properly for skewing, and it's probably broken for rotation too\nexport function getArcBounds(cx, cy, startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n  return {\n    left: cx + minX,\n    top: cy + minY,\n    right: cx + maxX,\n    bottom: cy + maxY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\nexport function mergeBounds(bounds) {\n  var len = bounds.length;\n  if (len > 0) {\n    var bound = bounds[0];\n    var left = bound.left;\n    var top_1 = bound.top;\n    var right = bound.right;\n    var bottom = bound.bottom;\n    if (len > 1) {\n      for (var i = 1; i < len; i++) {\n        bound = bounds[i];\n        left = Math.min(bound.left, left);\n        right = Math.max(bound.right, right);\n        top_1 = Math.min(bound.top, top_1);\n        bottom = Math.max(bound.bottom, bottom);\n      }\n    }\n    return {\n      left: left,\n      right: right,\n      top: top_1,\n      bottom: bottom\n    };\n  }\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n}\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n  return value;\n}\nexport function inBounds(point, bounds) {\n  if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n    return true;\n  }\n  return false;\n}\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return normalizeAngle(angle);\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nexport function getPointOnLine(pointA, pointB, position) {\n  return {\n    x: pointA.x + (pointB.x - pointA.x) * position,\n    y: pointA.y + (pointB.y - pointA.y) * position\n  };\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\nexport function boundsOverlap(bounds1, bounds2) {\n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}","map":{"version":3,"names":["isNumber","PI","Math","HALFPI","RADIANS","DEGREES","round","value","precision","floor","rounded","d","pow","ceil","getCubicControlPointA","p0","p1","p2","tensionX","tensionY","x","y","getCubicControlPointB","p3","fitToRange","min","max","sin","angle","tan","cos","normalizeAngle","getArcBounds","cx","cy","startAngle","endAngle","radius","minX","Number","MAX_VALUE","minY","maxX","maxY","bpoints","push","getArcPoint","fromAngle","toAngle","i","length","pt","left","top","right","bottom","arc","mergeBounds","bounds","len","bound","top_1","fitAngleToRange","temp","count","maxEnd","maxStart","inBounds","point","getAngle","point1","point2","diffX","diffY","atan2","getPointOnQuadraticCurve","pointA","pointB","controlPoint","position","getPointOnLine","closest","values","referenceValue","reduce","prev","curr","abs","boundsOverlap","bounds1","bounds2"],"sources":["../../../../../src/.internal/core/util/Math.ts"],"sourcesContent":["import type { IPoint } from \"./IPoint\";\nimport { isNumber } from \"./Type\";\nimport type { IBounds } from \"./IBounds\";\n\n/**\n * ============================================================================\n * CONSTANTS\n * ============================================================================\n * @hidden\n */\nexport const PI = Math.PI;\nexport const HALFPI = PI / 2;\nexport const RADIANS = PI / 180;\nexport const DEGREES = 180 / PI;\n\n/**\n * Rounds the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\n * @return Rounded value\n */\nexport function round(value: number, precision?: number, floor?: boolean): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\n\t\tlet rounded = Math.round(value);\n\t\tif (floor) {\n\t\t\tif (rounded - value == 0.5) {\n\t\t\t\trounded--;\n\t\t\t}\n\t\t}\n\t\treturn rounded;\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.round(value * d) / d;\n\t}\n}\n\n\n/**\n * Ceils the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @return Rounded value\n */\nexport function ceil(value: number, precision: number): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\t\treturn Math.ceil(value);\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.ceil(value * d) / d;\n\t}\n}\n\n\n/**\n * [getCubicControlPointA description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\n}\n\n/**\n * [getCubicControlPointB description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointB(p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\n}\n\n\nexport function fitToRange(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns sine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function sin(angle: number): number {\n\treturn Math.sin(RADIANS * angle);\n}\n\n/**\n * Returns tan of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function tan(angle: number): number {\n\treturn Math.tan(RADIANS * angle);\n}\n\n/**\n * Returns cosine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Cosine\n */\nexport function cos(angle: number): number {\n\treturn Math.cos(RADIANS * angle);\n}\n\n// 0 to 360\nexport function normalizeAngle(value: number): number {\n\tvalue = value % 360;\n\tif (value < 0) {\n\t\tvalue += 360;\n\t}\n\treturn value;\n}\n\n// TODO this doesn't work properly for skewing, and it's probably broken for rotation too\nexport function getArcBounds(cx: number, cy: number, startAngle: number, endAngle: number, radius: number): IBounds {\n\n\tlet minX = Number.MAX_VALUE;\n\tlet minY = Number.MAX_VALUE;\n\tlet maxX = -Number.MAX_VALUE;\n\tlet maxY = -Number.MAX_VALUE;\n\n\tlet bpoints = [];\n\n\tbpoints.push(getArcPoint(radius, startAngle));\n\tbpoints.push(getArcPoint(radius, endAngle));\n\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\n\t\tif (angle >= startAngle && angle <= endAngle) {\n\t\t\tbpoints.push(getArcPoint(radius, angle));\n\t\t}\n\t}\n\n\tfor (let i = 0; i < bpoints.length; i++) {\n\t\tlet pt = bpoints[i];\n\t\tif (pt.x < minX) { minX = pt.x; }\n\t\tif (pt.y < minY) { minY = pt.y; }\n\t\tif (pt.x > maxX) { maxX = pt.x; }\n\t\tif (pt.y > maxY) { maxY = pt.y; }\n\t}\n\n\treturn ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });\n}\n\n/**\n * Returns point on arc\n *\n * @param center point\n * @param radius\n * @param arc\n * @return {boolean}\n */\nexport function getArcPoint(radius: number, arc: number) {\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\n}\n\n\nexport function mergeBounds(bounds: IBounds[]): IBounds {\n\tconst len = bounds.length;\n\n\tif (len > 0) {\n\t\tlet bound = bounds[0];\n\t\tlet left = bound.left;\n\t\tlet top = bound.top;\n\t\tlet right = bound.right;\n\t\tlet bottom = bound.bottom;\n\n\t\tif (len > 1) {\n\t\t\tfor (let i = 1; i < len; i++) {\n\t\t\t\tbound = bounds[i];\n\t\t\t\tleft = Math.min(bound.left, left);\n\t\t\t\tright = Math.max(bound.right, right);\n\t\t\t\ttop = Math.min(bound.top, top);\n\t\t\t\tbottom = Math.max(bound.bottom, bottom);\n\t\t\t}\n\t\t}\n\n\t\treturn { left, right, top, bottom };\n\t}\n\treturn { left: 0, right: 0, top: 0, bottom: 0 };\n}\n\n\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\n\n\tif (startAngle > endAngle) {\n\t\tlet temp: number = startAngle;\n\t\tstartAngle = endAngle;\n\t\tendAngle = temp;\n\t}\n\n\tvalue = normalizeAngle(value);\n\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n\tif (value < startAngle) {\n\t\tvalue += 360 * (count + 1);\n\t}\n\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\n\n\tif (value > endAngle) {\n\n\t\tif (value - 360 > startAngle) {\n\t\t\tvalue -= 360;\n\t\t}\n\t\telse {\n\t\t\tif (value < maxEnd) {\n\t\t\t\tvalue = endAngle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = startAngle;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value < startAngle) {\n\t\tif (value > maxStart) {\n\t\t\tvalue = startAngle;\n\t\t}\n\t\telse {\n\t\t\tvalue = endAngle;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nexport function inBounds(point: IPoint, bounds: IBounds) {\n\tif (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\n\tif (!point2) {\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\n\t}\n\tlet diffX: number = point2.x - point1.x;\n\tlet diffY: number = point2.y - point1.y;\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\n\tif (angle < 0) {\n\t\tangle += 360;\n\t}\n\treturn normalizeAngle(angle);\n}\n\n/**\n * [getPointOnQuadraticCurve description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param pointA        [description]\n * @param pointB        [description]\n * @param controlPoint  [description]\n * @param position      [description]\n * @return [description]\n */\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n\treturn { x: x, y: y };\n}\n\nexport function getPointOnLine(pointA: IPoint, pointB: IPoint, position: number): IPoint {\n\treturn { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };\n}\n\n\n/**\n * Returns the closest value from the array of values to the reference value.\n *\n * @param values  Array of values\n * @param value   Reference value\n * @return Closes value from the array\n */\nexport function closest(values: number[], referenceValue: number): number {\n\treturn values.reduce(function(prev, curr) {\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\n\t});\n}\n\nexport function boundsOverlap (bounds1:IBounds, bounds2:IBounds) {  \n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}