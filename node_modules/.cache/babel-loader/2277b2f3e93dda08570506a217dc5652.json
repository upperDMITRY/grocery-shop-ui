{"ast":null,"code":"/** @ignore */ /** */\nimport * as $math from \"./Math\";\n/**\r\n * @ignore\r\n */\nexport function segmentedLine(display, segments) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n        for (var g = 0, len_1 = groups.length; g < len_1; g++) {\n          line(display, groups[g]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport function line(display, points) {\n  for (var p = 0, len = points.length; p < len; p++) {\n    var point = points[p];\n    display.lineTo(point.x, point.y);\n  }\n}\n/**\r\n * @ignore\r\n */\nexport function moveTo(display, point) {\n  display.moveTo(point.x, point.y);\n}\n/**\r\n * @ignore\r\n */\nexport function clear(display) {\n  display.clear();\n}\n/**\r\n * @ignore\r\n */\nexport function smoothedSegmentedline(display, segments, tensionX, tensionY) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n        for (var g = 0, len_2 = groups.length; g < len_2; g++) {\n          var points = groups[g];\n          if (points.length > 0) {\n            display.lineTo(points[0].x, points[0].y);\n          }\n          smoothedLine(display, points, tensionX, tensionY);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\nexport function smoothedLine(display, points, tensionX, tensionY) {\n  for (var i = points.length - 1; i > 0; i--) {\n    var p0 = points[i];\n    var p1 = points[i - 1];\n    if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n      points.splice(i - 1, 1);\n    }\n  }\n  if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n    line(display, points);\n    return;\n  }\n  tensionX = 1 - tensionX + 0.00001;\n  tensionY = 1 - tensionY + 0.00001;\n  var first = points[0];\n  var last = points[points.length - 1];\n  var closed = false;\n  if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n    closed = true;\n  }\n  // Can't moveTo here, as it wont be possible to have fill then.\n  var path = \"\";\n  for (var i = 0, len = points.length - 1; i < len; i++) {\n    var p0 = points[i - 1];\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n    if (i === 0) {\n      if (closed) {\n        p0 = points[len - 2];\n      } else {\n        p0 = points[0];\n      }\n    } else if (i == len - 1) {\n      if (closed) {\n        p3 = points[1];\n      } else {\n        p3 = p2;\n      }\n    }\n    var controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n    var controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n    display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n  }\n  return path;\n}","map":{"version":3,"names":["$math","segmentedLine","display","segments","s","len","length","groups","firstGroup","firstPoint","moveTo","x","y","g","len_1","line","points","p","point","lineTo","clear","smoothedSegmentedline","tensionX","tensionY","len_2","smoothedLine","i","p0","p1","Math","abs","splice","first","last","closed","round","path","p2","p3","controlPointA","getCubicControlPointA","controlPointB","getCubicControlPointB","bezierCurveTo"],"sources":["../../../../../src/.internal/core/util/Draw.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport type { IPoint } from \"./IPoint\"\nimport * as $math from \"./Math\";\nimport type { IGraphics } from \"../render/backend/Renderer\";\n\n/**\n * @ignore\n */\nexport function segmentedLine(display: IGraphics, segments: Array<Array<Array<IPoint>>>) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tline(display, groups[g]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function line(display: IGraphics, points: Array<IPoint>) {\n\tfor (let p = 0, len = points.length; p < len; p++) {\n\t\tconst point = points[p];\n\t\tdisplay.lineTo(point.x, point.y);\n\t}\n}\n\n/**\n * @ignore\n */\nexport function moveTo(display: IGraphics, point: IPoint) {\n\tdisplay.moveTo(point.x, point.y);\n}\n\n/**\n * @ignore\n */\nexport function clear(display: IGraphics) {\n\tdisplay.clear();\n}\n\n/**\n * @ignore\n */\nexport function smoothedSegmentedline(display: IGraphics, segments: Array<Array<Array<IPoint>>>, tensionX: number, tensionY: number) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tconst points = groups[g];\n\t\t\t\t\tif (points.length > 0) {\n\t\t\t\t\t\tdisplay.lineTo(points[0].x, points[0].y)\n\t\t\t\t\t}\n\t\t\t\t\tsmoothedLine(display, points, tensionX, tensionY);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function smoothedLine(display: IGraphics, points: Array<IPoint>, tensionX: number, tensionY: number) {\n\n\tfor (let i = points.length - 1; i > 0; i--) {\n\t\tlet p0 = points[i];\n\t\tlet p1 = points[i - 1];\n\n\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\tpoints.splice(i - 1, 1);\n\t\t}\n\t}\n\n\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\tline(display, points);\n\t\treturn;\n\t}\n\n\ttensionX = 1 - tensionX + 0.00001;\n\ttensionY = 1 - tensionY + 0.00001;\n\n\tlet first = points[0];\n\tlet last = points[points.length - 1];\n\n\tlet closed: boolean = false;\n\n\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\tclosed = true;\n\t}\n\n\t// Can't moveTo here, as it wont be possible to have fill then.\n\tlet path: string = \"\";\n\n\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\tlet p0: IPoint = points[i - 1];\n\n\t\tlet p1: IPoint = points[i];\n\n\t\tlet p2: IPoint = points[i + 1];\n\n\t\tlet p3: IPoint = points[i + 2];\n\n\t\tif (i === 0) {\n\t\t\tif (closed) {\n\t\t\t\tp0 = points[len - 2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp0 = points[0];\n\t\t\t}\n\t\t} else if (i == len - 1) {\n\t\t\tif (closed) {\n\t\t\t\tp3 = points[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp3 = p2;\n\t\t\t}\n\t\t}\n\n\n\t\tlet controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n\t\tlet controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n\n\t\tdisplay.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n\t}\n\n\treturn path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}