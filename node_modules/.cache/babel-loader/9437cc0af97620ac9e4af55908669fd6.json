{"ast":null,"code":"import { __extends } from \"tslib\"; // import * as $object from \"../util/Object\";\n\nimport { p50, Percent } from \"../util/Percent\";\nimport { Label } from \"./Label\";\nimport { RadialText } from \"./RadialText\";\nimport * as $math from \"../util/Math\";\nimport * as $utils from \"../util/Utils\";\n\nvar RadialLabel =\n/** @class */\nfunction (_super) {\n  __extends(RadialLabel, _super);\n\n  function RadialLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_flipped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    return _this;\n  }\n\n  Object.defineProperty(RadialLabel.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._textKeys.push(\"textType\", \"kerning\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(RadialLabel.prototype, \"_makeText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._text = this.children.push(RadialText.new(this._root, {}));\n    }\n  });\n  /**\r\n   * Returns base radius in pixels.\r\n   *\r\n   * @return Base radius\r\n   */\n\n  Object.defineProperty(RadialLabel.prototype, \"baseRadius\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var radiusPrivate = this.getPrivate(\"radius\", 0);\n      var innerRadiusPrivate = this.getPrivate(\"innerRadius\", 0);\n      var baseRadius = this.get(\"baseRadius\", 0);\n      return innerRadiusPrivate + $utils.relativeToValue(baseRadius, radiusPrivate - innerRadiusPrivate);\n    }\n  });\n  /**\r\n   * Returns radius adjustment in pixels.\r\n   *\r\n   * @return Radius\r\n   */\n\n  Object.defineProperty(RadialLabel.prototype, \"radius\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var inside = this.get(\"inside\", false);\n      return this.baseRadius() + this.get(\"radius\", 0) * (inside ? -1 : 1);\n    }\n  });\n  Object.defineProperty(RadialLabel.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._updateChildren.call(this);\n\n      if (this.isDirty(\"baseRadius\") || this.isPrivateDirty(\"radius\") || this.isPrivateDirty(\"innerRadius\") || this.isDirty(\"labelAngle\") || this.isDirty(\"radius\") || this.isDirty(\"inside\") || this.isDirty(\"orientation\") || this.isDirty(\"textType\")) {\n        var textType = this.get(\"textType\", \"adjusted\");\n        var inside = this.get(\"inside\", false);\n        var orientation_1 = this.get(\"orientation\");\n        var labelAngle = $math.normalizeAngle(this.get(\"labelAngle\", 0));\n\n        this._text.set(\"startAngle\", this.get(\"labelAngle\", 0));\n\n        this._text.set(\"inside\", inside);\n\n        var sin = $math.sin(labelAngle);\n        var cos = $math.cos(labelAngle);\n        var baseRadius = this.baseRadius();\n        var radius = this.radius();\n        this._display.angle = 0;\n\n        if (textType == \"circular\") {\n          this.setAll({\n            paddingTop: 0,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0\n          }); // Circular labels are handled and positioned differently\n\n          this._text.set(\"orientation\", orientation_1);\n\n          this._text.set(\"radius\", radius);\n        } else {\n          if (baseRadius == 0) {\n            labelAngle = 0;\n            radius = 0;\n          } // Positioning of radial/regular labels are teh same\n\n\n          var x = radius * cos;\n          var y = radius * sin;\n\n          if (textType == \"radial\") {\n            this.setRaw(\"x\", x);\n            this.setRaw(\"y\", y);\n\n            if (labelAngle < 90 || labelAngle > 270 || orientation_1 != \"auto\") {\n              this._display.angle = labelAngle; // + 90;\n\n              this._flipped = false;\n            } else {\n              this._display.angle = labelAngle + 180;\n              this._flipped = true;\n            }\n\n            this._dirty.rotation = false;\n          } else if (textType == \"adjusted\") {\n            this.setRaw(\"centerX\", p50);\n            this.setRaw(\"centerY\", p50);\n            this.setRaw(\"x\", x);\n            this.setRaw(\"y\", y);\n          } else if (textType == \"regular\") {\n            this.setRaw(\"x\", x);\n            this.setRaw(\"y\", y);\n          }\n        }\n\n        this.markDirtyPosition();\n        this.markDirtyBounds();\n      }\n    }\n  });\n  Object.defineProperty(RadialLabel.prototype, \"_updatePosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var textType = this.get(\"textType\", \"regular\");\n      var inside = this.get(\"inside\", false);\n      var dx = 0;\n      var dy = 0;\n      var labelAngle = this.get(\"labelAngle\", 0);\n      var bounds = this.localBounds();\n      var w = bounds.right - bounds.left;\n      var h = bounds.bottom - bounds.top;\n\n      if (textType == \"radial\") {\n        if (this._flipped) {\n          var centerX = this.get(\"centerX\");\n\n          if (centerX instanceof Percent) {\n            w = w * (1 - centerX.value * 2);\n          }\n\n          dx = w * $math.cos(labelAngle);\n          dy = w * $math.sin(labelAngle);\n        }\n      } else if (!inside && textType == \"adjusted\") {\n        dx = w / 2 * $math.cos(labelAngle);\n        dy = h / 2 * $math.sin(labelAngle);\n      }\n\n      this.setRaw(\"dx\", dx);\n      this.setRaw(\"dy\", dy);\n\n      _super.prototype._updatePosition.call(this);\n    }\n  });\n  Object.defineProperty(RadialLabel.prototype, \"text\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._text;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RadialLabel, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"RadialLabel\"\n  });\n  Object.defineProperty(RadialLabel, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Label.classNames.concat([RadialLabel.className])\n  });\n  return RadialLabel;\n}(Label);\n\nexport { RadialLabel };","map":{"version":3,"sources":["../../../../../src/.internal/core/render/RadialLabel.ts"],"names":[],"mappings":"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","sourcesContent":["// import * as $object from \"../util/Object\";\nimport { p50, Percent } from \"../util/Percent\";\nimport { Label, ILabelPrivate, ILabelSettings } from \"./Label\";\nimport { RadialText } from \"./RadialText\";\n\nimport * as $math from \"../util/Math\";\nimport * as $utils from \"../util/Utils\";\n\n\nexport interface IRadialLabelSettings extends ILabelSettings {\n\n\t/**\n\t * Pixel value to adjust radius with.\n\t *\n\t * Will add to (or subtract from if negative) whatever value `baseRadius` evaluates\n\t * to.\n\t */\n\tradius?: number;\n\n\t/**\n\t * Radius of the label's position.\n\t *\n\t * Can be either set in absolute pixel value, or percent.\n\t *\n\t * Relative value, depending on the situation, will most often mean its\n\t * position within certain circular object, like a slice: 0% meaning inner\n\t * edge, and 100% - the outer edge.\n\t *\n\t * @default 100%\n\t */\n\tbaseRadius?: number | Percent;\n\n\t/**\n\t * Label anngle in degrees.\n\t *\n\t * In most cases it will be set by the chart/series and does not need to\n\t * be set manually.\n\t */\n\tlabelAngle?: number;\n\n\t/**\n\t * Should the text \"face\" inward or outward from the arc the text is\n\t * following.\n\t *\n\t * `\"auto\"` means that facing will be chosen automatically based on the angle\n\t * to enhance readbility.\n\t *\n\t * Only applies if `type = \"circluar\"`.\n\t * \n\t * @default \"auto\"\n\t */\n\torientation?: \"inward\" | \"outward\" | \"auto\";\n\n\t/**\n\t * Should label be drawn inside (`true`) or outside (`false`) the arc.\n\t *\n\t * @default false\n\t */\n\tinside?: boolean;\n\n\t/**\n\t * Label type.\n\t *\n\t * * `\"regular\"` (default) - normal horizontal label.\n\t * * `\"circular\"` - arched label.\n\t * * `\"radial\"` - label radiating from the center of the arc.\n\t * * `\"aligned\"` - horizontal label aligned with other labels horizontally.\n\t * * `\"adjusted\"` - horizontal label adjusted in postion.\n\t *\n\t * @default \"regular\"\n\t */\n\ttextType?: \"regular\" | \"circular\" | \"radial\" | \"aligned\" | \"adjusted\";\n\n\t/**\n\t * Extra spacing between characters, in pixels.\n\t *\n\t * @default 0\n\t */\n\tkerning?: number;\n\n}\n\nexport interface IRadialLabelPrivate extends ILabelPrivate {\n\n\t/**\n\t * @ignore\n\t */\n\tleft?: boolean;\n\n\t/**\n\t * @ignore\n\t */\n\tradius?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tinnerRadius?: number;\n\n}\n\nexport class RadialLabel extends Label {\n\n\tdeclare public _settings: IRadialLabelSettings;\n\tdeclare public _privateSettings: IRadialLabelPrivate;\n\n\tdeclare protected _text: RadialText;\n\n\tpublic static className: string = \"RadialLabel\";\n\tpublic static classNames: Array<string> = Label.classNames.concat([RadialLabel.className]);\n\n\tprotected _flipped: boolean = false;\n\n\tprotected _afterNew() {\n\t\tthis._textKeys.push(\"textType\", \"kerning\");\n\t\tsuper._afterNew();\n\t}\n\n\n\tpublic _makeText() {\n\t\tthis._text = this.children.push(RadialText.new(this._root, {}));\n\t}\n\n\t/**\n\t * Returns base radius in pixels.\n\t * \n\t * @return Base radius\n\t */\n\tpublic baseRadius(): number {\n\t\tconst radiusPrivate = this.getPrivate(\"radius\", 0);\n\t\tconst innerRadiusPrivate = this.getPrivate(\"innerRadius\", 0);\n\t\tconst baseRadius = this.get(\"baseRadius\", 0);\n\t\treturn innerRadiusPrivate + $utils.relativeToValue(baseRadius, radiusPrivate - innerRadiusPrivate);\n\t}\n\n\t/**\n\t * Returns radius adjustment in pixels.\n\t * \n\t * @return Radius\n\t */\n\tpublic radius(): number {\n\t\tconst inside = this.get(\"inside\", false);\n\t\treturn this.baseRadius() + this.get(\"radius\", 0) * (inside ? -1 : 1);\n\t}\n\n\tpublic _updateChildren() {\n\t\tsuper._updateChildren();\n\n\t\tif (this.isDirty(\"baseRadius\") || this.isPrivateDirty(\"radius\") || this.isPrivateDirty(\"innerRadius\") || this.isDirty(\"labelAngle\") || this.isDirty(\"radius\") || this.isDirty(\"inside\") || this.isDirty(\"orientation\") || this.isDirty(\"textType\")) {\n\n\t\t\tconst textType = this.get(\"textType\", \"adjusted\");\n\n\t\t\tconst inside = this.get(\"inside\", false);\n\n\t\t\tconst orientation = this.get(\"orientation\");\n\t\t\tlet labelAngle = $math.normalizeAngle(this.get(\"labelAngle\", 0));\n\n\t\t\tthis._text.set(\"startAngle\", this.get(\"labelAngle\", 0));\n\t\t\tthis._text.set(\"inside\", inside);\n\n\t\t\tconst sin = $math.sin(labelAngle);\n\t\t\tconst cos = $math.cos(labelAngle);\n\n\t\t\tlet baseRadius = this.baseRadius();\n\t\t\tlet radius = this.radius();\n\n\t\t\tthis._display.angle = 0;\n\n\t\t\tif (textType == \"circular\") {\n\n\t\t\t\tthis.setAll({\n\t\t\t\t\tpaddingTop: 0,\n\t\t\t\t\tpaddingBottom: 0,\n\t\t\t\t\tpaddingLeft: 0,\n\t\t\t\t\tpaddingRight: 0\n\t\t\t\t});\n\n\t\t\t\t// Circular labels are handled and positioned differently\n\n\t\t\t\tthis._text.set(\"orientation\", orientation);\n\t\t\t\tthis._text.set(\"radius\", radius);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (baseRadius == 0) {\n\t\t\t\t\tlabelAngle = 0;\n\t\t\t\t\tradius = 0;\n\t\t\t\t}\n\n\t\t\t\t// Positioning of radial/regular labels are teh same\n\t\t\t\tlet x = radius * cos;\n\t\t\t\tlet y = radius * sin;\n\n\t\t\t\tif (textType == \"radial\") {\n\n\t\t\t\t\tthis.setRaw(\"x\", x);\n\t\t\t\t\tthis.setRaw(\"y\", y);\n\n\t\t\t\t\tif ((labelAngle < 90) || (labelAngle > 270) || orientation != \"auto\") {\n\t\t\t\t\t\tthis._display.angle = labelAngle;// + 90;\n\t\t\t\t\t\tthis._flipped = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._display.angle = labelAngle + 180;\n\t\t\t\t\t\tthis._flipped = true;\n\t\t\t\t\t}\n\t\t\t\t\tthis._dirty.rotation = false;\n\t\t\t\t}\n\t\t\t\telse if (textType == \"adjusted\") {\n\t\t\t\t\tthis.setRaw(\"centerX\", p50);\n\t\t\t\t\tthis.setRaw(\"centerY\", p50);\n\t\t\t\t\tthis.setRaw(\"x\", x);\n\t\t\t\t\tthis.setRaw(\"y\", y);\n\t\t\t\t}\n\t\t\t\telse if (textType == \"regular\") {\n\t\t\t\t\tthis.setRaw(\"x\", x);\n\t\t\t\t\tthis.setRaw(\"y\", y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.markDirtyPosition();\n\t\t\tthis.markDirtyBounds();\n\t\t}\n\t}\n\n\n\tpublic _updatePosition() {\n\n\t\tconst textType = this.get(\"textType\", \"regular\");\n\t\tconst inside = this.get(\"inside\", false);\n\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\t\tlet labelAngle = this.get(\"labelAngle\", 0);\n\t\tlet bounds = this.localBounds();\n\t\tlet w = bounds.right - bounds.left;\n\t\tlet h = bounds.bottom - bounds.top;\n\n\t\tif (textType == \"radial\") {\n\t\t\tif (this._flipped) {\n\t\t\t\tlet centerX = this.get(\"centerX\");\n\t\t\t\tif (centerX instanceof Percent) {\n\t\t\t\t\tw = w * (1 - centerX.value * 2);\n\t\t\t\t}\n\n\t\t\t\tdx = w * $math.cos(labelAngle);\n\t\t\t\tdy = w * $math.sin(labelAngle);\n\t\t\t}\n\t\t}\n\t\telse if (!inside && textType == \"adjusted\") {\n\t\t\tdx = w / 2 * $math.cos(labelAngle);\n\t\t\tdy = h / 2 * $math.sin(labelAngle);\n\t\t}\n\n\n\t\tthis.setRaw(\"dx\", dx);\n\t\tthis.setRaw(\"dy\", dy);\n\n\t\tsuper._updatePosition();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic get text(): RadialText {\n\t\treturn this._text;\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}