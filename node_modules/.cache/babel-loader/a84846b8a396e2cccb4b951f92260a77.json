{"ast":null,"code":"/** @ignore */ /** */\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n/**\r\n * @ignore\r\n */\nexport function populateString(target, string) {\n  if (string != null) {\n    string = \"\" + string;\n    string = TextFormatter.escape(string);\n    var tags = string.match(/\\{([^}]+)\\}/g);\n    var i = void 0;\n    if (tags) {\n      for (i = 0; i < tags.length; i++) {\n        var tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n        var value = getTagValue(target, tag, \"\");\n        if (value == null) {\n          value = \"\";\n        }\n        string = string.split(tags[i]).join(value);\n      }\n    }\n    string = TextFormatter.unescape(string);\n  } else {\n    string = \"\";\n  }\n  // TODO: apply adapter?\n  return string;\n}\n/**\r\n * @ignore\r\n */\nfunction getTagValue(target, tagName, format) {\n  var value;\n  var dataItem = target.dataItem;\n  // Parse parts\n  var parts = [];\n  var reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;\n  ;\n  var matches;\n  while (true) {\n    matches = reg.exec(tagName);\n    if (matches === null) {\n      break;\n    }\n    if (matches[3]) {\n      // Simple property\n      parts.push({\n        prop: matches[3]\n      });\n      // Check if maybe we should force a formatter on this value\n      var dateFields = target.getDateFormatter().get(\"dateFields\", []);\n      var numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n      var durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n      if (dateFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDate\",\n          params: []\n        });\n      } else if (numericFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatNumber\",\n          params: []\n        });\n      } else if (durationFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDuration\",\n          params: []\n        });\n      }\n    } else {\n      // Method\n      // Parse parameters\n      var params = [];\n      if ($utils.trim(matches[2]) != \"\") {\n        var reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n        var matches2 = void 0;\n        while (true) {\n          matches2 = reg2.exec(matches[2]);\n          if (matches2 === null) {\n            break;\n          }\n          params.push(matches2[1] || matches2[2] || matches2[3]);\n        }\n      }\n      parts.push({\n        method: matches[1],\n        params: params\n      });\n    }\n  }\n  // Check if we can retrieve the value from data item\n  if (dataItem) {\n    // Check values\n    value = getTagValueFromObject(target, parts, dataItem._settings);\n    // Check properties\n    if (value == null || $type.isObject(value)) {\n      // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n      value = getTagValueFromObject(target, parts, dataItem);\n    }\n    // Check data context\n    var dataContext = dataItem.dataContext;\n    if (value == null && dataContext) {\n      value = getTagValueFromObject(target, parts, dataContext);\n      // Maybe it's a literal dot-separated name of the key in dataContext?\n      if (value == null) {\n        value = getTagValueFromObject(target, [{\n          prop: tagName\n        }], dataContext);\n      }\n      // scond data context level sometimes exist (tree map)\n      if (value == null && dataContext.dataContext) {\n        value = getTagValueFromObject(target, parts, dataContext.dataContext);\n      }\n    }\n    // Check component's data item\n    if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n      value = getTagValue(dataItem.component, tagName, format);\n    }\n  }\n  // Check sprite's properties\n  if (value == null) {\n    value = getTagValueFromObject(target, parts, target);\n  }\n  // Finally, check the parent\n  if (value == null && target.parent) {\n    value = getTagValue(target.parent, tagName, format);\n  }\n  return value;\n}\n/**\r\n * @ignore\r\n */\nfunction getTagValueFromObject(target, parts, object, format) {\n  var current = object;\n  var formatApplied = false;\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n    if (part.prop) {\n      // Regular property\n      if (current instanceof Sprite) {\n        current = current.get(part.prop) || current.getPrivate(part.prop) || current[part.prop];\n      } else if (current.get) {\n        current = current.get(part.prop) || current[part.prop];\n      } else {\n        current = current[part.prop];\n      }\n      if (current == null) {\n        // Not set, return undefined\n        return;\n      }\n    } else {\n      // Method\n      switch (part.method) {\n        case \"formatNumber\":\n          var numberValue = $type.toNumber(current);\n          if (numberValue != null) {\n            current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n          break;\n        case \"formatDate\":\n          var dateValue = $type.toDate(current);\n          if (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n            // Was not able to get date out of value, quitting and letting\n            // calling method try another value\n            return;\n          }\n          if (dateValue != null) {\n            current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n          break;\n        case \"formatDuration\":\n          var durationValue = $type.toNumber(current);\n          if (durationValue != null) {\n            current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);\n            formatApplied = true;\n          }\n          break;\n        case \"urlEncode\":\n        case \"encodeURIComponent\":\n          current = encodeURIComponent(current);\n          break;\n        default:\n          if (current[part.method]) {\n            current[part.method].apply(object, part.params);\n          }\n          break;\n      }\n    }\n  }\n  // Apply default format if it wasn't applied explicitly\n  if (!formatApplied) {\n    var formatParts = [{\n      method: \"\",\n      params: format\n    }];\n    if (format == null) {\n      // Format is not set\n      // Determine from the type of the value\n      if ($type.isNumber(current)) {\n        formatParts[0].method = \"formatNumber\";\n        formatParts[0].params = \"\";\n      } else if ($type.isDate(current)) {\n        formatParts[0].method = \"formatDate\";\n        formatParts[0].params = \"\";\n      }\n    } else {\n      // Format set\n      // Try to determine formatter based on the format\n      var formatterType = $utils.getFormat(format);\n      // format\n      if (formatterType === \"number\") {\n        formatParts[0].method = \"formatNumber\";\n      } else if (formatterType === \"date\") {\n        formatParts[0].method = \"formatDate\";\n      } else if (formatterType === \"duration\") {\n        formatParts[0].method = \"formatDuration\";\n      }\n    }\n    // Apply format\n    if (formatParts[0].method) {\n      current = getTagValueFromObject(target, formatParts, current);\n    }\n  }\n  return current;\n}","map":{"version":3,"names":["$type","$utils","Sprite","TextFormatter","populateString","target","string","escape","tags","match","i","length","tag","replace","value","getTagValue","split","join","unescape","tagName","format","dataItem","parts","reg","matches","exec","push","prop","dateFields","getDateFormatter","get","numericFields","getNumberFormatter","durationFields","getDurationFormatter","indexOf","method","params","trim","reg2","matches2","getTagValueFromObject","_settings","isObject","dataContext","component","parent","object","current","formatApplied","len","part","getPrivate","numberValue","toNumber","undefined","dateValue","toDate","isDate","isNaN","getTime","durationValue","encodeURIComponent","apply","formatParts","isNumber","formatterType","getFormat"],"sources":["../../../../../src/.internal/core/util/PopulateString.ts"],"sourcesContent":["/** @ignore *//** */\n\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n\n/**\n * @ignore\n */\nexport function populateString(target: Sprite, string: string): string {\n\tif (string != null) {\n\t\tstring = \"\" + string;\n\t\tstring = TextFormatter.escape(string);\n\t\tlet tags = string.match(/\\{([^}]+)\\}/g);\n\t\tlet i;\n\t\tif (tags) {\n\t\t\tfor (i = 0; i < tags.length; i++) {\n\t\t\t\tlet tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n\t\t\t\tlet value = getTagValue(target, tag, \"\");\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\n\t\t\t\tstring = string.split(tags[i]).join(value);\n\t\t\t}\n\t\t}\n\t\tstring = TextFormatter.unescape(string);\n\t}\n\telse {\n\t\tstring = \"\";\n\t}\n\n\t// TODO: apply adapter?\n\treturn string;\n}\n\n/**\n * @ignore\n */\nfunction getTagValue(target: Sprite, tagName: string, format?: string): string {\n\tlet value: any;\n\tconst dataItem = target.dataItem;\n\n\t// Parse parts\n\tlet parts: any[] = [];\n\tlet reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;;\n\tlet matches;\n\n\twhile (true) {\n\t\tmatches = reg.exec(tagName);\n\n\t\tif (matches === null) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (matches[3]) {\n\t\t\t// Simple property\n\t\t\tparts.push({\n\t\t\t\tprop: matches[3]\n\t\t\t});\n\n\t\t\t// Check if maybe we should force a formatter on this value\n\t\t\tconst dateFields = target.getDateFormatter().get(\"dateFields\", []);\n\t\t\tconst numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n\t\t\tconst durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n\t\t\tif ((<any>dateFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatDate\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((<any>numericFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatNumber\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((<any>durationFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatDuration\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Method\n\t\t\t// Parse parameters\n\t\t\tlet params: any[] = [];\n\t\t\tif ($utils.trim(matches[2]) != \"\") {\n\t\t\t\tlet reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n\t\t\t\tlet matches2;\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tmatches2 = reg2.exec(matches[2]);\n\n\t\t\t\t\tif (matches2 === null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.push(matches2[1] || matches2[2] || matches2[3])\n\t\t\t\t}\n\t\t\t}\n\t\t\tparts.push({\n\t\t\t\tmethod: matches[1],\n\t\t\t\tparams: params\n\t\t\t})\n\t\t}\n\t}\n\n\t// Check if we can retrieve the value from data item\n\tif (dataItem) {\n\n\n\t\t// Check values\n\t\tvalue = getTagValueFromObject(target, parts, dataItem._settings);\n\n\t\t// Check properties\n\t\tif (value == null || $type.isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n\t\t\tvalue = getTagValueFromObject(target, parts, dataItem);\n\t\t}\n\n\t\t// Check data context\n\t\tlet dataContext: any = dataItem.dataContext;\n\n\t\tif (value == null && dataContext) {\n\t\t\tvalue = getTagValueFromObject(target, parts, dataContext);\n\n\t\t\t// Maybe it's a literal dot-separated name of the key in dataContext?\n\t\t\tif (value == null) {\n\t\t\t\tvalue = getTagValueFromObject(target, [{\n\t\t\t\t\tprop: tagName\n\t\t\t\t}], dataContext);\n\t\t\t}\n\n\t\t\t// scond data context level sometimes exist (tree map)\n\t\t\tif (value == null && dataContext.dataContext) {\n\t\t\t\tvalue = getTagValueFromObject(target, parts, dataContext.dataContext);\n\t\t\t}\n\t\t}\n\n\t\t// Check component's data item\n\t\tif (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n\t\t\tvalue = getTagValue(dataItem.component, tagName, format);\n\t\t}\n\t}\n\n\t// Check sprite's properties\n\tif (value == null) {\n\t\tvalue = getTagValueFromObject(target, parts, target);\n\t}\n\n\t// Finally, check the parent\n\tif (value == null && target.parent) {\n\t\tvalue = getTagValue(target.parent, tagName, format);\n\t}\n\n\treturn value;\n}\n\n/**\n * @ignore\n */\nfunction getTagValueFromObject(target: Sprite, parts: any[], object: any, format?: string): any {\n\tlet current: any = object;\n\tlet formatApplied = false;\n\tfor (let i = 0, len = parts.length; i < len; i++) {\n\t\tlet part = parts[i];\n\t\tif (part.prop) {\n\t\t\t// Regular property\n\t\t\tif (current instanceof Sprite) {\n\t\t\t\tcurrent = current.get(part.prop) || current.getPrivate(part.prop) || (<any>current)[part.prop];\n\t\t\t}\n\t\t\telse if (current.get) {\n\t\t\t\tcurrent = current.get(part.prop) || (<any>current)[part.prop];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent = current[part.prop];\n\t\t\t}\n\t\t\tif (current == null) {\n\t\t\t\t// Not set, return undefined\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Method\n\n\t\t\tswitch (part.method) {\n\t\t\t\tcase \"formatNumber\":\n\t\t\t\t\tlet numberValue = $type.toNumber(current);\n\t\t\t\t\tif (numberValue != null) {\n\t\t\t\t\t\tcurrent = target.getNumberFormatter().format(\n\t\t\t\t\t\t\tnumberValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"formatDate\":\n\t\t\t\t\tlet dateValue = $type.toDate(current);\n\t\t\t\t\tif (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n\t\t\t\t\t\t// Was not able to get date out of value, quitting and letting\n\t\t\t\t\t\t// calling method try another value\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (dateValue != null) {\n\t\t\t\t\t\tcurrent = target.getDateFormatter().format(\n\t\t\t\t\t\t\tdateValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"formatDuration\":\n\t\t\t\t\tlet durationValue = $type.toNumber(current);\n\t\t\t\t\tif (durationValue != null) {\n\t\t\t\t\t\tcurrent = target.getDurationFormatter().format(\n\t\t\t\t\t\t\tdurationValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined,\n\t\t\t\t\t\t\tpart.params[1] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"urlEncode\":\n\t\t\t\tcase \"encodeURIComponent\":\n\t\t\t\t\tcurrent = encodeURIComponent(current);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (current[part.method]) {\n\t\t\t\t\t\tcurrent[part.method].apply(object, part.params);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply default format if it wasn't applied explicitly\n\tif (!formatApplied) {\n\n\t\tlet formatParts = [{\n\t\t\tmethod: \"\",\n\t\t\tparams: format\n\t\t}];\n\n\t\tif (format == null) {\n\n\t\t\t// Format is not set\n\t\t\t// Determine from the type of the value\n\t\t\tif ($type.isNumber(current)) {\n\t\t\t\tformatParts[0].method = \"formatNumber\";\n\t\t\t\tformatParts[0].params = \"\";\n\t\t\t}\n\t\t\telse if ($type.isDate(current)) {\n\t\t\t\tformatParts[0].method = \"formatDate\";\n\t\t\t\tformatParts[0].params = \"\";\n\t\t\t}\n\n\t\t}\n\t\telse {\n\n\t\t\t// Format set\n\t\t\t// Try to determine formatter based on the format\n\t\t\tlet formatterType: string = $utils.getFormat(format);\n\n\t\t\t// format\n\t\t\tif (formatterType === \"number\") {\n\t\t\t\tformatParts[0].method = \"formatNumber\";\n\t\t\t}\n\t\t\telse if (formatterType === \"date\") {\n\t\t\t\tformatParts[0].method = \"formatDate\";\n\t\t\t}\n\t\t\telse if (formatterType === \"duration\") {\n\t\t\t\tformatParts[0].method = \"formatDuration\";\n\t\t\t}\n\n\t\t}\n\n\t\t// Apply format\n\t\tif (formatParts[0].method) {\n\t\t\tcurrent = getTagValueFromObject(target, formatParts, current);\n\t\t}\n\n\t}\n\n\treturn current;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}