{"ast":null,"code":"import * as $type from \"./Type\";\nimport * as $object from \"./Object\";\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\n\nvar JSONParser =\n/** @class */\nfunction () {\n  function JSONParser() {}\n  /**\r\n   * Parses JSON string.\r\n   *\r\n   * @param   input    JSON\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n\n\n  Object.defineProperty(JSONParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options);\n\n      try {\n        if ($type.isString(input)) {\n          var data = JSON.parse(input);\n\n          if (options.reverse && $type.isArray(data)) {\n            data.reverse();\n          }\n\n          return data;\n        } else if ($type.isArray(input) || $type.isObject(input)) {\n          return input;\n        } else {\n          throw \"Unable to parse JSON data\";\n        }\n      } catch (e) {\n        return undefined;\n      }\n    }\n  });\n  Object.defineProperty(JSONParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        reverse: false\n      };\n\n      if (!options) {\n        options = {};\n      }\n\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return JSONParser;\n}();\n\nexport { JSONParser };\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\n\nvar CSVParser =\n/** @class */\nfunction () {\n  function CSVParser() {}\n  /**\r\n   * Parses CSV string.\r\n   *\r\n   * @param   input    CSV\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n\n\n  Object.defineProperty(CSVParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options); // Get CSV data as array\n\n      var data = this.CSVToArray(input, options.delimiter); // Init resuling array\n\n      var res = [],\n          cols = [],\n          col,\n          i; // Skip rows\n\n      for (i = 0; i < options.skipRows; i++) {\n        data.shift();\n      } // First row holds column names?\n\n\n      if (options.useColumnNames) {\n        cols = data.shift(); // Normalize column names\n\n        for (var x = 0; x < cols.length; x++) {\n          // trim\n          col = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\"; // Check for empty\n\n          if (\"\" === col) {\n            col = \"col\" + x;\n          }\n\n          cols[x] = col;\n        }\n      } // Iterate through the result set\n\n\n      var row;\n\n      while (true) {\n        row = options.reverse ? data.pop() : data.shift();\n\n        if (!row) {\n          break;\n        }\n\n        if (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n          continue;\n        }\n\n        var dataPoint = {};\n\n        for (i = 0; i < row.length; i++) {\n          col = undefined === cols[i] ? \"col\" + i : cols[i];\n          dataPoint[col] = row[i];\n        }\n\n        res.push(dataPoint);\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(CSVParser, \"CSVToArray\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (data, delimiter) {\n      // Check to see if the delimiter is defined. If not,\n      // then default to comma.\n      delimiter = delimiter || ','; // Create a regular expression to parse the CSV values.\n\n      var objPattern = new RegExp( // Delimiters.\n      \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" + // Quoted fields.\n      \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" + // Standard fields.\n      \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\"); // Create an array to hold our data. Give the array\n      // a default empty first row.\n\n      var arrData = [[]]; // Create an array to hold our individual pattern\n      // matching groups.\n\n      var arrMatches = null; // Keep looping over the regular expression matches\n      // until we can no longer find a match.\n\n      while (true) {\n        arrMatches = objPattern.exec(data);\n\n        if (!arrMatches) {\n          break;\n        } // Get the delimiter that was found.\n\n\n        var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n\n        if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n          // Since we have reached a new row of data,\n          // add an empty row to our data array.\n          arrData.push([]);\n        } // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n\n\n        var strMatchedValue = void 0;\n\n        if (arrMatches[2]) {\n          // We found a quoted value. When we capture\n          // this value, unescape any double quotes.\n          strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n        } else {\n          // We found a non-quoted value.\n          strMatchedValue = arrMatches[3];\n        } // Now that we have our value string, let's add\n        // it to the data array.\n\n\n        arrData[arrData.length - 1].push(strMatchedValue);\n      } // Return the parsed data.\n\n\n      return arrData;\n    }\n  });\n  Object.defineProperty(CSVParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        delimiter: \",\",\n        reverse: false,\n        skipRows: 0,\n        skipEmpty: true,\n        useColumnNames: false\n      };\n\n      if (!options) {\n        options = {};\n      }\n\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return CSVParser;\n}();\n\nexport { CSVParser };","map":{"version":3,"sources":["../../../../../src/.internal/core/util/DataParser.ts"],"names":[],"mappings":"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","sourcesContent":["import * as $type from \"./Type\"\nimport * as $object from \"./Object\"\n\nexport interface IJSONParserOptions {\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class JSONParser {\n\n\t/**\n\t * Parses JSON string.\n\t * \n\t * @param   input    JSON\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: IJSONParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\t\ttry {\n\t\t\tif ($type.isString(input)) {\n\t\t\t\tlet data  = JSON.parse(input);\n\t\t\t\tif (options.reverse && $type.isArray(data)) {\n\t\t\t\t\tdata.reverse();\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if ($type.isArray(input) || $type.isObject(input)) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow(\"Unable to parse JSON data\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprotected static _applyDefaults(options?: IJSONParserOptions): IJSONParserOptions {\n\t\tconst normalized: IJSONParserOptions = {};\n\t\tconst defaults = {\n\t\t\treverse: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\t}\n}\n\n\nexport interface ICSVParserOptions {\n\n\t/**\n\t * Delimiter used for columns.\n\t * \n\t * @default \",\"\n\t */\n\tdelimiter?: string;\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n\t/**\n\t * Skip first X rows.\n\t *\n\t * @default 0\n\t */\n\tskipRows?: number;\n\n\t/**\n\t * Skip empty rows.\n\t *\n\t * @default true\n\t */\n\tskipEmpty?: boolean;\n\n\t/**\n\t * Use the first row to name the columns.\n\t * \n\t * @default false\n\t */\n\tuseColumnNames?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class CSVParser {\n\n\t/**\n\t * Parses CSV string.\n\t * \n\t * @param   input    CSV\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: ICSVParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\n\t\t// Get CSV data as array\n\t\tlet data = this.CSVToArray(input, options.delimiter!);\n\n\t\t// Init resuling array\n\t\tlet res: any[] = [],\n\t\t\tcols: string[] = [],\n\t\t\tcol: string,\n\t\t\ti: number;\n\n\t\t// Skip rows\n\t\tfor (i = 0; i < options.skipRows!; i++) {\n\t\t\tdata.shift();\n\t\t}\n\n\t\t// First row holds column names?\n\t\tif (options.useColumnNames) {\n\t\t\tcols = data.shift();\n\n\t\t\t// Normalize column names\n\t\t\tfor (let x = 0; x < cols.length; x++) {\n\t\t\t\t// trim\n\t\t\t\tcol = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n\n\t\t\t\t// Check for empty\n\t\t\t\tif (\"\" === col) {\n\t\t\t\t\tcol = \"col\" + x;\n\t\t\t\t}\n\n\t\t\t\tcols[x] = col;\n\t\t\t}\n\t\t}\n\n\t\t// Iterate through the result set\n\t\tlet row;\n\t\twhile (true) {\n\t\t\trow = options.reverse ? data.pop() : data.shift();\n\n\t\t\tif (!row) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dataPoint: any = {};\n\t\t\tfor (i = 0; i < row.length; i++) {\n\t\t\t\tcol = undefined === cols[i] ? \"col\" + i : cols[i];\n\t\t\t\tdataPoint[col] = row[i];\n\t\t\t}\n\t\t\tres.push(dataPoint);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic static CSVToArray(data: string, delimiter: string): any[] {\n\n\t\t// Check to see if the delimiter is defined. If not,\n\t\t// then default to comma.\n\t\tdelimiter = (delimiter || ',');\n\n\t\t// Create a regular expression to parse the CSV values.\n\t\tlet objPattern = new RegExp(\n\t\t\t(\n\t\t\t\t// Delimiters.\n\t\t\t\t\"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n\t\t\t\t// Quoted fields.\n\t\t\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n\t\t\t\t// Standard fields.\n\t\t\t\t\"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"\n\t\t\t),\n\t\t\t\"gi\"\n\t\t);\n\n\n\t\t// Create an array to hold our data. Give the array\n\t\t// a default empty first row.\n\t\tlet arrData: any[] = [\n\t\t\t[]\n\t\t];\n\n\t\t// Create an array to hold our individual pattern\n\t\t// matching groups.\n\t\tlet arrMatches = null;\n\n\t\t// Keep looping over the regular expression matches\n\t\t// until we can no longer find a match.\n\t\twhile (true) {\n\t\t\tarrMatches = objPattern.exec(data);\n\n\t\t\tif (!arrMatches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get the delimiter that was found.\n\t\t\tlet strMatchedDelimiter = arrMatches[1];\n\n\t\t\t// Check to see if the given delimiter has a length\n\t\t\t// (is not the start of string) and if it matches\n\t\t\t// field delimiter. If id does not, then we know\n\t\t\t// that this delimiter is a row delimiter.\n\t\t\tif (\n\t\t\t\tstrMatchedDelimiter.length &&\n\t\t\t\t(strMatchedDelimiter !== delimiter)\n\t\t\t) {\n\n\t\t\t\t// Since we have reached a new row of data,\n\t\t\t\t// add an empty row to our data array.\n\t\t\t\tarrData.push([]);\n\n\t\t\t}\n\n\t\t\t// Now that we have our delimiter out of the way,\n\t\t\t// let's check to see which kind of value we\n\t\t\t// captured (quoted or unquoted).\n\t\t\tlet strMatchedValue;\n\t\t\tif (arrMatches[2]) {\n\n\t\t\t\t// We found a quoted value. When we capture\n\t\t\t\t// this value, unescape any double quotes.\n\t\t\t\tstrMatchedValue = arrMatches[2].replace(\n\t\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"),\n\t\t\t\t\t\"\\\"\"\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// We found a non-quoted value.\n\t\t\t\tstrMatchedValue = arrMatches[3];\n\n\t\t\t}\n\n\t\t\t// Now that we have our value string, let's add\n\t\t\t// it to the data array.\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\n\t\t}\n\n\t\t// Return the parsed data.\n\t\treturn (arrData);\n\t}\n\n\tprotected static _applyDefaults(options?: ICSVParserOptions): ICSVParserOptions {\n\t\tconst normalized: ICSVParserOptions = {};\n\t\tconst defaults = {\n\t\t\tdelimiter: \",\",\n\t\t\treverse: false,\n\t\t\tskipRows: 0,\n\t\t\tskipEmpty: true,\n\t\t\tuseColumnNames: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\n\t}\n\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}