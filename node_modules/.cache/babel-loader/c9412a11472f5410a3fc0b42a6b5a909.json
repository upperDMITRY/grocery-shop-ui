{"ast":null,"code":"import * as $array from \"./Array\";\nexport function keys(object) {\n  return Object.keys(object);\n}\n/**\r\n * Returns an array of object's property names ordered using specific ordering\r\n * function.\r\n *\r\n * @param object  Source object\r\n * @param order   Ordering function\r\n * @returns Object property names\r\n */\n\nexport function keysOrdered(object, order) {\n  return keys(object).sort(order);\n}\nexport function copy(object) {\n  return Object.assign({}, object);\n}\nexport function each(object, f) {\n  keys(object).forEach(function (key) {\n    f(key, object[key]);\n  });\n}\n/**\r\n * Iterates through all properties of the object calling `fn` for each of them.\r\n *\r\n * If return value of the function evaluates to `false` further iteration is\r\n * cancelled.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n */\n\nexport function eachContinue(object, fn) {\n  for (var key in object) {\n    if (hasKey(object, key)) {\n      if (!fn(key, object[key])) {\n        break;\n      }\n    }\n  }\n}\n/**\r\n * Orders object properties using custom `ord` function and iterates through\r\n * them calling `fn` for each of them.\r\n *\r\n * @param object  Source object\r\n * @param fn      Callback function\r\n * @param order   Ordering function\r\n */\n\nexport function eachOrdered(object, fn, ord) {\n  $array.each(keysOrdered(object, ord), function (key) {\n    fn(key, object[key]);\n  });\n}\n/**\r\n * Checks if `object` has a specific `key`.\r\n *\r\n * @param object  Source object\r\n * @param key     Property name\r\n * @returns Has key?\r\n */\n\nexport function hasKey(object, key) {\n  return {}.hasOwnProperty.call(object, key);\n}\n/**\r\n * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.\r\n *\r\n * @param fromObject  Source object\r\n * @param toObject    Target object\r\n * @return Updated target object\r\n * @todo Maybe consolidate with utils.copy?\r\n */\n\nexport function softCopyProperties(source, target) {\n  each(source, function (key, value) {\n    // only if value is set\n    //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {\n    if (value != null && target[key] == null) {\n      target[key] = value;\n    }\n  });\n  return target;\n}","map":{"version":3,"sources":["../../../../../src/.internal/core/util/Object.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAZ,MAAwB,SAAxB;AAGA,OAAM,SAAU,IAAV,CAAkB,MAAlB,EAA2B;AAChC,SAAO,MAAM,CAAC,IAAP,CAAY,MAAZ,CAAP;AACA;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,WAAV,CAA8B,MAA9B,EAA8C,KAA9C,EAAmG;AACxG,SAAO,IAAI,CAAC,MAAD,CAAJ,CAAa,IAAb,CAAkB,KAAlB,CAAP;AACA;AAED,OAAM,SAAU,IAAV,CAAkB,MAAlB,EAA2B;AAChC,SAAO,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,MAAlB,CAAP;AACA;AAED,OAAM,SAAU,IAAV,CAAkB,MAAlB,EAA6B,CAA7B,EAAoG;AACzG,EAAA,IAAI,CAAC,MAAD,CAAJ,CAAa,OAAb,CAAqB,UAAC,GAAD,EAAI;AACxB,IAAA,CAAC,CAAC,GAAD,EAAM,MAAM,CAAC,GAAD,CAAZ,CAAD;AACA,GAFD;AAGA;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAU,YAAV,CAA+B,MAA/B,EAA+C,EAA/C,EAAuH;AAC5H,OAAK,IAAI,GAAT,IAAgB,MAAhB,EAAwB;AACvB,QAAI,MAAM,CAAC,MAAD,EAAS,GAAT,CAAV,EAAyB;AACxB,UAAI,CAAC,EAAE,CAAC,GAAD,EAAuB,MAAM,CAAC,GAAD,CAA7B,CAAP,EAAqE;AACpE;AACA;AACD;AACD;AACD;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,WAAV,CAA8B,MAA9B,EAA8C,EAA9C,EAAqH,GAArH,EAAwK;AAC7K,EAAA,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,MAAD,EAAS,GAAT,CAAvB,EAAsC,UAAC,GAAD,EAAI;AACzC,IAAA,EAAE,CAAC,GAAD,EAAM,MAAM,CAAC,GAAD,CAAZ,CAAF;AACA,GAFD;AAGA;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,MAAV,CAAmD,MAAnD,EAAmE,GAAnE,EAA2E;AAChF,SAAO,GAAG,cAAH,CAAkB,IAAlB,CAAuB,MAAvB,EAA+B,GAA/B,CAAP;AACA;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,kBAAV,CAA6B,MAA7B,EAA6C,MAA7C,EAA2D;AAChE,EAAA,IAAI,CAAC,MAAD,EAAS,UAAC,GAAD,EAAM,KAAN,EAAW;AACvB;AACA;AACA,QAAI,KAAK,IAAI,IAAT,IAAuB,MAAO,CAAC,GAAD,CAAP,IAAgB,IAA3C,EAAiD;AAC1C,MAAA,MAAO,CAAC,GAAD,CAAP,GAAe,KAAf;AACN;AACD,GANG,CAAJ;AAOA,SAAO,MAAP;AACA","sourcesContent":["import * as $array from \"./Array\";\nimport type { Keyof } from \"./Type\";\n\nexport function keys<O>(object: O): Array<Keyof<O>> {\n\treturn Object.keys(object) as Array<Keyof<O>>;\n}\n\n/**\n * Returns an array of object's property names ordered using specific ordering\n * function.\n *\n * @param object  Source object\n * @param order   Ordering function\n * @returns Object property names\n */\nexport function keysOrdered<Object>(object: Object, order: (a: Keyof<Object>, b: Keyof<Object>) => number): Array<Keyof<Object>> {\n\treturn keys(object).sort(order);\n}\n\nexport function copy<O>(object: O): O {\n\treturn Object.assign({}, object);\n}\n\nexport function each<O>(object: O, f: <K extends keyof O>(key: K, value: Exclude<O[K], undefined>) => void): void {\n\tkeys(object).forEach((key) => {\n\t\tf(key, object[key] as any);\n\t});\n}\n\n/**\n * Iterates through all properties of the object calling `fn` for each of them.\n *\n * If return value of the function evaluates to `false` further iteration is\n * cancelled.\n *\n * @param object  Source object\n * @param fn      Callback function\n */\nexport function eachContinue<Object>(object: Object, fn: <Key extends Keyof<Object>>(key: Key, value: Object[Key]) => boolean): void {\n\tfor (let key in object) {\n\t\tif (hasKey(object, key)) {\n\t\t\tif (!fn(key as Keyof<Object>, object[key] as Object[Keyof<Object>])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Orders object properties using custom `ord` function and iterates through\n * them calling `fn` for each of them.\n *\n * @param object  Source object\n * @param fn      Callback function\n * @param order   Ordering function\n */\nexport function eachOrdered<Object>(object: Object, fn: <Key extends Keyof<Object>>(key: Key, value: Object[Key]) => void, ord: (a: Keyof<Object>, b: Keyof<Object>) => number): void {\n\t$array.each(keysOrdered(object, ord), (key) => {\n\t\tfn(key, object[key]);\n\t});\n}\n\n/**\n * Checks if `object` has a specific `key`.\n *\n * @param object  Source object\n * @param key     Property name\n * @returns Has key?\n */\nexport function hasKey<Object, Key extends keyof Object>(object: Object, key: Key): boolean {\n\treturn {}.hasOwnProperty.call(object, key);\n}\n\n/**\n * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.\n *\n * @param fromObject  Source object\n * @param toObject    Target object\n * @return Updated target object\n * @todo Maybe consolidate with utils.copy?\n */\nexport function softCopyProperties(source: Object, target: Object): Object {\n\teach(source, (key, value) => {\n\t\t// only if value is set\n\t\t//if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {\n\t\tif (value != null && (<any>target)[key] == null) {\n\t\t\t(<any>target)[key] = value;\n\t\t}\n\t});\n\treturn target;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}