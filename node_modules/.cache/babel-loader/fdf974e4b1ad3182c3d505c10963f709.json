{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Sprite } from \"./Sprite\";\nimport { BlendMode } from \"./backend/Renderer\";\nimport * as $type from \"../util/Type\";\nimport * as $array from \"../util/Array\";\nexport var visualSettings = [\"fill\", \"fillOpacity\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"fillPattern\", \"strokePattern\", \"fillGradient\", \"strokeGradient\", \"strokeDasharray\", \"strokeDashoffset\"];\n/**\r\n * Base class used for drawing shapes.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\n\nvar Graphics =\n/** @class */\nfunction (_super) {\n  __extends(Graphics, _super);\n\n  function Graphics() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_display\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this._root._renderer.makeGraphics()\n    });\n    Object.defineProperty(_this, \"_clear\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Graphics.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"draw\") || this.isDirty(\"svgPath\")) {\n        this.markDirtyBounds();\n      }\n\n      if (this.isDirty(\"fill\") || this.isDirty(\"stroke\") || this.isDirty(\"fillGradient\") || this.isDirty(\"strokeGradient\") || this.isDirty(\"fillPattern\") || this.isDirty(\"strokePattern\") || this.isDirty(\"fillOpacity\") || this.isDirty(\"strokeOpacity\") || this.isDirty(\"strokeWidth\") || this.isDirty(\"draw\") || this.isDirty(\"blendMode\") || this.isDirty(\"strokeDasharray\") || this.isDirty(\"strokeDashoffset\") || this.isDirty(\"svgPath\") || this.isDirty(\"shadowColor\") || this.isDirty(\"shadowBlur\") || this.isDirty(\"shadowOffsetX\") || this.isDirty(\"shadowOffsetY\")) {\n        this._clear = true;\n      }\n\n      if (this.isDirty(\"fillGradient\")) {\n        var gradient = this.get(\"fillGradient\");\n\n        if (gradient) {\n          this._display.isMeasured = true;\n          var gradientTarget = gradient.get(\"target\");\n\n          if (gradientTarget) {\n            this._disposers.push(gradientTarget.events.on(\"boundschanged\", function () {\n              _this._markDirtyKey(\"fill\");\n            }));\n\n            this._disposers.push(gradientTarget.events.on(\"positionchanged\", function () {\n              _this._markDirtyKey(\"fill\");\n            }));\n          }\n        }\n      }\n\n      if (this.isDirty(\"strokeGradient\")) {\n        var gradient = this.get(\"strokeGradient\");\n\n        if (gradient) {\n          this._display.isMeasured = true;\n          var gradientTarget = gradient.get(\"target\");\n\n          if (gradientTarget) {\n            this._disposers.push(gradientTarget.events.on(\"boundschanged\", function () {\n              _this._markDirtyKey(\"stroke\");\n            }));\n\n            this._disposers.push(gradientTarget.events.on(\"positionchanged\", function () {\n              _this._markDirtyKey(\"stroke\");\n            }));\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Graphics.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._changed.call(this);\n\n      if (this._clear) {\n        this.markDirtyLayer();\n\n        this._display.clear();\n\n        var strokeDasharray = this.get(\"strokeDasharray\");\n\n        if ($type.isNumber(strokeDasharray)) {\n          if (strokeDasharray < 0.5) {\n            strokeDasharray = [0];\n          } else {\n            strokeDasharray = [strokeDasharray];\n          }\n        }\n\n        this._display.setLineDash(strokeDasharray);\n\n        var strokeDashoffset = this.get(\"strokeDashoffset\");\n\n        if (strokeDashoffset) {\n          this._display.setLineDashOffset(strokeDashoffset);\n        }\n\n        var blendMode = this.get(\"blendMode\", BlendMode.NORMAL);\n        this._display.blendMode = blendMode;\n        var draw = this.get(\"draw\");\n\n        if (draw) {\n          draw(this._display, this);\n        }\n\n        var svgPath = this.get(\"svgPath\");\n\n        if (svgPath != null) {\n          this._display.svgPath(svgPath);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Graphics.prototype, \"_afterChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._afterChanged.call(this);\n\n      if (this._clear) {\n        var fill_1 = this.get(\"fill\");\n        var fillGradient = this.get(\"fillGradient\");\n        var fillPattern = this.get(\"fillPattern\");\n        var fillOpacity_1 = this.get(\"fillOpacity\");\n        var stroke_1 = this.get(\"stroke\");\n        var strokeGradient = this.get(\"strokeGradient\");\n        var strokePattern = this.get(\"strokePattern\");\n        var shadowColor = this.get(\"shadowColor\");\n        var shadowBlur = this.get(\"shadowBlur\");\n        var shadowOffsetX = this.get(\"shadowOffsetX\");\n        var shadowOffsetY = this.get(\"shadowOffsetY\");\n        var shadowOpacity = this.get(\"shadowOpacity\"); //const bounds = this._display.getLocalBounds();\n\n        if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n          this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n        }\n\n        if (fillPattern) {\n          var changed = false;\n\n          if (fill_1 && (!fillPattern.get(\"fill\") || fillPattern.get(\"fillInherited\"))) {\n            fillPattern.set(\"fill\", fill_1);\n            fillPattern.set(\"fillInherited\", true);\n            changed = true;\n          }\n\n          if (stroke_1 && (!fillPattern.get(\"color\") || fillPattern.get(\"colorInherited\"))) {\n            fillPattern.set(\"color\", stroke_1);\n            fillPattern.set(\"colorInherited\", true);\n            changed = true;\n          }\n\n          if (changed) {\n            // @todo: is this OK?\n            fillPattern._changed();\n          }\n\n          var pattern = fillPattern.pattern;\n\n          if (pattern) {\n            this._display.beginFill(pattern, fillOpacity_1);\n\n            this._display.endFill();\n          }\n        } else if (fillGradient) {\n          if (fill_1) {\n            var stops = fillGradient.get(\"stops\", []);\n\n            if (stops.length) {\n              $array.each(stops, function (stop) {\n                if ((!stop.color || stop.colorInherited) && fill_1) {\n                  stop.color = fill_1;\n                  stop.colorInherited = true;\n                }\n\n                if (stop.opacity == null || stop.opacityInherited) {\n                  stop.opacity = fillOpacity_1;\n                  stop.opacityInherited = true;\n                }\n              });\n            }\n          }\n\n          var gradient = fillGradient.getFill(this);\n\n          if (gradient) {\n            this._display.beginFill(gradient, fillOpacity_1);\n\n            this._display.endFill();\n          }\n        } else if (fill_1) {\n          this._display.beginFill(fill_1, fillOpacity_1);\n\n          this._display.endFill();\n        }\n\n        if (stroke_1 || strokeGradient || strokePattern) {\n          var strokeOpacity_1 = this.get(\"strokeOpacity\");\n          var strokeWidth = this.get(\"strokeWidth\", 1);\n\n          if (strokePattern) {\n            var changed = false;\n\n            if (stroke_1 && (!strokePattern.get(\"color\") || strokePattern.get(\"colorInherited\"))) {\n              strokePattern.set(\"color\", stroke_1);\n              strokePattern.set(\"colorInherited\", true);\n              changed = true;\n            }\n\n            if (changed) {\n              // @todo: is this OK?\n              strokePattern._changed();\n            }\n\n            var pattern = strokePattern.pattern;\n\n            if (pattern) {\n              this._display.lineStyle(strokeWidth, pattern, strokeOpacity_1);\n\n              this._display.endStroke();\n            }\n          } else if (strokeGradient) {\n            var stops = strokeGradient.get(\"stops\", []);\n\n            if (stops.length) {\n              $array.each(stops, function (stop) {\n                if ((!stop.color || stop.colorInherited) && stroke_1) {\n                  stop.color = stroke_1;\n                  stop.colorInherited = true;\n                }\n\n                if (stop.opacity == null || stop.opacityInherited) {\n                  stop.opacity = strokeOpacity_1;\n                  stop.opacityInherited = true;\n                }\n              });\n            }\n\n            var gradient = strokeGradient.getFill(this);\n\n            if (gradient) {\n              this._display.lineStyle(strokeWidth, gradient, strokeOpacity_1);\n\n              this._display.endStroke();\n            }\n          } else if (stroke_1) {\n            this._display.lineStyle(strokeWidth, stroke_1, strokeOpacity_1);\n\n            this._display.endStroke();\n          }\n        }\n      }\n\n      this._clear = false;\n    }\n  });\n  Object.defineProperty(Graphics, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Graphics\"\n  });\n  Object.defineProperty(Graphics, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Sprite.classNames.concat([Graphics.className])\n  });\n  return Graphics;\n}(Sprite);\n\nexport { Graphics };","map":{"version":3,"sources":["../../../../../src/.internal/core/render/Graphics.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Color } from \"../util/Color\";\nimport type { Pattern } from \"../render/patterns/Pattern\";\nimport type { Gradient } from \"../render/gradients/Gradient\";\n\nimport { ISpriteSettings, ISpritePrivate, ISpriteEvents, Sprite } from \"./Sprite\";\nimport { IGraphics, BlendMode } from \"./backend/Renderer\";\n\nimport * as $type from \"../util/Type\";\nimport * as $array from \"../util/Array\";\n\n\nexport const visualSettings = [\"fill\", \"fillOpacity\", \"stroke\", \"strokeWidth\", \"strokeOpacity\", \"fillPattern\", \"strokePattern\", \"fillGradient\", \"strokeGradient\", \"strokeDasharray\", \"strokeDashoffset\"];\n\nexport interface IGraphicsSettings extends ISpriteSettings {\n\n\t/**\n\t * Fill color.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more information\n\t */\n\tfill?: Color;\n\n\t/**\n\t * Stroke (border or line) color.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more information\n\t */\n\tstroke?: Color;\n\n\t/**\n\t * Fill pattern.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more information\n\t */\n\tfillPattern?: Pattern;\n\n\t/**\n\t * Stroke (border or line) pattern.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more information\n\t */\n\tstrokePattern?: Pattern;\n\n\t/**\n\t * Fill gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more information\n\t */\n\tfillGradient?: Gradient;\n\n\t/**\n\t * Stroke (border or line) gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more information\n\t */\n\tstrokeGradient?: Gradient;\n\n\t/**\n\t * Stroke (border or line) dash settings.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Dashed_lines} for more information\n\t */\n\tstrokeDasharray?: number[] | number;\n\n\t/**\n\t * Stroke (border or line) dash offset.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Dashed_lines} for more information\n\t */\n\tstrokeDashoffset?: number;\n\n\t/**\n\t * Opacity of the fill. 0 - fully transparent; 1 - fully opaque.\n\t */\n\tfillOpacity?: number;\n\n\t/**\n\t * Opacity of the stroke (border or line). 0 - fully transparent; 1 - fully opaque.\n\t */\n\tstrokeOpacity?: number;\n\n\t/**\n\t * Width of the stroke (border or line) in pixels.\n\t */\n\tstrokeWidth?: number;\n\n\t/**\n\t * Drawing function.\n\t *\n\t * Must use renderer (`display` parameter) methods to draw.\n\t */\n\tdraw?: (display: IGraphics, graphics: Graphics) => void;\n\n\t/**\n\t * Rendering mode.\n\t *\n\t * @default BlendMode.NORMAL (\"source-over\")\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation} for more information\n\t * @ignore\n\t */\n\tblendMode?: BlendMode;\n\n\t/**\n\t * Draw a shape using an SVG path.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n\t/**\n\t * Color of the element's shadow.\n\t *\n\t * For this to work at least one of the following needs to be set as well:\n\t * `shadowBlur`, `shadowOffsetX`, `shadowOffsetY`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowColor?: Color | null;\n\n\t/**\n\t * Blurriness of the the shadow.\n\t *\n\t * The bigger the number, the more blurry shadow will be.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowBlur?: number;\n\n\t/**\n\t * Horizontal shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetX?: number;\n\n\t/**\n\t * Vertical shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetY?: number;\n\n\t/**\n\t * Opacity of the shadow (0-1).\n\t *\n\t * If not set, will use the same as `fillOpacity` of the element.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOpacity?: number;\n\n}\n\nexport interface IGraphicsPrivate extends ISpritePrivate {\n}\n\nexport interface IGraphicsEvents extends ISpriteEvents {\n}\n\n/**\n * Base class used for drawing shapes.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\n * @important\n */\nexport class Graphics extends Sprite {\n\n\tdeclare public _settings: IGraphicsSettings;\n\tdeclare public _privateSettings: IGraphicsPrivate;\n\tdeclare public _events: IGraphicsEvents;\n\n\tpublic _display: IGraphics = this._root._renderer.makeGraphics();\n\n\tprotected _clear = false;\n\n\tpublic static className: string = \"Graphics\";\n\tpublic static classNames: Array<string> = Sprite.classNames.concat([Graphics.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"draw\") || this.isDirty(\"svgPath\")) {\n\t\t\tthis.markDirtyBounds();\n\t\t}\n\n\t\tif (this.isDirty(\"fill\") || this.isDirty(\"stroke\") || this.isDirty(\"fillGradient\") || this.isDirty(\"strokeGradient\") || this.isDirty(\"fillPattern\") || this.isDirty(\"strokePattern\") || this.isDirty(\"fillOpacity\") || this.isDirty(\"strokeOpacity\") || this.isDirty(\"strokeWidth\") || this.isDirty(\"draw\") || this.isDirty(\"blendMode\") || this.isDirty(\"strokeDasharray\") || this.isDirty(\"strokeDashoffset\") || this.isDirty(\"svgPath\") || this.isDirty(\"shadowColor\") || this.isDirty(\"shadowBlur\") || this.isDirty(\"shadowOffsetX\") || this.isDirty(\"shadowOffsetY\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\n\t\tif (this.isDirty(\"fillGradient\")) {\n\t\t\tconst gradient = this.get(\"fillGradient\");\n\t\t\tif (gradient) {\n\t\t\t\tthis._display.isMeasured = true;\n\t\t\t\tconst gradientTarget = gradient.get(\"target\");\n\t\t\t\tif (gradientTarget) {\n\t\t\t\t\tthis._disposers.push(gradientTarget.events.on(\"boundschanged\", () => {\n\t\t\t\t\t\tthis._markDirtyKey(\"fill\");\n\t\t\t\t\t}))\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"positionchanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"fill\");\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"strokeGradient\")) {\n\t\t\tconst gradient = this.get(\"strokeGradient\");\n\t\t\tif (gradient) {\n\t\t\t\tthis._display.isMeasured = true;\n\t\t\t\tconst gradientTarget = gradient.get(\"target\");\n\t\t\t\tif (gradientTarget) {\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"boundschanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"stroke\");\n\t\t\t\t\t\t}))\n\t\t\t\t\tthis._disposers.push(\n\t\t\t\t\t\tgradientTarget.events.on(\"positionchanged\", () => {\n\t\t\t\t\t\t\tthis._markDirtyKey(\"stroke\");\n\t\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this._clear) {\n\t\t\tthis.markDirtyLayer();\n\t\t\tthis._display.clear();\n\n\t\t\tlet strokeDasharray = this.get(\"strokeDasharray\");\n\t\t\tif ($type.isNumber(strokeDasharray)) {\n\t\t\t\tif (strokeDasharray < 0.5) {\n\t\t\t\t\tstrokeDasharray = [0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstrokeDasharray = [strokeDasharray]\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._display.setLineDash(strokeDasharray as number[]);\n\n\t\t\tconst strokeDashoffset = this.get(\"strokeDashoffset\");\n\t\t\tif (strokeDashoffset) {\n\t\t\t\tthis._display.setLineDashOffset(strokeDashoffset);\n\t\t\t}\n\n\t\t\tconst blendMode = this.get(\"blendMode\", BlendMode.NORMAL);\n\t\t\tthis._display.blendMode = blendMode;\n\n\t\t\tconst draw = this.get(\"draw\");\n\t\t\tif (draw) {\n\t\t\t\tdraw(this._display, this);\n\t\t\t}\n\n\t\t\tconst svgPath = this.get(\"svgPath\");\n\t\t\tif (svgPath != null) {\n\t\t\t\tthis._display.svgPath(svgPath!);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _afterChanged() {\n\t\tsuper._afterChanged();\n\n\t\tif (this._clear) {\n\t\t\tconst fill = this.get(\"fill\");\n\t\t\tconst fillGradient = this.get(\"fillGradient\");\n\t\t\tconst fillPattern = this.get(\"fillPattern\");\n\t\t\tconst fillOpacity = this.get(\"fillOpacity\");\n\n\t\t\tconst stroke = this.get(\"stroke\");\n\t\t\tconst strokeGradient = this.get(\"strokeGradient\");\n\t\t\tconst strokePattern = this.get(\"strokePattern\");\n\n\t\t\tconst shadowColor = this.get(\"shadowColor\");\n\t\t\tconst shadowBlur = this.get(\"shadowBlur\");\n\t\t\tconst shadowOffsetX = this.get(\"shadowOffsetX\");\n\t\t\tconst shadowOffsetY = this.get(\"shadowOffsetY\");\n\t\t\tconst shadowOpacity = this.get(\"shadowOpacity\");\n\n\t\t\t//const bounds = this._display.getLocalBounds();\n\n\t\t\tif (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {\n\t\t\t\tthis._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);\n\t\t\t}\n\n\t\t\tif (fillPattern) {\n\t\t\t\tlet changed = false;\n\t\t\t\tif (fill && (!fillPattern.get(\"fill\") || fillPattern.get(\"fillInherited\"))) {\n\t\t\t\t\tfillPattern.set(\"fill\", fill);\n\t\t\t\t\tfillPattern.set(\"fillInherited\", true)\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (stroke && (!fillPattern.get(\"color\") || fillPattern.get(\"colorInherited\"))) {\n\t\t\t\t\tfillPattern.set(\"color\", stroke);\n\t\t\t\t\tfillPattern.set(\"colorInherited\", true)\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (changed) {\n\t\t\t\t\t// @todo: is this OK?\n\t\t\t\t\tfillPattern._changed();\n\t\t\t\t}\n\t\t\t\tconst pattern = fillPattern.pattern;\n\t\t\t\tif (pattern) {\n\t\t\t\t\tthis._display.beginFill(pattern, fillOpacity);\n\t\t\t\t\tthis._display.endFill();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fillGradient) {\n\t\t\t\tif (fill) {\n\t\t\t\t\tconst stops = fillGradient.get(\"stops\", []);\n\t\t\t\t\tif (stops.length) {\n\t\t\t\t\t\t$array.each(stops, (stop: any) => {\n\t\t\t\t\t\t\tif ((!stop.color || stop.colorInherited) && fill) {\n\t\t\t\t\t\t\t\tstop.color = fill;\n\t\t\t\t\t\t\t\tstop.colorInherited = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stop.opacity == null || stop.opacityInherited) {\n\t\t\t\t\t\t\t\tstop.opacity = fillOpacity;\n\t\t\t\t\t\t\t\tstop.opacityInherited = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst gradient = fillGradient.getFill(this);\n\t\t\t\tif (gradient) {\n\t\t\t\t\tthis._display.beginFill(gradient, fillOpacity);\n\t\t\t\t\tthis._display.endFill();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (fill) {\n\t\t\t\tthis._display.beginFill(fill, fillOpacity);\n\t\t\t\tthis._display.endFill();\n\t\t\t}\n\n\t\t\tif (stroke || strokeGradient || strokePattern) {\n\t\t\t\tconst strokeOpacity = this.get(\"strokeOpacity\");\n\t\t\t\tconst strokeWidth = this.get(\"strokeWidth\", 1);\n\n\t\t\t\tif (strokePattern) {\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tif (stroke && (!strokePattern.get(\"color\") || strokePattern.get(\"colorInherited\"))) {\n\t\t\t\t\t\tstrokePattern.set(\"color\", stroke);\n\t\t\t\t\t\tstrokePattern.set(\"colorInherited\", true);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// @todo: is this OK?\n\t\t\t\t\t\tstrokePattern._changed();\n\t\t\t\t\t}\n\t\t\t\t\tconst pattern = strokePattern.pattern;\n\t\t\t\t\tif (pattern) {\n\t\t\t\t\t\tthis._display.lineStyle(strokeWidth, pattern, strokeOpacity);\n\t\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (strokeGradient) {\n\n\t\t\t\t\tconst stops = strokeGradient.get(\"stops\", []);\n\t\t\t\t\tif (stops.length) {\n\t\t\t\t\t\t$array.each(stops, (stop: any) => {\n\t\t\t\t\t\t\tif ((!stop.color || stop.colorInherited) && stroke) {\n\t\t\t\t\t\t\t\tstop.color = stroke;\n\t\t\t\t\t\t\t\tstop.colorInherited = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (stop.opacity == null || stop.opacityInherited) {\n\t\t\t\t\t\t\t\tstop.opacity = strokeOpacity;\n\t\t\t\t\t\t\t\tstop.opacityInherited = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tconst gradient = strokeGradient.getFill(this);\n\t\t\t\t\tif (gradient) {\n\t\t\t\t\t\tthis._display.lineStyle(strokeWidth, gradient, strokeOpacity);\n\t\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (stroke) {\n\t\t\t\t\tthis._display.lineStyle(strokeWidth, stroke, strokeOpacity);\n\t\t\t\t\tthis._display.endStroke();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tthis._clear = false;\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}