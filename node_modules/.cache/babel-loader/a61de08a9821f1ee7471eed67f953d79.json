{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { Color } from \"./Color\";\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\n\nvar ColorSet =\n/** @class */\nfunction (_super) {\n  __extends(ColorSet, _super);\n\n  function ColorSet() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } //protected _currentPass: number = 0;\n\n\n  Object.defineProperty(ColorSet.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // Applying themes because color set will not have parent\n      _super.prototype._afterNewApplyThemes.call(this);\n    }\n  });\n  Object.defineProperty(ColorSet.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"startIndex\")) {\n        this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"generateColors\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\n      var pass = this.getPrivate(\"currentPass\");\n      var colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\n      if (!this.getPrivate(\"numColors\")) {\n        this.setPrivate(\"numColors\", colors.length);\n      } //const len = colors.length;\n\n\n      var len = this.getPrivate(\"numColors\"); //const start = len - this.getPrivate(\"numColors\")!;\n\n      var start = 0;\n      var passOptions = this.get(\"passOptions\");\n      var reuse = this.get(\"reuse\");\n\n      for (var i = start; i < len; i++) {\n        if (reuse) {\n          colors.push(colors[i]);\n        } else {\n          var hsl = colors[i].toHSL();\n          var h = hsl.h + (passOptions.hue || 0) * pass;\n\n          while (h > 1) h -= 1;\n\n          var s = hsl.s + (passOptions.saturation || 0) * pass; //if (s > 1) s -= Math.floor(s);\n\n          if (s > 1) s = 1;\n          if (s < 0) s = 0;\n          var l = hsl.l + (passOptions.lightness || 0) * pass; //if (l > 1) l -= Math.floor(l);\n\n          while (l > 1) l -= 1;\n\n          colors.push(Color.fromHSL(h, s, l));\n        }\n      }\n    }\n  });\n  /**\r\n   * Returns a [[Color]] at specific index.\r\n   *\r\n   * If there's no color at this index, a new color is generated.\r\n   *\r\n   * @param   index  Index\r\n   * @return         Color\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"getIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      var colors = this.get(\"colors\", []);\n      var saturation = this.get(\"saturation\");\n\n      if (index >= colors.length) {\n        this.generateColors();\n        return this.getIndex(index);\n      }\n\n      return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\n    }\n  });\n  /**\r\n   * Returns next [[Color]] in the list.\r\n   *\r\n   * If the list is out of colors, new ones are generated dynamically.\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"next\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var currentStep = this.getPrivate(\"currentStep\", 0);\n      this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n      return this.getIndex(currentStep);\n    }\n  });\n  /**\r\n   * Resets counter to the start of the list, so the next call for `next()` will\r\n   * return the first color.\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"reset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n    }\n  });\n  Object.defineProperty(ColorSet, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"ColorSet\"\n  });\n  Object.defineProperty(ColorSet, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Entity.classNames.concat([ColorSet.className])\n  });\n  return ColorSet;\n}(Entity);\n\nexport { ColorSet };","map":{"version":3,"sources":["../../../../../src/.internal/core/util/ColorSet.ts"],"names":[],"mappings":"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","sourcesContent":["import { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\";\nimport { Color } from \"./Color\";\n\n\nexport interface IColorSetSettings extends IEntitySettings {\n\n\t/**\n\t * List of colors in the set.\n\t */\n\tcolors?: Color[];\n\n\t/**\n\t * A step size when using `next()`.\n\t *\n\t * E.g. setting to `2` will make it return every second color in the list.\n\t *\n\t * @default 1\n\t */\n\tstep?: number;\n\n\t/**\n\t * Start iterating colors from specific index.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * If set to `true`, color set will reuse existing colors from the list\n\t * inestead of generating new ones.\n\t *\n\t * @default false\n\t */\n\treuse?: boolean;\n\n\t/**\n\t * A base color to generate new colors from if `colors` is not specified.\n\t * @type {[type]}\n\t */\n\tbaseColor?: Color;\n\n\t/**\n\t * A set of tranformation to apply to base list of colors when the set runs\n\t * out of colors and generates additional ones.\n\t */\n\tpassOptions?: IColorSetStepOptions;\n\n\t/**\n\t * If set, each returned color will be applied saturation.\n\t */\n\tsaturation?: number;\n\n\t// count?: number;\n}\n\nexport interface IColorSetPrivate extends IEntityPrivate {\n\n\tcurrentStep?: number;\n\tcurrentPass?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tnumColors?: number;\n\n}\n\nexport interface IColorSetStepOptions {\n\n\t/**\n\t * Value to add to \"hue\".\n\t */\n\thue?: number;\n\n\t/**\n\t * Value to add to \"saturation\".\n\t */\n\tsaturation?: number;\n\n\t/**\n\t * Value to add to \"lightness\".\n\t */\n\tlightness?: number;\n\n}\n\n\n/**\n * An object which holds list of colors and can generate new ones.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\n */\nexport class ColorSet extends Entity {\n\tpublic static className: string = \"ColorSet\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([ColorSet.className]);\n\n\tdeclare public _settings: IColorSetSettings;\n\tdeclare public _privateSettings: IColorSetPrivate;\n\n\t//protected _currentPass: number = 0;\n\n\tprotected _afterNew() {\n\t\t// Applying themes because color set will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t}\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\t\tif (this.isDirty(\"startIndex\")) {\n\t\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0))\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic generateColors(): void {\n\t\tthis.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1)\n\t\tconst pass = this.getPrivate(\"currentPass\");\n\t\tconst colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\t\tif (!this.getPrivate(\"numColors\")) {\n\t\t\tthis.setPrivate(\"numColors\", colors.length);\n\t\t}\n\t\t//const len = colors.length;\n\t\tconst len = this.getPrivate(\"numColors\")!;\n\t\t//const start = len - this.getPrivate(\"numColors\")!;\n\t\tconst start = 0;\n\t\tconst passOptions = this.get(\"passOptions\")!;\n\t\tconst reuse = this.get(\"reuse\");\n\t\tfor (let i = start; i < len; i++) {\n\t\t\tif (reuse) {\n\t\t\t\tcolors.push(colors[i])\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst hsl = colors[i]!.toHSL();\n\t\t\t\tlet h = hsl.h + (passOptions.hue || 0) * pass!;\n\t\t\t\twhile (h > 1) h -= 1;\n\n\t\t\t\tlet s = hsl.s + (passOptions.saturation || 0) * pass!;\n\t\t\t\t//if (s > 1) s -= Math.floor(s);\n\t\t\t\tif (s > 1) s = 1;\n\t\t\t\tif (s < 0) s = 0;\n\n\t\t\t\tlet l = hsl.l + (passOptions.lightness || 0) * pass!;\n\t\t\t\t//if (l > 1) l -= Math.floor(l);\n\t\t\t\twhile (l > 1) l -= 1;\n\t\t\t\tcolors.push(Color.fromHSL(h, s, l));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a [[Color]] at specific index.\n\t *\n\t * If there's no color at this index, a new color is generated.\n\t *\n\t * @param   index  Index\n\t * @return         Color\n\t */\n\tpublic getIndex(index: number): Color {\n\t\tconst colors = this.get(\"colors\", []);\n\t\tconst saturation = this.get(\"saturation\");\n\t\tif (index >= colors.length) {\n\t\t\tthis.generateColors();\n\t\t\treturn this.getIndex(index);\n\t\t}\n\n\t\treturn saturation != null ? Color.saturate(colors[index], saturation!) : colors[index];\n\t}\n\n\t/**\n\t * Returns next [[Color]] in the list.\n\t *\n\t * If the list is out of colors, new ones are generated dynamically.\n\t */\n\tpublic next() {\n\t\tlet currentStep = this.getPrivate(\"currentStep\", 0);\n\t\tthis.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n\t\treturn this.getIndex(currentStep);\n\t}\n\n\t/**\n\t * Resets counter to the start of the list, so the next call for `next()` will\n\t * return the first color.\n\t */\n\tpublic reset() {\n\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}