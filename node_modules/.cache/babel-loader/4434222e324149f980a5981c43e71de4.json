{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Pattern } from \"./Pattern\";\nimport * as $type from \"../../util//Type\";\n/**\r\n * Line pattern.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\n\nvar LinePattern =\n/** @class */\nfunction (_super) {\n  __extends(LinePattern, _super);\n\n  function LinePattern() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(LinePattern.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"gap\")) {\n        this._clear = true;\n      }\n    }\n  });\n  Object.defineProperty(LinePattern.prototype, \"_draw\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._draw.call(this);\n\n      var w = this.get(\"width\", 100);\n      var h = this.get(\"height\", 100);\n      var gap = this.get(\"gap\", 0);\n      var strokeWidth = this.get(\"strokeWidth\", 1);\n\n      if (!gap) {\n        this._display.moveTo(0, 0);\n\n        this._display.lineTo(w, 0);\n      } else {\n        var step = gap + strokeWidth;\n        var count = h / step;\n\n        for (var i = -count; i < count * 2; i++) {\n          var y = Math.round(i * step - step / 2) + 0.5;\n\n          this._display.moveTo(-w, y);\n\n          this._display.lineTo(w * 2, y);\n        }\n      }\n\n      this._display.lineStyle(strokeWidth, this.get(\"color\"), this.get(\"colorOpacity\"));\n\n      var strokeDasharray = this.get(\"strokeDasharray\");\n\n      if ($type.isNumber(strokeDasharray)) {\n        if (strokeDasharray < 0.5) {\n          strokeDasharray = [0];\n        } else {\n          strokeDasharray = [strokeDasharray];\n        }\n      }\n\n      this._display.setLineDash(strokeDasharray);\n\n      var strokeDashoffset = this.get(\"strokeDashoffset\");\n\n      if (strokeDashoffset) {\n        this._display.setLineDashOffset(strokeDashoffset);\n      }\n\n      this._display.endStroke();\n    }\n  });\n  Object.defineProperty(LinePattern, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"LinePattern\"\n  });\n  Object.defineProperty(LinePattern, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Pattern.classNames.concat([LinePattern.className])\n  });\n  return LinePattern;\n}(Pattern);\n\nexport { LinePattern };","map":{"version":3,"sources":["../../../../../../src/.internal/core/render/patterns/LinePattern.ts"],"names":[],"mappings":";AAAA,SAAS,OAAT,QAA2D,WAA3D;AACA,OAAO,KAAK,KAAZ,MAAuB,kBAAvB;AAgBA;;;;AAIG;;AACH,IAAA,WAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAiC,EAAA,SAAA,CAAA,WAAA,EAAA,MAAA,CAAA;;AAAjC,WAAA,WAAA,GAAA;;AA2DC;;;;;;WAnDA,YAAA;AACC,MAAA,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB;;AAEA,UAAI,KAAK,OAAL,CAAa,KAAb,CAAJ,EAAyB;AACxB,aAAK,MAAL,GAAc,IAAd;AACA;AACD;;;;;;WAED,YAAA;AACC,MAAA,MAAA,CAAA,SAAA,CAAM,KAAN,CAAW,IAAX,CAAW,IAAX;;AAEA,UAAM,CAAC,GAAG,KAAK,GAAL,CAAS,OAAT,EAAkB,GAAlB,CAAV;AACA,UAAM,CAAC,GAAG,KAAK,GAAL,CAAS,QAAT,EAAmB,GAAnB,CAAV;AACA,UAAM,GAAG,GAAG,KAAK,GAAL,CAAS,KAAT,EAAgB,CAAhB,CAAZ;AACA,UAAM,WAAW,GAAG,KAAK,GAAL,CAAS,aAAT,EAAwB,CAAxB,CAApB;;AAEA,UAAI,CAAC,GAAL,EAAU;AACT,aAAK,QAAL,CAAc,MAAd,CAAqB,CAArB,EAAwB,CAAxB;;AACA,aAAK,QAAL,CAAc,MAAd,CAAqB,CAArB,EAAwB,CAAxB;AACA,OAHD,MAIK;AACJ,YAAI,IAAI,GAAG,GAAG,GAAG,WAAjB;AACA,YAAI,KAAK,GAAG,CAAC,GAAG,IAAhB;;AAEA,aAAK,IAAI,CAAC,GAAG,CAAC,KAAd,EAAqB,CAAC,GAAG,KAAK,GAAG,CAAjC,EAAoC,CAAC,EAArC,EAAyC;AACxC,cAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,GAAG,IAAJ,GAAW,IAAI,GAAG,CAA7B,IAAkC,GAA5C;;AACA,eAAK,QAAL,CAAc,MAAd,CAAqB,CAAC,CAAtB,EAAyB,CAAzB;;AACA,eAAK,QAAL,CAAc,MAAd,CAAqB,CAAC,GAAG,CAAzB,EAA4B,CAA5B;AACA;AACD;;AAED,WAAK,QAAL,CAAc,SAAd,CAAwB,WAAxB,EAAqC,KAAK,GAAL,CAAS,OAAT,CAArC,EAAwD,KAAK,GAAL,CAAS,cAAT,CAAxD;;AAEA,UAAI,eAAe,GAAG,KAAK,GAAL,CAAS,iBAAT,CAAtB;;AACA,UAAI,KAAK,CAAC,QAAN,CAAe,eAAf,CAAJ,EAAqC;AACpC,YAAI,eAAe,GAAG,GAAtB,EAA2B;AAC1B,UAAA,eAAe,GAAG,CAAC,CAAD,CAAlB;AACA,SAFD,MAGK;AACJ,UAAA,eAAe,GAAG,CAAC,eAAD,CAAlB;AACA;AACD;;AACD,WAAK,QAAL,CAAc,WAAd,CAA0B,eAA1B;;AAEA,UAAM,gBAAgB,GAAG,KAAK,GAAL,CAAS,kBAAT,CAAzB;;AACA,UAAI,gBAAJ,EAAsB;AACrB,aAAK,QAAL,CAAc,iBAAd,CAAgC,gBAAhC;AACA;;AAED,WAAK,QAAL,CAAc,SAAd;AACA;;AArDD,EAAA,MAAA,CAAA,cAAA,CAAA,WAAA,EAAA,WAAA,EAAA;oBAAA;sBAAA;kBAAA;WAAkC;AAAlC,GAAA;AACA,EAAA,MAAA,CAAA,cAAA,CAAA,WAAA,EAAA,YAAA,EAAA;oBAAA;sBAAA;kBAAA;WAA0C,OAAO,CAAC,UAAR,CAAmB,MAAnB,CAA0B,CAAC,WAAW,CAAC,SAAb,CAA1B;AAA1C,GAAA;AAqDD,SAAA,WAAA;AAAC,CA3DD,CAAiC,OAAjC,CAAA;;SAAa,W","sourcesContent":["import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\nimport * as $type from \"../../util//Type\";\n\nexport interface ILinePatternSettings extends IPatternSettings {\n\n\t/**\n\t * Gap between  lines, in pixels.\n\t *\n\t * @default 6\n\t */\n\tgap?: number;\n\n}\n\nexport interface ILinePatternPrivate extends IPatternPrivate {\n}\n\n/**\n * Line pattern.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class LinePattern extends Pattern {\n\n\tdeclare public _settings: ILinePatternSettings;\n\tdeclare public _privateSettings: ILinePatternPrivate;\n\n\tpublic static className: string = \"LinePattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([LinePattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"gap\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\tconst w = this.get(\"width\", 100);\n\t\tconst h = this.get(\"height\", 100);\n\t\tconst gap = this.get(\"gap\", 0);\n\t\tconst strokeWidth = this.get(\"strokeWidth\", 1);\n\n\t\tif (!gap) {\n\t\t\tthis._display.moveTo(0, 0);\n\t\t\tthis._display.lineTo(w, 0);\n\t\t}\n\t\telse {\n\t\t\tlet step = gap + strokeWidth;\n\t\t\tlet count = h / step;\n\n\t\t\tfor (let i = -count; i < count * 2; i++) {\n\t\t\t\tconst y = Math.round(i * step - step / 2) + 0.5;\n\t\t\t\tthis._display.moveTo(-w, y);\n\t\t\t\tthis._display.lineTo(w * 2, y);\n\t\t\t}\n\t\t}\n\n\t\tthis._display.lineStyle(strokeWidth, this.get(\"color\"), this.get(\"colorOpacity\"));\n\n\t\tlet strokeDasharray = this.get(\"strokeDasharray\");\n\t\tif ($type.isNumber(strokeDasharray)) {\n\t\t\tif (strokeDasharray < 0.5) {\n\t\t\t\tstrokeDasharray = [0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrokeDasharray = [strokeDasharray]\n\t\t\t}\n\t\t}\n\t\tthis._display.setLineDash(strokeDasharray as number[]);\n\n\t\tconst strokeDashoffset = this.get(\"strokeDashoffset\");\n\t\tif (strokeDashoffset) {\n\t\t\tthis._display.setLineDashOffset(strokeDashoffset);\n\t\t}\n\n\t\tthis._display.endStroke();\n\t}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}