{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n/**\r\n * Creates a duration axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\r\n * @important\r\n */\n\nvar DurationAxis =\n/** @class */\nfunction (_super) {\n  __extends(DurationAxis, _super);\n\n  function DurationAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DurationAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, strictMode) {\n      var e_1, _a;\n\n      var minMaxStep;\n      var durationFormatter = this.getDurationFormatter();\n      var baseUnit = this.get(\"baseUnit\"); // we don't allow to go to smaller units, setting so to avoid invalidation\n\n      this.setRaw(\"maxPrecision\", 0);\n\n      if (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n        // will fail if 0\n        if (gridCount <= 1) {\n          gridCount = 1;\n        }\n\n        gridCount = Math.round(gridCount);\n        var initialMin = min;\n        var initialMax = max;\n        var difference = max - min; // in case min and max is the same, use max\n\n        if (difference === 0) {\n          difference = Math.abs(max);\n        }\n\n        var step = difference / gridCount;\n        var divisors = [60, 30, 20, 15, 10, 2, 1];\n        var realDivisor = 1;\n\n        if (baseUnit == \"hour\") {\n          divisors = [24, 12, 6, 4, 2, 1];\n        }\n\n        try {\n          for (var divisors_1 = __values(divisors), divisors_1_1 = divisors_1.next(); !divisors_1_1.done; divisors_1_1 = divisors_1.next()) {\n            var divisor = divisors_1_1.value;\n\n            if (difference / divisor > gridCount) {\n              realDivisor = divisor;\n              break;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (divisors_1_1 && !divisors_1_1.done && (_a = divisors_1.return)) _a.call(divisors_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        var count = Math.ceil((max - min) / realDivisor / gridCount);\n        var exponent = Math.log(Math.abs(count)) * Math.LOG10E;\n        var power = Math.pow(10, Math.floor(exponent)) / 10;\n        var reducedCount = count / power; // find closest to divisor\n\n        var closest = $math.closest(divisors, reducedCount);\n        count = closest * power;\n        step = realDivisor * count;\n        min = Math.floor(min / step) * step;\n        max = Math.ceil(max / step) * step;\n\n        if (strictMode) {\n          min -= step;\n\n          if (min < 0 && initialMin >= 0) {\n            min = 0;\n          }\n\n          max += step;\n\n          if (max > 0 && initialMax <= 0) {\n            max = 0;\n          }\n        }\n\n        minMaxStep = {\n          min: min,\n          max: max,\n          step: step\n        };\n      } else {\n        minMaxStep = _super.prototype._adjustMinMax.call(this, min, max, gridCount, strictMode);\n      } // choose duration formatter based on step\n\n\n      this.setPrivate(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n      return minMaxStep;\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_formatText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var formatter = this.getDurationFormatter();\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(DurationAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var formatter = this.getDurationFormatter();\n      var extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n      var decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n      var value = $math.round(this.positionToValue(position), decimals);\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  Object.defineProperty(DurationAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DurationAxis\"\n  });\n  Object.defineProperty(DurationAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DurationAxis.className])\n  });\n  return DurationAxis;\n}(ValueAxis);\n\nexport { DurationAxis };","map":{"version":3,"sources":["../../../../../../src/.internal/charts/xy/axes/DurationAxis.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\nimport type { TimeUnit } from \"../../../core/util/Time\"\n\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IValueAxisEvents, IMinMaxStep } from \"./ValueAxis\";\n\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n\nexport interface IDurationAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * A base unit (granularity) of data.\n\t *\n\t * Used to indicate what are the base units of your data.\n\t *\n\t * Available options: `\"millisecond\"`, `\"second\"` (default), `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/#Base_unit} for more info\n\t * @default \"second\"\n\t */\n\tbaseUnit?: TimeUnit\n\n}\n\nexport interface IDurationAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDurationAxisPrivate extends IValueAxisPrivate {\n\tdurationFormat: string;\n}\n\nexport interface IDurationAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a duration axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\n * @important\n */\nexport class DurationAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DurationAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DurationAxis.className]);\n\n\tdeclare public _settings: IDurationAxisSettings<R>;\n\tdeclare public _privateSettings: IDurationAxisPrivate;\n\tdeclare public _dataItemSettings: IDurationAxisDataItem;\n\tdeclare public _events: IDurationAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, strictMode?: boolean): IMinMaxStep {\n\n\t\tlet minMaxStep: IMinMaxStep;\n\n\t\tconst durationFormatter = this.getDurationFormatter();\n\t\tconst baseUnit = this.get(\"baseUnit\");\n\t\t// we don't allow to go to smaller units, setting so to avoid invalidation\n\t\tthis.setRaw(\"maxPrecision\", 0);\n\n\t\tif (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n\t\t\t// will fail if 0\n\t\t\tif (gridCount <= 1) {\n\t\t\t\tgridCount = 1;\n\t\t\t}\n\n\t\t\tgridCount = Math.round(gridCount);\n\n\t\t\tlet initialMin: number = min;\n\t\t\tlet initialMax: number = max;\n\n\t\t\tlet difference = max - min;\n\n\t\t\t// in case min and max is the same, use max\n\t\t\tif (difference === 0) {\n\t\t\t\tdifference = Math.abs(max);\n\t\t\t}\n\n\t\t\tlet step = difference / gridCount;\n\n\t\t\tlet divisors = [60, 30, 20, 15, 10, 2, 1];\n\t\t\tlet realDivisor = 1;\n\n\t\t\tif (baseUnit == \"hour\") {\n\t\t\t\tdivisors = [24, 12, 6, 4, 2, 1];\n\t\t\t}\n\n\t\t\tfor (let divisor of divisors) {\n\t\t\t\tif (difference / divisor > gridCount) {\n\t\t\t\t\trealDivisor = divisor;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet count = Math.ceil(((max - min) / realDivisor) / gridCount);\n\n\t\t\tlet exponent: number = Math.log(Math.abs(count)) * Math.LOG10E;\n\t\t\tlet power = Math.pow(10, Math.floor(exponent)) / 10;\n\t\t\tlet reducedCount = count / power;\n\n\t\t\t// find closest to divisor\n\t\t\tlet closest = $math.closest(divisors, reducedCount);\n\t\t\tcount = closest * power;\n\n\t\t\tstep = realDivisor * count;\n\n\t\t\tmin = Math.floor(min / step) * step;\n\t\t\tmax = Math.ceil(max / step) * step;\n\n\t\t\tif (strictMode) {\n\t\t\t\tmin -= step;\n\t\t\t\tif (min < 0 && initialMin >= 0) {\n\t\t\t\t\tmin = 0;\n\t\t\t\t}\n\t\t\t\tmax += step;\n\n\t\t\t\tif (max > 0 && initialMax <= 0) {\n\t\t\t\t\tmax = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tminMaxStep = { min: min, max: max, step: step };\n\t\t}\n\t\telse {\n\t\t\tminMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);\n\t\t}\n\n\t\t// choose duration formatter based on step\n\t\tthis.setPrivate(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n\n\t\treturn minMaxStep;\n\t}\n\n\tprotected _formatText(value: number) {\n\t\tconst formatter = this.getDurationFormatter();\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\tconst formatter = this.getDurationFormatter();\n\t\tconst extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n\t\tconst decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n\t\tconst value = $math.round(this.positionToValue(position), decimals);\n\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\t\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}