{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"../../util/Entity\";\n/**\r\n * Base class for gradients.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\r\n */\n\nvar Gradient =\n/** @class */\nfunction (_super) {\n  __extends(Gradient, _super);\n\n  function Gradient() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(Gradient.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      // Applying themes because gradient will not have parent\n      _super.prototype._afterNewApplyThemes.call(this);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Gradient.prototype, \"getFill\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(_target) {\n      return {\n        addColorStop: function addColorStop(_offset, _color) {}\n      };\n    }\n  });\n  Object.defineProperty(Gradient.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      _super.prototype._changed.call(this); //if (this.isDirty(\"target\") && this.get(\"target\")) {\n      //\tthis.get(\"target\")!.events.on(\"boundschanged\", () => {\n      //\t});\n      //}\n\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Gradient.prototype, \"getBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(target) {\n      var gradientTarget = this.get(\"target\");\n\n      if (gradientTarget) {\n        var bounds = gradientTarget.globalBounds();\n        var p0 = target.toLocal({\n          x: bounds.left,\n          y: bounds.top\n        });\n        var p1 = target.toLocal({\n          x: bounds.right,\n          y: bounds.top\n        });\n        var p2 = target.toLocal({\n          x: bounds.right,\n          y: bounds.bottom\n        });\n        var p3 = target.toLocal({\n          x: bounds.left,\n          y: bounds.bottom\n        });\n        return {\n          left: Math.min(p0.x, p1.x, p2.x, p3.x),\n          top: Math.min(p0.y, p1.y, p2.y, p3.y),\n          right: Math.max(p0.x, p1.x, p2.x, p3.x),\n          bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n        };\n      }\n\n      return target._display.getLocalBounds();\n    }\n  });\n  Object.defineProperty(Gradient, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Gradient\"\n  });\n  Object.defineProperty(Gradient, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Entity.classNames.concat([Gradient.className])\n  });\n  return Gradient;\n}(Entity);\n\nexport { Gradient };","map":{"version":3,"sources":["../../../../../../src/.internal/core/render/gradients/Gradient.ts"],"names":[],"mappings":";AAIA,SAAS,MAAT,QAAwD,mBAAxD;AAsBA;;;;AAIG;;AACH,IAAA,QAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAuC,EAAA,SAAA,CAAA,QAAA,EAAA,MAAA,CAAA;;AAAvC,WAAA,QAAA,GAAA;;AAuDC;;;;;;WA/CA,iBAAA;AACC;AACA,MAAA,MAAA,CAAA,SAAA,CAAM,oBAAN,CAA0B,IAA1B,CAA0B,IAA1B;AACA;;AAED;;AAEG;;;;;;WACH,eAAe,OAAf,EAA8B;AAC7B,aAAO;AACN,QAAA,YAAY,EAAE,sBAAC,OAAD,EAAkB,MAAlB,EAAgC,CAAQ;AADhD,OAAP;AAGA;;;;;;WAED,iBAAA;AACC,MAAA,MAAA,CAAA,SAAA,CAAM,QAAN,CAAc,IAAd,CAAc,IAAd,EADD,CAGC;AACA;AAEA;AACA;;AACA;;AAED;;AAEG;;;;;;WACH,eAAiB,MAAjB,EAA+B;AAC9B,UAAM,cAAc,GAAG,KAAK,GAAL,CAAS,QAAT,CAAvB;;AACA,UAAI,cAAJ,EAAoB;AACnB,YAAI,MAAM,GAAG,cAAc,CAAC,YAAf,EAAb;AAEA,YAAM,EAAE,GAAG,MAAM,CAAC,OAAP,CAAe;AAAE,UAAA,CAAC,EAAE,MAAM,CAAC,IAAZ;AAAkB,UAAA,CAAC,EAAE,MAAM,CAAC;AAA5B,SAAf,CAAX;AACA,YAAM,EAAE,GAAG,MAAM,CAAC,OAAP,CAAe;AAAE,UAAA,CAAC,EAAE,MAAM,CAAC,KAAZ;AAAmB,UAAA,CAAC,EAAE,MAAM,CAAC;AAA7B,SAAf,CAAX;AACA,YAAM,EAAE,GAAG,MAAM,CAAC,OAAP,CAAe;AAAE,UAAA,CAAC,EAAE,MAAM,CAAC,KAAZ;AAAmB,UAAA,CAAC,EAAE,MAAM,CAAC;AAA7B,SAAf,CAAX;AACA,YAAM,EAAE,GAAG,MAAM,CAAC,OAAP,CAAe;AAAE,UAAA,CAAC,EAAE,MAAM,CAAC,IAAZ;AAAkB,UAAA,CAAC,EAAE,MAAM,CAAC;AAA5B,SAAf,CAAX;AAEA,eAAO;AACN,UAAA,IAAI,EAAE,IAAI,CAAC,GAAL,CAAS,EAAE,CAAC,CAAZ,EAAe,EAAE,CAAC,CAAlB,EAAqB,EAAE,CAAC,CAAxB,EAA2B,EAAE,CAAC,CAA9B,CADA;AAEN,UAAA,GAAG,EAAE,IAAI,CAAC,GAAL,CAAS,EAAE,CAAC,CAAZ,EAAe,EAAE,CAAC,CAAlB,EAAqB,EAAE,CAAC,CAAxB,EAA2B,EAAE,CAAC,CAA9B,CAFC;AAGN,UAAA,KAAK,EAAE,IAAI,CAAC,GAAL,CAAS,EAAE,CAAC,CAAZ,EAAe,EAAE,CAAC,CAAlB,EAAqB,EAAE,CAAC,CAAxB,EAA2B,EAAE,CAAC,CAA9B,CAHD;AAIN,UAAA,MAAM,EAAE,IAAI,CAAC,GAAL,CAAS,EAAE,CAAC,CAAZ,EAAe,EAAE,CAAC,CAAlB,EAAqB,EAAE,CAAC,CAAxB,EAA2B,EAAE,CAAC,CAA9B;AAJF,SAAP;AAMA;;AACD,aAAO,MAAM,CAAC,QAAP,CAAgB,cAAhB,EAAP;AACA;;AAhDD,EAAA,MAAA,CAAA,cAAA,CAAA,QAAA,EAAA,WAAA,EAAA;oBAAA;sBAAA;kBAAA;WAAkC;AAAlC,GAAA;AACA,EAAA,MAAA,CAAA,cAAA,CAAA,QAAA,EAAA,YAAA,EAAA;oBAAA;sBAAA;kBAAA;WAA0C,MAAM,CAAC,UAAP,CAAkB,MAAlB,CAAyB,CAAC,QAAQ,CAAC,SAAV,CAAzB;AAA1C,GAAA;AAiDD,SAAA,QAAA;AAAC,CAvDD,CAAuC,MAAvC,CAAA;;SAAsB,Q","sourcesContent":["import type { IBounds } from \"../../util/IBounds\"\nimport type { IGradient, IGradientStop } from \"../backend/Renderer\";\nimport type { Sprite } from \"../Sprite\";\n\nimport { Entity, IEntitySettings, IEntityPrivate } from \"../../util/Entity\"\n\n\nexport interface IGradientSettings extends IEntitySettings {\n\n\t/**\n\t * A list of color steps for the gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\n\t */\n\tstops?: Array<IGradientStop>;\n\n\t/**\n\t * Gradient target.\n\t */\n\ttarget?: Sprite;\n\n}\n\nexport interface IGradientPrivate extends IEntityPrivate {\n}\n\n/**\n * Base class for gradients.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\n */\nexport abstract class Gradient extends Entity {\n\n\tdeclare public _settings: IGradientSettings;\n\tdeclare public _privateSettings: IGradientPrivate;\n\n\tpublic static className: string = \"Gradient\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([Gradient.className]);\n\n\tprotected _afterNew() {\n\t\t// Applying themes because gradient will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getFill(_target: Sprite): IGradient {\n\t\treturn {\n\t\t\taddColorStop: (_offset: number, _color: string) => { }\n\t\t};\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\t//if (this.isDirty(\"target\") && this.get(\"target\")) {\n\t\t//\tthis.get(\"target\")!.events.on(\"boundschanged\", () => {\n\n\t\t//\t});\n\t\t//}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getBounds(target: Sprite): IBounds {\n\t\tconst gradientTarget = this.get(\"target\");\n\t\tif (gradientTarget) {\n\t\t\tlet bounds = gradientTarget.globalBounds();\n\n\t\t\tconst p0 = target.toLocal({ x: bounds.left, y: bounds.top });\n\t\t\tconst p1 = target.toLocal({ x: bounds.right, y: bounds.top });\n\t\t\tconst p2 = target.toLocal({ x: bounds.right, y: bounds.bottom });\n\t\t\tconst p3 = target.toLocal({ x: bounds.left, y: bounds.bottom });\n\n\t\t\treturn {\n\t\t\t\tleft: Math.min(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\ttop: Math.min(p0.y, p1.y, p2.y, p3.y),\n\t\t\t\tright: Math.max(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\tbottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n\t\t\t}\n\t\t}\n\t\treturn target._display.getLocalBounds();\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}