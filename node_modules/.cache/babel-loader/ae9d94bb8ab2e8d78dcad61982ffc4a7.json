{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\n/**\r\n * Creates a date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\r\n * @important\r\n */\nvar DateAxis = /** @class */function (_super) {\n  __extends(DateAxis, _super);\n  function DateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n  Object.defineProperty(DateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      _super.prototype._afterNew.call(this);\n      this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this.isDirty(\"baseInterval\")) {\n        this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        this.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n        var groupInterval = this.getPrivate(\"groupInterval\");\n        if (groupInterval) {\n          this.setPrivateRaw(\"baseInterval\", groupInterval);\n        } else {\n          this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n        }\n        if (this.isDirty(\"groupInterval\")) {\n          var groupInterval_1 = this.get(\"groupInterval\");\n          if (groupInterval_1) {\n            this.setRaw(\"groupIntervals\", [groupInterval_1]);\n          }\n        }\n        if (this.isDirty(\"groupData\")) {\n          if (!this._dataGrouped) {\n            if (this.get(\"groupData\")) {\n              $array.each(this.series, function (series) {\n                _this._groupSeriesData(series);\n              });\n            } else {\n              var baseInterval = this.get(\"baseInterval\");\n              var mainDataSetId_1 = baseInterval.timeUnit + baseInterval.count;\n              $array.each(this.series, function (series) {\n                series.setDataSet(mainDataSetId_1);\n              });\n              this.setPrivateRaw(\"baseInterval\", baseInterval);\n              this.setPrivateRaw(\"groupInterval\", undefined);\n              this.markDirtyExtremes();\n            }\n            this._dataGrouped = true;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupSeriesData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series) {\n      var _this = this;\n      if (this.get(\"groupData\")) {\n        // make array of intervals which will be used;\n        var intervals_1 = [];\n        var baseDuration_1 = this.baseMainDuration();\n        var groupIntervals = this.get(\"groupIntervals\");\n        if (groupIntervals) {}\n        $array.each(groupIntervals, function (interval) {\n          var intervalDuration = $time.getIntervalDuration(interval);\n          if (intervalDuration > baseDuration_1) {\n            intervals_1.push(interval);\n          }\n        });\n        series._dataSets = {};\n        var key_1 = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n        var fields_1;\n        var baseAxis = series.get(\"baseAxis\");\n        if (series.get(\"xAxis\") === baseAxis) {\n          fields_1 = series._valueYFields;\n        } else if (series.get(\"yAxis\") === baseAxis) {\n          fields_1 = series._valueXFields;\n        }\n        var dataItems_1 = series._mainDataItems;\n        var baseInterval = this.get(\"baseInterval\");\n        var mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n        series._dataSets[mainDataSetId] = dataItems_1;\n        $array.eachContinue(intervals_1, function (interval) {\n          var previousTime = -Infinity;\n          var dataSetId = interval.timeUnit + interval.count;\n          series._dataSets[dataSetId] = [];\n          var newDataItem;\n          var sum = {};\n          var count = {};\n          var groupFieldValues = {};\n          var workingFields = {};\n          $array.each(fields_1, function (field) {\n            sum[field] = 0;\n            count[field] = 0;\n            groupFieldValues[field] = series.get(field + \"Grouped\");\n            workingFields[field] = field + \"Working\";\n          });\n          $array.each(dataItems_1, function (dataItem) {\n            var time = dataItem.get(key_1);\n            var roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, _this._root.locale.firstDayOfWeek, _this._root.utc).getTime();\n            var dataContext;\n            if (previousTime < roundedTime) {\n              dataContext = $object.copy(dataItem.dataContext);\n              newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n              series._dataSets[dataSetId].push(newDataItem);\n              $array.each(fields_1, function (field) {\n                var value = dataItem.get(field);\n                if ($type.isNumber(value)) {\n                  newDataItem.setRaw(field, value);\n                  newDataItem.setRaw(workingFields[field], value);\n                  count[field]++;\n                  sum[field] += value;\n                }\n              });\n            } else {\n              $array.each(fields_1, function (field) {\n                var groupKey = groupFieldValues[field];\n                var value = dataItem.get(field);\n                if (value !== undefined) {\n                  var currentValue = newDataItem.get(field);\n                  switch (groupKey) {\n                    case \"close\":\n                      newDataItem.setRaw(field, value);\n                      break;\n                    case \"sum\":\n                      newDataItem.setRaw(field, currentValue + value);\n                      break;\n                    case \"open\":\n                      break;\n                    case \"low\":\n                      if (value < currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n                      break;\n                    case \"high\":\n                      if (value > currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n                      break;\n                    case \"average\":\n                      count[field]++;\n                      sum[field] += value;\n                      var average = sum[field] / count[field];\n                      newDataItem.setRaw(field, average);\n                      break;\n                    case \"extreme\":\n                      if (Math.abs(value) > Math.abs(currentValue)) {\n                        newDataItem.setRaw(field, value);\n                      }\n                      break;\n                  }\n                  newDataItem.setRaw(workingFields[field], newDataItem.get(field));\n                  var dataContext_1 = $object.copy(dataItem.dataContext);\n                  dataContext_1[key_1] = roundedTime;\n                  newDataItem.dataContext = dataContext_1;\n                }\n              });\n            }\n            previousTime = roundedTime;\n          });\n          if (series._dataSets[dataSetId].length < _this.get(\"groupCount\", Infinity)) {\n            return false;\n          }\n          return true;\n        });\n        if (series._dataSetId) {\n          series.setDataSet(series._dataSetId);\n        }\n        this.markDirtySize();\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_clearDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._clearDirty.call(this);\n      this._groupingCalculated = false;\n      this._dataGrouped = false;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      _super.prototype._handleRangeChange.call(this);\n      var selectionMin = this.getPrivate(\"selectionMin\");\n      var selectionMax = this.getPrivate(\"selectionMax\");\n      if ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n        if (this.get(\"groupData\") && !this._groupingCalculated) {\n          this._groupingCalculated = true;\n          var baseInterval = this.get(\"baseInterval\");\n          var modifiedDifference = selectionMax - selectionMin + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n          var groupInterval = this.get(\"groupInterval\");\n          if (!groupInterval) {\n            var groupIntervals = this.get(\"groupIntervals\");\n            if (groupIntervals) {\n              groupInterval = $time.chooseInterval(0, modifiedDifference, this.get(\"groupCount\", Infinity), groupIntervals);\n              if ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n                groupInterval = __assign({}, baseInterval);\n              }\n            }\n          }\n          var current = this.getPrivate(\"groupInterval\");\n          if (groupInterval && (!current || current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count)) {\n            this.setPrivateRaw(\"groupInterval\", groupInterval);\n            this.setPrivateRaw(\"baseInterval\", groupInterval);\n            if (groupInterval) {\n              var newId_1 = groupInterval.timeUnit + groupInterval.count;\n              $array.each(this.series, function (series) {\n                if (series.get(\"baseAxis\") === _this) {\n                  series.setDataSet(newId_1);\n                }\n              });\n              this.markDirtyExtremes();\n            }\n          }\n        }\n        $array.each(this.series, function (series) {\n          if (series.get(\"baseAxis\") === _this) {\n            var fieldName_1 = _this.getPrivate(\"name\") + _this.get(\"renderer\").getPrivate(\"letter\");\n            var start = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMin);\n            });\n            if (start.index > 0) {\n              start.index -= 1;\n            }\n            var end = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMax);\n            });\n            series.setPrivate(\"startIndex\", start.index);\n            series.setPrivate(\"endIndex\", end.index);\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, _strictMode) {\n      return {\n        min: min,\n        max: max,\n        step: (max - min) / gridCount\n      };\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"intervalDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._intervalDuration;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var selectionMin = this.getPrivate(\"selectionMin\");\n        var selectionMax = this.getPrivate(\"selectionMax\");\n        var renderer = this.get(\"renderer\");\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var value = selectionMin;\n        var i = 0;\n        var intervals = this.get(\"gridIntervals\");\n        var gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n        if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n          gridInterval = __assign({}, baseInterval);\n        }\n        var intervalDuration = $time.getIntervalDuration(gridInterval);\n        this._intervalDuration = intervalDuration;\n        var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n        value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min)).getTime();\n        var previousValue = value - intervalDuration;\n        var format = void 0;\n        var formats = this.get(\"dateFormats\");\n        while (value < selectionMax + intervalDuration) {\n          var dataItem = void 0;\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n            this._dataItems.push(dataItem);\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n          this._createAssets(dataItem, []);\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n          dataItem.setRaw(\"value\", value);\n          dataItem.setRaw(\"endValue\", $time.round(new Date(value + intervalDuration * 1.1), gridInterval.timeUnit, gridInterval.count).getTime());\n          var date = new Date(value);\n          format = formats[gridInterval.timeUnit];\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if (gridInterval.timeUnit != \"year\") {\n              if ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n                format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n              }\n            }\n          }\n          var label = dataItem.get(\"label\");\n          if (label) {\n            label.set(\"text\", this._root.dateFormatter.format(date, format));\n          }\n          this._prepareDataItem(dataItem, gridInterval.count);\n          previousValue = value;\n          value = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\n          i++;\n        }\n        for (var j = i; j < this.dataItems.length; j++) {\n          this.dataItems[j].hide();\n        }\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n      }\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n      var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      return startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (max) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n      var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      return startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n    }\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns a duration of user-defined `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"baseMainDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.get(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"processSeriesDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, fields) {\n      var _this = this;\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      dataItem.open = {};\n      dataItem.close = {};\n      $array.each(fields, function (field) {\n        var value = dataItem.get(field);\n        if ($type.isNumber(value)) {\n          var startTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, _this._root.locale.firstDayOfWeek, _this._root.utc).getTime();\n          var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, _this._root.utc).getTime();\n          dataItem.open[field] = startTime;\n          dataItem.close[field] = endTime;\n        }\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"roundAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position, location) {\n      var value = this.positionToValue(position);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      value = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n      var endValue = value;\n      if (location > 0) {\n        endValue = $time.add(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      }\n      return this.valueToPosition(value + (endValue - value) * location);\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      var format = this.get(\"dateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n      return this._root.dateFormatter.format(new Date(this.positionToValue(position)), this.get(\"tooltipDateFormat\", format));\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series, position) {\n      var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      var value = this.positionToValue(position);\n      var result = $array.getSortedIndex(series.dataItems, function (dataItem) {\n        var diValue = 0;\n        if (dataItem.open) {\n          diValue = dataItem.open[fieldName];\n        }\n        return $order.compare(diValue, value);\n      });\n      if (series.get(\"snapTooltip\")) {\n        var first = series.dataItems[result.index - 1];\n        var second = series.dataItems[result.index];\n        if (first && second) {\n          if (first.open && second.close) {\n            var open_1 = first.open[fieldName];\n            var close_1 = second.close[fieldName];\n            if (Math.abs(value - open_1) > Math.abs(value - close_1)) {\n              return second;\n            }\n          }\n        }\n        return first;\n      } else {\n        // @todo check if is in range\n        var dataItem = series.dataItems[result.index - 1];\n        if (dataItem) {\n          if (dataItem.open && dataItem.close) {\n            var open_2 = dataItem.open[fieldName];\n            var close_2 = dataItem.close[fieldName];\n            if (value >= open_2 && value <= close_2) {\n              return dataItem;\n            }\n          }\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"shouldGap\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, nextItem, autoGapCount, fieldName) {\n      var value1 = dataItem.get(fieldName);\n      var value2 = nextItem.get(fieldName);\n      if (value2 - value1 > this.baseDuration() * autoGapCount) {\n        return true;\n      }\n      return false;\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"zoomToDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration) {\n      this.zoomToValues(start.getTime(), end.getTime(), duration);\n    }\n  });\n  /**\r\n   * Returns a `Date` object corresponding to specific position within plot\r\n   * area.\r\n   *\r\n   * @param   position  Pposition\r\n   * @return            Date\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"positionToDate\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      return new Date(this.positionToValue(position));\n    }\n  });\n  /**\r\n   * Returns a relative position within plot area that corresponds to specific\r\n   * date.\r\n   *\r\n   * @param   date  Date\r\n   * @return        Position\r\n   */\n  Object.defineProperty(DateAxis.prototype, \"dateToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date) {\n      return this.valueToPosition(date.getTime());\n    }\n  });\n  Object.defineProperty(DateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DateAxis\"\n  });\n  Object.defineProperty(DateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DateAxis.className])\n  });\n  return DateAxis;\n}(ValueAxis);\nexport { DateAxis };","map":{"version":3,"names":["DataItem","ValueAxis","$type","$order","$array","$object","$utils","$time","DateAxis","_super","__extends","_this","apply","arguments","Object","defineProperty","value","_settings","themeTags","mergeTags","prototype","_afterNew","call","setPrivateRaw","get","isDirty","min","getPrivate","max","isNumber","Math","round","baseMainDuration","groupInterval","groupInterval_1","setRaw","_dataGrouped","each","series","_groupSeriesData","baseInterval","mainDataSetId_1","timeUnit","count","setDataSet","undefined","markDirtyExtremes","intervals_1","baseDuration_1","groupIntervals","interval","intervalDuration","getIntervalDuration","push","_dataSets","key_1","fields_1","baseAxis","_valueYFields","_valueXFields","dataItems_1","_mainDataItems","mainDataSetId","eachContinue","previousTime","Infinity","dataSetId","newDataItem","sum","groupFieldValues","workingFields","field","dataItem","time","roundedTime","Date","_root","locale","firstDayOfWeek","utc","getTime","dataContext","copy","_makeDataItem","groupKey","currentValue","average","abs","dataContext_1","length","_dataSetId","markDirtySize","_clearDirty","_groupingCalculated","_handleRangeChange","selectionMin","selectionMax","modifiedDifference","baseDuration","chooseInterval","__assign","current","newId_1","fieldName_1","start","getSortedIndex","dataItems","compare","index","end","setPrivate","gridCount","_strictMode","step","_intervalDuration","renderer","i","intervals","gridInterval","nextGridUnit","getNextUnit","previousValue","format","formats","_dataItems","processDataItem","_createAssets","isHidden","show","date","checkChange","label","set","dateFormatter","_prepareDataItem","add","j","hide","inited","_markDirtyAxes","_updateGhost","startTime","endTime","fields","open","close","cellLocation","axisLocation","openValue","closeValue","_baseValue","valueToPosition","positionToCoordinate","getDataItemPositionX","getDataItemPositionY","position","location","positionToValue","endValue","fieldName","result","diValue","first","second","open_1","close_1","open_2","close_2","nextItem","autoGapCount","value1","value2","duration","zoomToValues","classNames","concat","className"],"sources":["../../../../../../src/.internal/charts/xy/axes/DateAxis.ts"],"sourcesContent":["import { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { XYSeries, IXYSeriesDataItem } from \"../series/XYSeries\";\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IMinMaxStep, IValueAxisEvents } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\n\nexport interface IDateAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * @default 1\n\t */\n\tendLocation?: number;\n\n\t/**\n\t * Should axis group data items togeter dynamically?\n\t *\n\t * @default false\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupData?: boolean;\n\n\t/**\n\t * Maximum number of data items in the view before data grouping kicks in.\n\t *\n\t * @default 500\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupCount?: number;\n\n\t/**\n\t * Force data item grouping to specific interval.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to group data items into.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\n\t */\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\n\n}\n\nexport interface IDateAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDateAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * Current group interval.\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n}\n\nexport interface IDateAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\n * @important\n */\nexport class DateAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DateAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DateAxis.className]);\n\n\tdeclare public _settings: IDateAxisSettings<R>;\n\tdeclare public _privateSettings: IDateAxisPrivate;\n\tdeclare public _dataItemSettings: IDateAxisDataItem;\n\tdeclare public _events: IDateAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\n\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\t}\n\n\tpublic _updateChildren(){\n\t\tif(this.isDirty(\"baseInterval\")){\n\t\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\t\t}\n\t}\n\n\n\tprotected _groupData() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif (($type.isNumber(min) && $type.isNumber(max))) {\n\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n\n\t\t\tconst groupInterval = this.getPrivate(\"groupInterval\")!;\n\t\t\tif (groupInterval) {\n\t\t\t\tthis.setPrivateRaw(\"baseInterval\", groupInterval);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\t\t\t}\n\n\n\t\t\tif (this.isDirty(\"groupInterval\")) {\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\")!;\n\t\t\t\tif (groupInterval) {\n\t\t\t\t\tthis.setRaw(\"groupIntervals\", [groupInterval]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isDirty(\"groupData\")) {\n\t\t\t\tif (!this._dataGrouped) {\n\t\t\t\t\tif (this.get(\"groupData\")) {\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tthis._groupSeriesData(series);\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\t\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tseries.setDataSet(mainDataSetId);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis.setPrivateRaw(\"baseInterval\", baseInterval);\n\t\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", undefined);\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t\tthis._dataGrouped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _groupSeriesData(series: XYSeries) {\n\t\tif (this.get(\"groupData\")) {\n\t\t\t// make array of intervals which will be used;\n\t\t\tlet intervals: ITimeInterval[] = [];\n\t\t\tlet baseDuration = this.baseMainDuration();\n\n\t\t\tlet groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\tif (groupIntervals) { }\n\t\t\t$array.each(groupIntervals, (interval) => {\n\t\t\t\tlet intervalDuration = $time.getIntervalDuration(interval);\n\t\t\t\tif (intervalDuration > baseDuration) {\n\t\t\t\t\tintervals.push(interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tseries._dataSets = {};\n\n\t\t\tconst key = this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!;\n\t\t\tlet fields: Array<string>;\n\n\t\t\tconst baseAxis = series.get(\"baseAxis\");\n\n\t\t\tif (series.get(\"xAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueYFields;\n\t\t\t}\n\t\t\telse if (series.get(\"yAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueXFields;\n\t\t\t}\n\n\t\t\tlet dataItems = series._mainDataItems;\n\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\tseries._dataSets[mainDataSetId] = dataItems;\n\n\t\t\t$array.eachContinue(intervals, (interval) => {\n\n\t\t\t\tlet previousTime = -Infinity;\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\n\t\t\t\tseries._dataSets[dataSetId] = [];\n\n\t\t\t\tlet newDataItem: DataItem<IXYSeriesDataItem>;\n\n\t\t\t\tlet sum: { [index: string]: number } = {};\n\t\t\t\tlet count: { [index: string]: number } = {};\n\n\t\t\t\tlet groupFieldValues: { [index: string]: string } = {};\n\t\t\t\tlet workingFields: { [index: string]: string } = {};\n\n\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\tgroupFieldValues[field] = series.get((field + \"Grouped\") as any);\n\t\t\t\t\tworkingFields[field] = field + \"Working\";\n\t\t\t\t})\n\n\n\t\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\t\tlet time = dataItem.get(key as any);\n\t\t\t\t\tlet roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\t\t\t\tlet dataContext: any;\n\n\t\t\t\t\tif (previousTime < roundedTime) {\n\t\t\t\t\t\tdataContext = $object.copy(dataItem.dataContext);\n\n\t\t\t\t\t\tnewDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n\t\t\t\t\t\tseries._dataSets[dataSetId].push(newDataItem);\n\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif ($type.isNumber(value)) {\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, value);\n\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet groupKey = groupFieldValues[field];\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif (value !== undefined) {\n\n\t\t\t\t\t\t\t\tlet currentValue = newDataItem.get(field as any);\n\n\t\t\t\t\t\t\t\tswitch (groupKey) {\n\t\t\t\t\t\t\t\t\tcase \"close\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, currentValue + value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"open\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"low\":\n\t\t\t\t\t\t\t\t\t\tif (value < currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"high\":\n\t\t\t\t\t\t\t\t\t\tif (value > currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"average\":\n\t\t\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t\t\t\tlet average = sum[field] / count[field];\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, average);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"extreme\":\n\t\t\t\t\t\t\t\t\t\tif (Math.abs(value) > Math.abs(currentValue)) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, newDataItem.get(field as any));\n\t\t\t\t\t\t\t\tlet dataContext: any = $object.copy(dataItem.dataContext);\n\t\t\t\t\t\t\t\tdataContext[key as any] = roundedTime\n\t\t\t\t\t\t\t\tnewDataItem.dataContext = dataContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tpreviousTime = roundedTime;\n\t\t\t\t})\n\n\t\t\t\tif (series._dataSets[dataSetId].length < this.get(\"groupCount\", Infinity)) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t})\n\t\t\tif(series._dataSetId){\n\t\t\t\tseries.setDataSet(series._dataSetId);\n\t\t\t}\n\t\t\tthis.markDirtySize();\n\t\t}\n\t}\n\n\tpublic _clearDirty() {\n\t\tsuper._clearDirty();\n\t\tthis._groupingCalculated = false;\n\t\tthis._dataGrouped = false;\n\t}\n\n\tprotected _handleRangeChange() {\n\t\tsuper._handleRangeChange();\n\n\t\tconst selectionMin = this.getPrivate(\"selectionMin\");\n\t\tconst selectionMax = this.getPrivate(\"selectionMax\");\n\n\t\tif ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n\n\t\t\tif (this.get(\"groupData\") && !this._groupingCalculated) {\n\t\t\t\tthis._groupingCalculated = true;\n\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\n\t\t\t\tlet modifiedDifference = (selectionMax - selectionMin) + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\");\n\n\t\t\t\tif (!groupInterval) {\n\t\t\t\t\tconst groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\t\t\tif (groupIntervals) {\n\t\t\t\t\t\tgroupInterval = $time.chooseInterval(0, modifiedDifference, this.get(\"groupCount\", Infinity), groupIntervals);\n\t\t\t\t\t\tif ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n\t\t\t\t\t\t\tgroupInterval = { ...baseInterval };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet current = this.getPrivate(\"groupInterval\");\n\n\t\t\t\tif (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count))) {\n\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", groupInterval);\n\t\t\t\t\tthis.setPrivateRaw(\"baseInterval\", groupInterval!);\n\n\t\t\t\t\tif (groupInterval) {\n\t\t\t\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\t\t\t\tseries.setDataSet(newId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\n\t\t\t\t\tconst start = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMin);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (start.index > 0) {\n\t\t\t\t\t\tstart.index -= 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst end = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMax);\n\t\t\t\t\t});\n\n\t\t\t\t\tseries.setPrivate(\"startIndex\", start.index);\n\t\t\t\t\tseries.setPrivate(\"endIndex\", end.index);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, _strictMode?: boolean): IMinMaxStep {\n\t\treturn { min: min, max: max, step: (max - min) / gridCount };\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic intervalDuration(): number {\n\t\treturn this._intervalDuration;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tconst selectionMin = this.getPrivate(\"selectionMin\")! as number;\n\t\t\tconst selectionMax = this.getPrivate(\"selectionMax\")! as number;\n\t\t\tconst renderer = this.get(\"renderer\");\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\t\tlet value = selectionMin;\n\t\t\tlet i = 0;\n\n\t\t\tconst intervals = this.get(\"gridIntervals\")!;\n\t\t\tlet gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n\t\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\t\tgridInterval = { ...baseInterval };\n\t\t\t}\n\n\t\t\tconst intervalDuration = $time.getIntervalDuration(gridInterval);\n\t\t\tthis._intervalDuration = intervalDuration;\n\n\t\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\t\tvalue = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min)).getTime();\n\t\t\tlet previousValue = value - intervalDuration;\n\t\t\tlet format: string | Intl.DateTimeFormatOptions;\n\t\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\t\twhile (value < selectionMax + intervalDuration) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\t\t\t\tdataItem.setRaw(\"endValue\", $time.round(new Date(value + intervalDuration * 1.1), gridInterval.timeUnit, gridInterval.count).getTime());\n\t\t\t\t\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tformat = formats[gridInterval.timeUnit];\n\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\t\t\t\t\tif (gridInterval.timeUnit != \"year\") {\n\t\t\t\t\t\tif ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem, gridInterval.count);\n\n\t\t\t\tpreviousValue = value;\n\n\t\t\t\tvalue = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis.dataItems[j].hide();\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n\t}\n\n\tprotected _fixMax(max: number) {\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\t/**\n\t * Returns a duration of user-defined `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseMainDuration(): number {\n\t\treturn $time.getIntervalDuration(this.get(\"baseInterval\"));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic processSeriesDataItem(dataItem: DataItem<IXYSeriesDataItem>, fields: Array<string>) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tdataItem.open = {};\n\t\tdataItem.close = {};\n\n\t\t$array.each(fields, (field) => {\n\t\t\tlet value = dataItem.get(field as any);\n\t\t\tif ($type.isNumber(value)) {\n\t\t\t\tlet startTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\t\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\t\t\t\tdataItem.open![field] = startTime;\n\t\t\t\tdataItem.close![field] = endTime;\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tlet value = this.positionToValue(position);\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tvalue = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\tlet endValue = value;\n\t\tif (location > 0) {\n\t\t\tendValue = $time.add(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\t\t}\n\t\treturn this.valueToPosition(value + (endValue - value) * location);\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\n\t\tlet format = this.get(\"dateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\treturn this._root.dateFormatter.format(new Date(this.positionToValue(position)), this.get(\"tooltipDateFormat\", format));\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\t\tconst result = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\tvar diValue = 0;\n\t\t\tif (dataItem.open) {\n\t\t\t\tdiValue = dataItem.open[fieldName];\n\t\t\t}\n\t\t\t\n\t\t\treturn $order.compare(diValue, value);\n\t\t});\n\n\t\tif (series.get(\"snapTooltip\")) {\n\t\t\tlet first = series.dataItems[result.index - 1];\n\t\t\tlet second = series.dataItems[result.index];\n\n\t\t\tif (first && second) {\n\t\t\t\tif (first.open && second.close) {\n\t\t\t\t\tlet open = first.open[fieldName];\n\t\t\t\t\tlet close = second.close[fieldName];\n\n\t\t\t\t\tif (Math.abs(value - open) > Math.abs(value - close)) {\n\t\t\t\t\t\treturn second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t}\n\t\telse {\n\t\t\t// @todo check if is in range\n\t\t\tconst dataItem = series.dataItems[result.index - 1];\n\n\t\t\tif (dataItem) {\n\t\t\t\tif (dataItem.open && dataItem.close) {\n\t\t\t\t\tlet open = dataItem.open[fieldName];\n\t\t\t\t\tlet close = dataItem.close[fieldName];\n\n\t\t\t\t\tif (value >= open && value <= close) {\n\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic shouldGap(dataItem: DataItem<IXYSeriesDataItem>, nextItem: DataItem<IXYSeriesDataItem>, autoGapCount: number, fieldName: string): boolean {\n\t\tconst value1 = dataItem.get(fieldName as any);\n\t\tconst value2 = nextItem.get(fieldName as any);\n\n\t\tif (value2 - value1 > this.baseDuration() * autoGapCount) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` dates.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start Date\n\t * @param  end       End Date\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToDates(start: Date, end: Date, duration?: number) {\n\t\tthis.zoomToValues(start.getTime(), end.getTime(), duration);\n\t}\n\n\t/**\n\t * Returns a `Date` object corresponding to specific position within plot\n\t * area.\n\t *\n\t * @param   position  Pposition\n\t * @return            Date\n\t */\n\tpublic positionToDate(position: number): Date {\n\t\treturn new Date(this.positionToValue(position));\n\t}\n\n\t/**\n\t * Returns a relative position within plot area that corresponds to specific\n\t * date.\n\t *\n\t * @param   date  Date\n\t * @return        Position\n\t */\n\tpublic dateToPosition(date: Date): number {\n\t\treturn this.valueToPosition(date.getTime());\n\t}\n}\n"],"mappings":";AAAA,SAASA,QAAQ,QAAQ,gCAAgC;AAGzD,SAASC,SAAS,QAAkG,aAAa;AACjI,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,OAAO,MAAM,2BAA2B;AACpD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAoHhD;;;;;;AAMA,IAAAC,QAAA,0BAAAC,MAAA;EAAsDC,SAAA,CAAAF,QAAA,EAAAC,MAAA;EAAtD,SAAAD,SAAA;IAAA,IAAAG,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IASCC,MAAA,CAAAC,cAAA,CAAAJ,KAAA;;;;aAAkC;;IAClCG,MAAA,CAAAC,cAAA,CAAAJ,KAAA;;;;aAAyC;;IACzCG,MAAA,CAAAC,cAAA,CAAAJ,KAAA;;;;aAAsC;;;EAgnBvC;;;;;WA9mBC,SAAAK,CAAA;MACC,IAAI,CAACC,SAAS,CAACC,SAAS,GAAGZ,MAAM,CAACa,SAAS,CAAC,IAAI,CAACF,SAAS,CAACC,SAAS,EAAE,CAAC,MAAM,CAAC,CAAC;MAC/ET,MAAA,CAAAW,SAAA,CAAMC,SAAS,CAAAC,IAAA,MAAE;MAEjB,IAAI,CAACC,aAAa,CAAC,cAAc,EAAE,IAAI,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;IAC7D;;;;;;WAEA,SAAAR,CAAA;MACC,IAAG,IAAI,CAACS,OAAO,CAAC,cAAc,CAAC,EAAC;QAC/B,IAAI,CAACF,aAAa,CAAC,cAAc,EAAE,IAAI,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;;IAE9D;;;;;;WAGA,SAAAR,CAAA;MAAA,IAAAL,KAAA;MACC,IAAMe,GAAG,GAAG,IAAI,CAACC,UAAU,CAAC,KAAK,CAAC;MAClC,IAAMC,GAAG,GAAG,IAAI,CAACD,UAAU,CAAC,KAAK,CAAC;MAElC,IAAKzB,KAAK,CAAC2B,QAAQ,CAACH,GAAG,CAAC,IAAIxB,KAAK,CAAC2B,QAAQ,CAACD,GAAG,CAAC,EAAG;QAEjD,IAAI,CAACL,aAAa,CAAC,eAAe,EAAEO,IAAI,CAACC,KAAK,CAAC,CAAC,IAAI,CAACJ,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,GAAG,IAAI,CAACA,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,IAAI,CAACK,gBAAgB,EAAE,CAAC,CAAC;QAElI,IAAMC,aAAa,GAAG,IAAI,CAACN,UAAU,CAAC,eAAe,CAAE;QACvD,IAAIM,aAAa,EAAE;UAClB,IAAI,CAACV,aAAa,CAAC,cAAc,EAAEU,aAAa,CAAC;SACjD,MACI;UACJ,IAAI,CAACV,aAAa,CAAC,cAAc,EAAE,IAAI,CAACC,GAAG,CAAC,cAAc,CAAC,CAAC;;QAI7D,IAAI,IAAI,CAACC,OAAO,CAAC,eAAe,CAAC,EAAE;UAClC,IAAIS,eAAa,GAAG,IAAI,CAACV,GAAG,CAAC,eAAe,CAAE;UAC9C,IAAIU,eAAa,EAAE;YAClB,IAAI,CAACC,MAAM,CAAC,gBAAgB,EAAE,CAACD,eAAa,CAAC,CAAC;;;QAIhD,IAAI,IAAI,CAACT,OAAO,CAAC,WAAW,CAAC,EAAE;UAC9B,IAAI,CAAC,IAAI,CAACW,YAAY,EAAE;YACvB,IAAI,IAAI,CAACZ,GAAG,CAAC,WAAW,CAAC,EAAE;cAC1BpB,MAAM,CAACiC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE,UAACA,MAAM;gBAC/B3B,KAAI,CAAC4B,gBAAgB,CAACD,MAAM,CAAC;cAC9B,CAAC,CAAC;aACF,MACI;cACJ,IAAIE,YAAY,GAAG,IAAI,CAAChB,GAAG,CAAC,cAAc,CAAC;cAC3C,IAAIiB,eAAa,GAAWD,YAAY,CAACE,QAAQ,GAAGF,YAAY,CAACG,KAAK;cAEtEvC,MAAM,CAACiC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE,UAACA,MAAM;gBAC/BA,MAAM,CAACM,UAAU,CAACH,eAAa,CAAC;cACjC,CAAC,CAAC;cAEF,IAAI,CAAClB,aAAa,CAAC,cAAc,EAAEiB,YAAY,CAAC;cAChD,IAAI,CAACjB,aAAa,CAAC,eAAe,EAAEsB,SAAS,CAAC;cAC9C,IAAI,CAACC,iBAAiB,EAAE;;YAEzB,IAAI,CAACV,YAAY,GAAG,IAAI;;;;IAI5B;;;;;;WAGA,SAAApB,CAAwBsB,MAAgB;MAAxC,IAAA3B,KAAA;MACC,IAAI,IAAI,CAACa,GAAG,CAAC,WAAW,CAAC,EAAE;QAC1B;QACA,IAAIuB,WAAS,GAAoB,EAAE;QACnC,IAAIC,cAAY,GAAG,IAAI,CAAChB,gBAAgB,EAAE;QAE1C,IAAIiB,cAAc,GAAG,IAAI,CAACzB,GAAG,CAAC,gBAAgB,CAAE;QAChD,IAAIyB,cAAc,EAAE;QACpB7C,MAAM,CAACiC,IAAI,CAACY,cAAc,EAAE,UAACC,QAAQ;UACpC,IAAIC,gBAAgB,GAAG5C,KAAK,CAAC6C,mBAAmB,CAACF,QAAQ,CAAC;UAC1D,IAAIC,gBAAgB,GAAGH,cAAY,EAAE;YACpCD,WAAS,CAACM,IAAI,CAACH,QAAQ,CAAC;;QAE1B,CAAC,CAAC;QAEFZ,MAAM,CAACgB,SAAS,GAAG,EAAE;QAErB,IAAMC,KAAG,GAAG,IAAI,CAAC5B,UAAU,CAAC,MAAM,CAAE,GAAG,IAAI,CAACH,GAAG,CAAC,UAAU,CAAC,CAACG,UAAU,CAAC,QAAQ,CAAE;QACjF,IAAI6B,QAAqB;QAEzB,IAAMC,QAAQ,GAAGnB,MAAM,CAACd,GAAG,CAAC,UAAU,CAAC;QAEvC,IAAIc,MAAM,CAACd,GAAG,CAAC,OAAO,CAAC,KAAKiC,QAAQ,EAAE;UACrCD,QAAM,GAAGlB,MAAM,CAACoB,aAAa;SAC7B,MACI,IAAIpB,MAAM,CAACd,GAAG,CAAC,OAAO,CAAC,KAAKiC,QAAQ,EAAE;UAC1CD,QAAM,GAAGlB,MAAM,CAACqB,aAAa;;QAG9B,IAAIC,WAAS,GAAGtB,MAAM,CAACuB,cAAc;QACrC,IAAIrB,YAAY,GAAG,IAAI,CAAChB,GAAG,CAAC,cAAc,CAAC;QAC3C,IAAIsC,aAAa,GAAWtB,YAAY,CAACE,QAAQ,GAAGF,YAAY,CAACG,KAAK;QAEtEL,MAAM,CAACgB,SAAS,CAACQ,aAAa,CAAC,GAAGF,WAAS;QAE3CxD,MAAM,CAAC2D,YAAY,CAAChB,WAAS,EAAE,UAACG,QAAQ;UAEvC,IAAIc,YAAY,GAAG,CAACC,QAAQ;UAC5B,IAAIC,SAAS,GAAGhB,QAAQ,CAACR,QAAQ,GAAGQ,QAAQ,CAACP,KAAK;UAClDL,MAAM,CAACgB,SAAS,CAACY,SAAS,CAAC,GAAG,EAAE;UAEhC,IAAIC,WAAwC;UAE5C,IAAIC,GAAG,GAAgC,EAAE;UACzC,IAAIzB,KAAK,GAAgC,EAAE;UAE3C,IAAI0B,gBAAgB,GAAgC,EAAE;UACtD,IAAIC,aAAa,GAAgC,EAAE;UAEnDlE,MAAM,CAACiC,IAAI,CAACmB,QAAM,EAAE,UAACe,KAAK;YACzBH,GAAG,CAACG,KAAK,CAAC,GAAG,CAAC;YACd5B,KAAK,CAAC4B,KAAK,CAAC,GAAG,CAAC;YAChBF,gBAAgB,CAACE,KAAK,CAAC,GAAGjC,MAAM,CAACd,GAAG,CAAE+C,KAAK,GAAG,SAAiB,CAAC;YAChED,aAAa,CAACC,KAAK,CAAC,GAAGA,KAAK,GAAG,SAAS;UACzC,CAAC,CAAC;UAGFnE,MAAM,CAACiC,IAAI,CAACuB,WAAS,EAAE,UAACY,QAAQ;YAC/B,IAAIC,IAAI,GAAGD,QAAQ,CAAChD,GAAG,CAAC+B,KAAU,CAAC;YACnC,IAAImB,WAAW,GAAGnE,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAACF,IAAI,CAAC,EAAEvB,QAAQ,CAACR,QAAQ,EAAEQ,QAAQ,CAACP,KAAK,EAAEhC,KAAI,CAACiE,KAAK,CAACC,MAAM,CAACC,cAAc,EAAEnE,KAAI,CAACiE,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;YAC5I,IAAIC,WAAgB;YAEpB,IAAIjB,YAAY,GAAGU,WAAW,EAAE;cAC/BO,WAAW,GAAG5E,OAAO,CAAC6E,IAAI,CAACV,QAAQ,CAACS,WAAW,CAAC;cAEhDd,WAAW,GAAG,IAAInE,QAAQ,CAACsC,MAAM,EAAE2C,WAAW,EAAE3C,MAAM,CAAC6C,aAAa,CAACF,WAAW,CAAC,CAAC;cAClF3C,MAAM,CAACgB,SAAS,CAACY,SAAS,CAAC,CAACb,IAAI,CAACc,WAAW,CAAC;cAE7C/D,MAAM,CAACiC,IAAI,CAACmB,QAAM,EAAE,UAACe,KAAK;gBACzB,IAAIvD,KAAK,GAAGwD,QAAQ,CAAChD,GAAG,CAAC+C,KAAY,CAAC;gBACtC,IAAIrE,KAAK,CAAC2B,QAAQ,CAACb,KAAK,CAAC,EAAE;kBAC1BmD,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEvD,KAAK,CAAC;kBACvCmD,WAAW,CAAChC,MAAM,CAACmC,aAAa,CAACC,KAAK,CAAQ,EAAEvD,KAAK,CAAC;kBACtD2B,KAAK,CAAC4B,KAAK,CAAC,EAAE;kBACdH,GAAG,CAACG,KAAK,CAAC,IAAIvD,KAAK;;cAErB,CAAC,CAAC;aACF,MACI;cACJZ,MAAM,CAACiC,IAAI,CAACmB,QAAM,EAAE,UAACe,KAAK;gBACzB,IAAIa,QAAQ,GAAGf,gBAAgB,CAACE,KAAK,CAAC;gBACtC,IAAIvD,KAAK,GAAGwD,QAAQ,CAAChD,GAAG,CAAC+C,KAAY,CAAC;gBACtC,IAAIvD,KAAK,KAAK6B,SAAS,EAAE;kBAExB,IAAIwC,YAAY,GAAGlB,WAAW,CAAC3C,GAAG,CAAC+C,KAAY,CAAC;kBAEhD,QAAQa,QAAQ;oBACf,KAAK,OAAO;sBACXjB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEvD,KAAK,CAAC;sBACvC;oBAED,KAAK,KAAK;sBACTmD,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEc,YAAY,GAAGrE,KAAK,CAAC;sBACtD;oBAED,KAAK,MAAM;sBACV;oBAED,KAAK,KAAK;sBACT,IAAIA,KAAK,GAAGqE,YAAY,EAAE;wBACzBlB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEvD,KAAK,CAAC;;sBAExC;oBAED,KAAK,MAAM;sBACV,IAAIA,KAAK,GAAGqE,YAAY,EAAE;wBACzBlB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEvD,KAAK,CAAC;;sBAExC;oBAED,KAAK,SAAS;sBACb2B,KAAK,CAAC4B,KAAK,CAAC,EAAE;sBACdH,GAAG,CAACG,KAAK,CAAC,IAAIvD,KAAK;sBACnB,IAAIsE,OAAO,GAAGlB,GAAG,CAACG,KAAK,CAAC,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;sBACvCJ,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEe,OAAO,CAAC;sBACzC;oBAED,KAAK,SAAS;sBACb,IAAIxD,IAAI,CAACyD,GAAG,CAACvE,KAAK,CAAC,GAAGc,IAAI,CAACyD,GAAG,CAACF,YAAY,CAAC,EAAE;wBAC7ClB,WAAW,CAAChC,MAAM,CAACoC,KAAY,EAAEvD,KAAK,CAAC;;sBAExC;;kBAGFmD,WAAW,CAAChC,MAAM,CAACmC,aAAa,CAACC,KAAK,CAAQ,EAAEJ,WAAW,CAAC3C,GAAG,CAAC+C,KAAY,CAAC,CAAC;kBAC9E,IAAIiB,aAAW,GAAQnF,OAAO,CAAC6E,IAAI,CAACV,QAAQ,CAACS,WAAW,CAAC;kBACzDO,aAAW,CAACjC,KAAU,CAAC,GAAGmB,WAAW;kBACrCP,WAAW,CAACc,WAAW,GAAGO,aAAW;;cAEvC,CAAC,CAAC;;YAEHxB,YAAY,GAAGU,WAAW;UAC3B,CAAC,CAAC;UAEF,IAAIpC,MAAM,CAACgB,SAAS,CAACY,SAAS,CAAC,CAACuB,MAAM,GAAG9E,KAAI,CAACa,GAAG,CAAC,YAAY,EAAEyC,QAAQ,CAAC,EAAE;YAC1E,OAAO,KAAK;;UAEb,OAAO,IAAI;QACZ,CAAC,CAAC;QACF,IAAG3B,MAAM,CAACoD,UAAU,EAAC;UACpBpD,MAAM,CAACM,UAAU,CAACN,MAAM,CAACoD,UAAU,CAAC;;QAErC,IAAI,CAACC,aAAa,EAAE;;IAEtB;;;;;;WAEA,SAAA3E,CAAA;MACCP,MAAA,CAAAW,SAAA,CAAMwE,WAAW,CAAAtE,IAAA,MAAE;MACnB,IAAI,CAACuE,mBAAmB,GAAG,KAAK;MAChC,IAAI,CAACzD,YAAY,GAAG,KAAK;IAC1B;;;;;;WAEA,SAAApB,CAAA;MAAA,IAAAL,KAAA;MACCF,MAAA,CAAAW,SAAA,CAAM0E,kBAAkB,CAAAxE,IAAA,MAAE;MAE1B,IAAMyE,YAAY,GAAG,IAAI,CAACpE,UAAU,CAAC,cAAc,CAAC;MACpD,IAAMqE,YAAY,GAAG,IAAI,CAACrE,UAAU,CAAC,cAAc,CAAC;MAEpD,IAAIzB,KAAK,CAAC2B,QAAQ,CAACkE,YAAY,CAAC,IAAI7F,KAAK,CAAC2B,QAAQ,CAACmE,YAAY,CAAC,EAAE;QAEjE,IAAI,IAAI,CAACxE,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAACqE,mBAAmB,EAAE;UACvD,IAAI,CAACA,mBAAmB,GAAG,IAAI;UAC/B,IAAIrD,YAAY,GAAG,IAAI,CAAChB,GAAG,CAAC,cAAc,CAAC;UAE3C,IAAIyE,kBAAkB,GAAID,YAAY,GAAGD,YAAY,IAAK,IAAI,CAACvE,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACA,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC0E,YAAY,EAAE,CAAC;UAChJ,IAAIjE,aAAa,GAAG,IAAI,CAACT,GAAG,CAAC,eAAe,CAAC;UAE7C,IAAI,CAACS,aAAa,EAAE;YACnB,IAAMgB,cAAc,GAAG,IAAI,CAACzB,GAAG,CAAC,gBAAgB,CAAE;YAClD,IAAIyB,cAAc,EAAE;cACnBhB,aAAa,GAAG1B,KAAK,CAAC4F,cAAc,CAAC,CAAC,EAAEF,kBAAkB,EAAE,IAAI,CAACzE,GAAG,CAAC,YAAY,EAAEyC,QAAQ,CAAC,EAAEhB,cAAc,CAAC;cAC7G,IAAI1C,KAAK,CAAC6C,mBAAmB,CAACnB,aAAa,CAAC,GAAG1B,KAAK,CAAC6C,mBAAmB,CAACZ,YAAY,CAAC,EAAE;gBACvFP,aAAa,GAAAmE,QAAA,KAAQ5D,YAAY,CAAE;;;;UAKtC,IAAI6D,OAAO,GAAG,IAAI,CAAC1E,UAAU,CAAC,eAAe,CAAC;UAE9C,IAAIM,aAAa,KAAK,CAACoE,OAAO,IAAKA,OAAO,CAAC3D,QAAQ,KAAKT,aAAa,CAACS,QAAQ,IAAI2D,OAAO,CAAC1D,KAAK,KAAKV,aAAa,CAACU,KAAM,CAAC,EAAE;YAC1H,IAAI,CAACpB,aAAa,CAAC,eAAe,EAAEU,aAAa,CAAC;YAClD,IAAI,CAACV,aAAa,CAAC,cAAc,EAAEU,aAAc,CAAC;YAElD,IAAIA,aAAa,EAAE;cAClB,IAAIqE,OAAK,GAAGrE,aAAa,CAACS,QAAQ,GAAGT,aAAa,CAACU,KAAK;cACxDvC,MAAM,CAACiC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE,UAACA,MAAM;gBAC/B,IAAIA,MAAM,CAACd,GAAG,CAAC,UAAU,CAAC,KAAKb,KAAI,EAAE;kBACpC2B,MAAM,CAACM,UAAU,CAAC0D,OAAK,CAAC;;cAE1B,CAAC,CAAC;cACF,IAAI,CAACxD,iBAAiB,EAAE;;;;QAK3B1C,MAAM,CAACiC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE,UAACA,MAAM;UAC/B,IAAIA,MAAM,CAACd,GAAG,CAAC,UAAU,CAAC,KAAKb,KAAI,EAAE;YACpC,IAAI4F,WAAS,GAAS5F,KAAI,CAACgB,UAAU,CAAC,MAAM,CAAE,GAAGhB,KAAI,CAACa,GAAG,CAAC,UAAU,CAAC,CAACG,UAAU,CAAC,QAAQ,CAAG;YAE5F,IAAM6E,KAAK,GAAGpG,MAAM,CAACqG,cAAc,CAACnE,MAAM,CAACoE,SAAS,EAAE,UAAClC,QAAQ;cAC9D,OAAOrE,MAAM,CAACwG,OAAO,CAACnC,QAAQ,CAAChD,GAAG,CAAC+E,WAAS,CAAC,EAAER,YAAY,CAAC;YAC7D,CAAC,CAAC;YAEF,IAAIS,KAAK,CAACI,KAAK,GAAG,CAAC,EAAE;cACpBJ,KAAK,CAACI,KAAK,IAAI,CAAC;;YAGjB,IAAMC,GAAG,GAAGzG,MAAM,CAACqG,cAAc,CAACnE,MAAM,CAACoE,SAAS,EAAE,UAAClC,QAAQ;cAC5D,OAAOrE,MAAM,CAACwG,OAAO,CAACnC,QAAQ,CAAChD,GAAG,CAAC+E,WAAS,CAAC,EAAEP,YAAY,CAAC;YAC7D,CAAC,CAAC;YAEF1D,MAAM,CAACwE,UAAU,CAAC,YAAY,EAAEN,KAAK,CAACI,KAAK,CAAC;YAC5CtE,MAAM,CAACwE,UAAU,CAAC,UAAU,EAAED,GAAG,CAACD,KAAK,CAAC;;QAE1C,CAAC,CAAC;;IAEJ;;;;;;WAEA,SAAA5F,CAAwBU,GAAW,EAAEE,GAAW,EAAEmF,SAAiB,EAAEC,WAAqB;MACzF,OAAO;QAAEtF,GAAG,EAAEA,GAAG;QAAEE,GAAG,EAAEA,GAAG;QAAEqF,IAAI,EAAE,CAACrF,GAAG,GAAGF,GAAG,IAAIqF;MAAS,CAAE;IAC7D;;EAEA;;;;;;;WAGA,SAAA/F,CAAA;MACC,OAAO,IAAI,CAACkG,iBAAiB;IAC9B;;;;;;WAEA,SAAAlG,CAAA;MACC,IAAMU,GAAG,GAAG,IAAI,CAACC,UAAU,CAAC,KAAK,CAAC;MAClC,IAAMC,GAAG,GAAG,IAAI,CAACD,UAAU,CAAC,KAAK,CAAC;MAElC,IAAIzB,KAAK,CAAC2B,QAAQ,CAACH,GAAG,CAAC,IAAIxB,KAAK,CAAC2B,QAAQ,CAACD,GAAG,CAAC,EAAE;QAC/C,IAAMmE,YAAY,GAAG,IAAI,CAACpE,UAAU,CAAC,cAAc,CAAY;QAC/D,IAAMqE,YAAY,GAAG,IAAI,CAACrE,UAAU,CAAC,cAAc,CAAY;QAC/D,IAAMwF,QAAQ,GAAG,IAAI,CAAC3F,GAAG,CAAC,UAAU,CAAC;QACrC,IAAMgB,YAAY,GAAG,IAAI,CAACb,UAAU,CAAC,cAAc,CAAC;QAEpD,IAAIX,KAAK,GAAG+E,YAAY;QACxB,IAAIqB,CAAC,GAAG,CAAC;QAET,IAAMC,SAAS,GAAG,IAAI,CAAC7F,GAAG,CAAC,eAAe,CAAE;QAC5C,IAAI8F,YAAY,GAAG/G,KAAK,CAAC4F,cAAc,CAAC,CAAC,EAAEH,YAAY,GAAGD,YAAY,EAAEoB,QAAQ,CAACJ,SAAS,EAAE,EAAEM,SAAS,CAAC;QAExG,IAAI9G,KAAK,CAAC6C,mBAAmB,CAACkE,YAAY,CAAC,GAAG,IAAI,CAACpB,YAAY,EAAE,EAAE;UAClEoB,YAAY,GAAAlB,QAAA,KAAQ5D,YAAY,CAAE;;QAGnC,IAAMW,gBAAgB,GAAG5C,KAAK,CAAC6C,mBAAmB,CAACkE,YAAY,CAAC;QAChE,IAAI,CAACJ,iBAAiB,GAAG/D,gBAAgB;QAEzC,IAAMoE,YAAY,GAAGhH,KAAK,CAACiH,WAAW,CAACF,YAAY,CAAC5E,QAAQ,CAAC;QAC7D1B,KAAK,GAAGT,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAACoB,YAAY,GAAG5C,gBAAgB,CAAC,EAAEmE,YAAY,CAAC5E,QAAQ,EAAE4E,YAAY,CAAC3E,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACC,MAAM,CAACC,cAAc,EAAE,IAAI,CAACF,KAAK,CAACG,GAAG,EAAE,IAAIJ,IAAI,CAACjD,GAAG,CAAC,CAAC,CAACsD,OAAO,EAAE;QACpL,IAAIyC,aAAa,GAAGzG,KAAK,GAAGmC,gBAAgB;QAC5C,IAAIuE,MAAM,SAAqC;QAC/C,IAAMC,OAAO,GAAG,IAAI,CAACnG,GAAG,CAAC,aAAa,CAAE;QAExC,OAAOR,KAAK,GAAGgF,YAAY,GAAG7C,gBAAgB,EAAE;UAC/C,IAAIqB,QAAQ,SAAqC;UACjD,IAAI,IAAI,CAACkC,SAAS,CAACjB,MAAM,GAAG2B,CAAC,GAAG,CAAC,EAAE;YAClC5C,QAAQ,GAAG,IAAIxE,QAAQ,CAAC,IAAI,EAAE6C,SAAS,EAAE,EAAE,CAAC;YAC5C,IAAI,CAAC+E,UAAU,CAACvE,IAAI,CAACmB,QAAQ,CAAC;YAC9B,IAAI,CAACqD,eAAe,CAACrD,QAAQ,CAAC;WAC9B,MACI;YACJA,QAAQ,GAAG,IAAI,CAACkC,SAAS,CAACU,CAAC,CAAC;;UAG7B,IAAI,CAACU,aAAa,CAACtD,QAAQ,EAAE,EAAE,CAAC;UAEhC,IAAIA,QAAQ,CAACuD,QAAQ,EAAE,EAAE;YACxBvD,QAAQ,CAACwD,IAAI,EAAE;;UAGhBxD,QAAQ,CAACrC,MAAM,CAAC,OAAO,EAAEnB,KAAK,CAAC;UAC/BwD,QAAQ,CAACrC,MAAM,CAAC,UAAU,EAAE5B,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAAC3D,KAAK,GAAGmC,gBAAgB,GAAG,GAAG,CAAC,EAAEmE,YAAY,CAAC5E,QAAQ,EAAE4E,YAAY,CAAC3E,KAAK,CAAC,CAACqC,OAAO,EAAE,CAAC;UAEvI,IAAIiD,IAAI,GAAG,IAAItD,IAAI,CAAC3D,KAAK,CAAC;UAE1B0G,MAAM,GAAGC,OAAO,CAACL,YAAY,CAAC5E,QAAQ,CAAC;UAEvC,IAAI6E,YAAY,IAAI,IAAI,CAAC/F,GAAG,CAAC,gBAAgB,CAAC,IAAItB,KAAK,CAAC2B,QAAQ,CAAC4F,aAAa,CAAC,EAAE;YAChF,IAAIH,YAAY,CAAC5E,QAAQ,IAAI,MAAM,EAAE;cACpC,IAAInC,KAAK,CAAC2H,WAAW,CAACD,IAAI,EAAE,IAAItD,IAAI,CAAC8C,aAAa,CAAC,EAAEF,YAAY,EAAE,IAAI,CAAC3C,KAAK,CAACG,GAAG,CAAC,EAAE;gBACnF2C,MAAM,GAAG,IAAI,CAAClG,GAAG,CAAC,yBAAyB,CAAE,CAAC8F,YAAY,CAAC5E,QAAQ,CAAC;;;;UAKvE,IAAMyF,KAAK,GAAG3D,QAAQ,CAAChD,GAAG,CAAC,OAAO,CAAC;UACnC,IAAI2G,KAAK,EAAE;YACVA,KAAK,CAACC,GAAG,CAAC,MAAM,EAAE,IAAI,CAACxD,KAAK,CAACyD,aAAa,CAACX,MAAM,CAACO,IAAI,EAAEP,MAAO,CAAC,CAAC;;UAGlE,IAAI,CAACY,gBAAgB,CAAC9D,QAAQ,EAAE8C,YAAY,CAAC3E,KAAK,CAAC;UAEnD8E,aAAa,GAAGzG,KAAK;UAErBA,KAAK,GAAGT,KAAK,CAACgI,GAAG,CAAC,IAAI5D,IAAI,CAAC3D,KAAK,CAAC,EAAEsG,YAAY,CAAC5E,QAAQ,EAAE4E,YAAY,CAAC3E,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;UAEvGoC,CAAC,EAAE;;QAGJ,KAAK,IAAIoB,CAAC,GAAGpB,CAAC,EAAEoB,CAAC,GAAG,IAAI,CAAC9B,SAAS,CAACjB,MAAM,EAAE+C,CAAC,EAAE,EAAE;UAC/C,IAAI,CAAC9B,SAAS,CAAC8B,CAAC,CAAC,CAACC,IAAI,EAAE;;QAGzBrI,MAAM,CAACiC,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE,UAACA,MAAM;UAC/B,IAAIA,MAAM,CAACoG,MAAM,EAAE;YAClBpG,MAAM,CAACqG,cAAc,EAAE;;QAEzB,CAAC,CAAC;;MAGH,IAAI,CAACC,YAAY,EAAE;IACpB;;;;;;WAEA,SAAA5H,CAAkBU,GAAW;MAC5B,IAAIc,YAAY,GAAG,IAAI,CAACb,UAAU,CAAC,cAAc,CAAC;MAClD,IAAIkH,SAAS,GAAGtI,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAACjD,GAAG,CAAC,EAAEc,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACC,MAAM,CAACC,cAAc,EAAE,IAAI,CAACF,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;MACjJ,IAAI8D,OAAO,GAAGvI,KAAK,CAACgI,GAAG,CAAC,IAAI5D,IAAI,CAACkE,SAAS,CAAC,EAAErG,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;MAEjH,OAAO6D,SAAS,GAAG,CAACC,OAAO,GAAGD,SAAS,IAAI,IAAI,CAACrH,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;IACxE;;;;;;WAEA,SAAAR,CAAkBY,GAAW;MAC5B,IAAIY,YAAY,GAAG,IAAI,CAACb,UAAU,CAAC,cAAc,CAAC;MAClD,IAAIkH,SAAS,GAAGtI,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAAC/C,GAAG,CAAC,EAAEY,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACC,MAAM,CAACC,cAAc,EAAE,IAAI,CAACF,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;MACjJ,IAAI8D,OAAO,GAAGvI,KAAK,CAACgI,GAAG,CAAC,IAAI5D,IAAI,CAACkE,SAAS,CAAC,EAAErG,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;MAEjH,OAAO6D,SAAS,GAAG,CAACC,OAAO,GAAGD,SAAS,IAAI,IAAI,CAACrH,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC;IACtE;;EAEA;;;;;;;;;WAKA,SAAAR,CAAA;MACC,OAAOT,KAAK,CAAC6C,mBAAmB,CAAC,IAAI,CAACzB,UAAU,CAAC,cAAc,CAAC,CAAC;IAClE;;EAEA;;;;;;;;;WAKA,SAAAX,CAAA;MACC,OAAOT,KAAK,CAAC6C,mBAAmB,CAAC,IAAI,CAAC5B,GAAG,CAAC,cAAc,CAAC,CAAC;IAC3D;;EAEA;;;;;;;WAGA,SAAAR,CAA6BwD,QAAqC,EAAEuE,MAAqB;MAAzF,IAAApI,KAAA;MACC,IAAM6B,YAAY,GAAG,IAAI,CAACb,UAAU,CAAC,cAAc,CAAC;MAEpD6C,QAAQ,CAACwE,IAAI,GAAG,EAAE;MAClBxE,QAAQ,CAACyE,KAAK,GAAG,EAAE;MAEnB7I,MAAM,CAACiC,IAAI,CAAC0G,MAAM,EAAE,UAACxE,KAAK;QACzB,IAAIvD,KAAK,GAAGwD,QAAQ,CAAChD,GAAG,CAAC+C,KAAY,CAAC;QACtC,IAAIrE,KAAK,CAAC2B,QAAQ,CAACb,KAAK,CAAC,EAAE;UAC1B,IAAI6H,SAAS,GAAGtI,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAAC3D,KAAK,CAAC,EAAEwB,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAEhC,KAAI,CAACiE,KAAK,CAACC,MAAM,CAACC,cAAc,EAAEnE,KAAI,CAACiE,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;UACnJ,IAAI8D,OAAO,GAAGvI,KAAK,CAACgI,GAAG,CAAC,IAAI5D,IAAI,CAACkE,SAAS,CAAC,EAAErG,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAEhC,KAAI,CAACiE,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;UACjHR,QAAQ,CAACwE,IAAK,CAACzE,KAAK,CAAC,GAAGsE,SAAS;UACjCrE,QAAQ,CAACyE,KAAM,CAAC1E,KAAK,CAAC,GAAGuE,OAAO;;MAElC,CAAC,CAAC;IACH;;EAEA;;;;;;;WAGA,SAAA9H,CAA4BwD,QAAqC,EAAED,KAAa,EAAE2E,YAAoB,EAAEC,YAAoB;MAE3H,IAAIC,SAAS;MACb,IAAIC,UAAU;MAEd,IAAI7E,QAAQ,CAACwE,IAAI,IAAIxE,QAAQ,CAACyE,KAAK,EAAE;QACpCG,SAAS,GAAG5E,QAAQ,CAACwE,IAAI,CAACzE,KAAK,CAAC;QAChC8E,UAAU,GAAG7E,QAAQ,CAACyE,KAAK,CAAC1E,KAAK,CAAC;OAClC,MACI;QACJ6E,SAAS,GAAG5E,QAAQ,CAAChD,GAAG,CAAC+C,KAAY,CAAC;QACtC8E,UAAU,GAAGD,SAAS;;MAGvB,IAAIpI,KAAK,GAAGoI,SAAS,GAAG,CAACC,UAAU,GAAGD,SAAS,IAAIF,YAAY;MAE/DlI,KAAK,GAAG,IAAI,CAACsI,UAAU,GAAG,CAACtI,KAAK,GAAG,IAAI,CAACsI,UAAU,IAAIH,YAAY;MAElE,OAAO,IAAI,CAACI,eAAe,CAACvI,KAAK,CAAC;IACnC;;EAEA;;;;;;;WAGA,SAAAA,CAA8BwD,QAAqC,EAAED,KAAa,EAAE2E,YAAoB,EAAEC,YAAoB;MAC7H,OAAO,IAAI,CAAClI,SAAS,CAACkG,QAAQ,CAACqC,oBAAoB,CAAC,IAAI,CAACC,oBAAoB,CAACjF,QAAQ,EAAED,KAAK,EAAE2E,YAAY,EAAEC,YAAY,CAAC,CAAC;IAC5H;;EAEA;;;;;;;WAGA,SAAAnI,CAA4BwD,QAAqC,EAAED,KAAa,EAAE2E,YAAoB,EAAEC,YAAoB;MAC3H,IAAIC,SAAS;MACb,IAAIC,UAAU;MAEd,IAAI7E,QAAQ,CAACwE,IAAI,IAAIxE,QAAQ,CAACyE,KAAK,EAAE;QACpCG,SAAS,GAAG5E,QAAQ,CAACwE,IAAI,CAACzE,KAAK,CAAC;QAChC8E,UAAU,GAAG7E,QAAQ,CAACyE,KAAK,CAAC1E,KAAK,CAAC;OAClC,MACI;QACJ6E,SAAS,GAAG5E,QAAQ,CAAChD,GAAG,CAAC+C,KAAY,CAAC;QACtC8E,UAAU,GAAGD,SAAS;;MAGvB,IAAIpI,KAAK,GAAGoI,SAAS,GAAG,CAACC,UAAU,GAAGD,SAAS,IAAIF,YAAY;MAE/DlI,KAAK,GAAG,IAAI,CAACsI,UAAU,GAAG,CAACtI,KAAK,GAAG,IAAI,CAACsI,UAAU,IAAIH,YAAY;MAClE,OAAO,IAAI,CAACI,eAAe,CAACvI,KAAK,CAAC;IACnC;;EAEA;;;;;;;WAGA,SAAAA,CAA8BwD,QAAqC,EAAED,KAAa,EAAE2E,YAAoB,EAAEC,YAAoB;MAC7H,OAAO,IAAI,CAAClI,SAAS,CAACkG,QAAQ,CAACqC,oBAAoB,CAAC,IAAI,CAACE,oBAAoB,CAAClF,QAAQ,EAAED,KAAK,EAAE2E,YAAY,EAAEC,YAAY,CAAC,CAAC;IAC5H;;EAEA;;;;;;;WAGA,SAAAnI,CAAyB2I,QAAgB,EAAEC,QAAgB;MAC1D,IAAI5I,KAAK,GAAG,IAAI,CAAC6I,eAAe,CAACF,QAAQ,CAAC;MAC1C,IAAInH,YAAY,GAAG,IAAI,CAACb,UAAU,CAAC,cAAc,CAAC;MAClDX,KAAK,GAAGT,KAAK,CAACwB,KAAK,CAAC,IAAI4C,IAAI,CAAC3D,KAAK,CAAC,EAAEwB,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACC,MAAM,CAACC,cAAc,EAAE,IAAI,CAACF,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;MAC3I,IAAI8E,QAAQ,GAAG9I,KAAK;MACpB,IAAI4I,QAAQ,GAAG,CAAC,EAAE;QACjBE,QAAQ,GAAGvJ,KAAK,CAACgI,GAAG,CAAC,IAAI5D,IAAI,CAAC3D,KAAK,CAAC,EAAEwB,YAAY,CAACE,QAAQ,EAAEF,YAAY,CAACG,KAAK,EAAE,IAAI,CAACiC,KAAK,CAACG,GAAG,CAAC,CAACC,OAAO,EAAE;;MAE3G,OAAO,IAAI,CAACuE,eAAe,CAACvI,KAAK,GAAG,CAAC8I,QAAQ,GAAG9I,KAAK,IAAI4I,QAAQ,CAAC;IACnE;;EAEA;;;;;;;;;;WAMA,SAAA5I,CAAsB2I,QAAgB;MACrC;MAEA,IAAIjC,MAAM,GAAG,IAAI,CAAClG,GAAG,CAAC,aAAa,CAAE,CAAC,IAAI,CAACG,UAAU,CAAC,cAAc,CAAC,CAACe,QAAQ,CAAC;MAC/E,OAAO,IAAI,CAACkC,KAAK,CAACyD,aAAa,CAACX,MAAM,CAAC,IAAI/C,IAAI,CAAC,IAAI,CAACkF,eAAe,CAACF,QAAQ,CAAC,CAAC,EAAE,IAAI,CAACnI,GAAG,CAAC,mBAAmB,EAAEkG,MAAM,CAAC,CAAC;IACxH;;EAEA;;;;;;;;;;;WAOA,SAAA1G,CAAqBsB,MAAgB,EAAEqH,QAAgB;MACtD,IAAII,SAAS,GAAS,IAAI,CAACpI,UAAU,CAAC,MAAM,CAAE,GAAG,IAAI,CAACH,GAAG,CAAC,UAAU,CAAC,CAACG,UAAU,CAAC,QAAQ,CAAG;MAC5F,IAAIX,KAAK,GAAG,IAAI,CAAC6I,eAAe,CAACF,QAAQ,CAAC;MAC1C,IAAMK,MAAM,GAAG5J,MAAM,CAACqG,cAAc,CAACnE,MAAM,CAACoE,SAAS,EAAE,UAAClC,QAAQ;QAC/D,IAAIyF,OAAO,GAAG,CAAC;QACf,IAAIzF,QAAQ,CAACwE,IAAI,EAAE;UAClBiB,OAAO,GAAGzF,QAAQ,CAACwE,IAAI,CAACe,SAAS,CAAC;;QAGnC,OAAO5J,MAAM,CAACwG,OAAO,CAACsD,OAAO,EAAEjJ,KAAK,CAAC;MACtC,CAAC,CAAC;MAEF,IAAIsB,MAAM,CAACd,GAAG,CAAC,aAAa,CAAC,EAAE;QAC9B,IAAI0I,KAAK,GAAG5H,MAAM,CAACoE,SAAS,CAACsD,MAAM,CAACpD,KAAK,GAAG,CAAC,CAAC;QAC9C,IAAIuD,MAAM,GAAG7H,MAAM,CAACoE,SAAS,CAACsD,MAAM,CAACpD,KAAK,CAAC;QAE3C,IAAIsD,KAAK,IAAIC,MAAM,EAAE;UACpB,IAAID,KAAK,CAAClB,IAAI,IAAImB,MAAM,CAAClB,KAAK,EAAE;YAC/B,IAAImB,MAAI,GAAGF,KAAK,CAAClB,IAAI,CAACe,SAAS,CAAC;YAChC,IAAIM,OAAK,GAAGF,MAAM,CAAClB,KAAK,CAACc,SAAS,CAAC;YAEnC,IAAIjI,IAAI,CAACyD,GAAG,CAACvE,KAAK,GAAGoJ,MAAI,CAAC,GAAGtI,IAAI,CAACyD,GAAG,CAACvE,KAAK,GAAGqJ,OAAK,CAAC,EAAE;cACrD,OAAOF,MAAM;;;;QAIhB,OAAOD,KAAK;OACZ,MACI;QACJ;QACA,IAAM1F,QAAQ,GAAGlC,MAAM,CAACoE,SAAS,CAACsD,MAAM,CAACpD,KAAK,GAAG,CAAC,CAAC;QAEnD,IAAIpC,QAAQ,EAAE;UACb,IAAIA,QAAQ,CAACwE,IAAI,IAAIxE,QAAQ,CAACyE,KAAK,EAAE;YACpC,IAAIqB,MAAI,GAAG9F,QAAQ,CAACwE,IAAI,CAACe,SAAS,CAAC;YACnC,IAAIQ,OAAK,GAAG/F,QAAQ,CAACyE,KAAK,CAACc,SAAS,CAAC;YAErC,IAAI/I,KAAK,IAAIsJ,MAAI,IAAItJ,KAAK,IAAIuJ,OAAK,EAAE;cACpC,OAAO/F,QAAQ;;;;;IAKpB;;EAEA;;;;;;;WAGA,SAAAxD,CAAiBwD,QAAqC,EAAEgG,QAAqC,EAAEC,YAAoB,EAAEV,SAAiB;MACrI,IAAMW,MAAM,GAAGlG,QAAQ,CAAChD,GAAG,CAACuI,SAAgB,CAAC;MAC7C,IAAMY,MAAM,GAAGH,QAAQ,CAAChJ,GAAG,CAACuI,SAAgB,CAAC;MAE7C,IAAIY,MAAM,GAAGD,MAAM,GAAG,IAAI,CAACxE,YAAY,EAAE,GAAGuE,YAAY,EAAE;QACzD,OAAO,IAAI;;MAEZ,OAAO,KAAK;IACb;;EAEA;;;;;;;;;;;;;WASA,SAAAzJ,CAAmBwF,KAAW,EAAEK,GAAS,EAAE+D,QAAiB;MAC3D,IAAI,CAACC,YAAY,CAACrE,KAAK,CAACxB,OAAO,EAAE,EAAE6B,GAAG,CAAC7B,OAAO,EAAE,EAAE4F,QAAQ,CAAC;IAC5D;;EAEA;;;;;;;;;;;WAOA,SAAA5J,CAAsB2I,QAAgB;MACrC,OAAO,IAAIhF,IAAI,CAAC,IAAI,CAACkF,eAAe,CAACF,QAAQ,CAAC,CAAC;IAChD;;EAEA;;;;;;;;;;;WAOA,SAAA3I,CAAsBiH,IAAU;MAC/B,OAAO,IAAI,CAACsB,eAAe,CAACtB,IAAI,CAACjD,OAAO,EAAE,CAAC;IAC5C;;EAznBAlE,MAAA,CAAAC,cAAA,CAAAP,QAAA;;;;WAAkC;;EAClCM,MAAA,CAAAC,cAAA,CAAAP,QAAA;;;;WAA0CP,SAAS,CAAC6K,UAAU,CAACC,MAAM,CAAC,CAACvK,QAAQ,CAACwK,SAAS,CAAC;;EAynB3F,OAAAxK,QAAC;CAAA,CA3nBqDP,SAAS;SAAlDO,QAAQ"},"metadata":{},"sourceType":"module"}