{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Text } from \"../render/Text\";\nimport { p50, p100 } from \"../util/Percent\";\nimport { Container } from \"./Container\";\nimport * as $array from \"../../core/util/Array\";\nimport * as $type from \"../../core/util/Type\";\n/**\r\n * Creates a label with support for in-line styling and data bindings.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info\r\n */\n\nvar Label =\n/** @class */\nfunction (_super) {\n  __extends(Label, _super);\n\n  function Label() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_text\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_textKeys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"text\", \"fill\", \"textAlign\", \"fontFamily\", \"fontSize\", \"fontStyle\", \"fontWeight\", \"fontStyle\", \"fontVariant\", \"shadowColor\", \"shadowBlur\", \"shadowOffsetX\", \"shadowOffsetY\", \"shadowOpacity\", // \"leading\",\n      // \"letterSpacing\",\n      \"lineHeight\", \"baselineRatio\", //\"padding\",\n      // \"stroke\",\n      // \"strokeThickness\",\n      // \"trim\",\n      // \"wordWrap\",\n      \"direction\", \"textBaseline\", \"oversizedBehavior\", \"breakWords\", \"ellipsis\", \"minScale\", \"populateText\", \"role\", \"ignoreFormatting\"]\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @ignore Text is not to be used directly\r\n     */\n    get: function get() {\n      return this._text;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var _this = this;\n\n      _super.prototype._afterNew.call(this);\n\n      this._makeText();\n\n      $array.each(this._textKeys, function (property) {\n        var propValue = _this.get(property);\n\n        if (propValue != undefined) {\n          _this._text.set(property, propValue);\n        }\n      });\n    }\n  });\n  Object.defineProperty(Label.prototype, \"_makeText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      this._text = this.children.push(Text.new(this._root, {}));\n    }\n  });\n  Object.defineProperty(Label.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var _this = this;\n\n      _super.prototype._updateChildren.call(this);\n\n      $array.each(this._textKeys, function (property) {\n        _this._text.set(property, _this.get(property));\n      });\n\n      if (this.isDirty(\"maxWidth\")) {\n        this._setMaxDimentions();\n      }\n\n      if (this.isDirty(\"maxHeight\")) {\n        this._setMaxDimentions();\n      }\n\n      if (this.isDirty(\"rotation\")) {\n        this._setMaxDimentions();\n      }\n\n      if (this.isDirty(\"textAlign\") || this.isDirty(\"width\")) {\n        var textAlign = this.get(\"textAlign\");\n        var x = void 0;\n\n        if (this.get(\"width\") != null) {\n          if (textAlign == \"right\") {\n            x = p100;\n          } else if (textAlign == \"center\") {\n            x = p50;\n          } else {\n            x = 0;\n          }\n        } else {\n          if (textAlign == \"left\" || textAlign == \"start\") {\n            x = this.get(\"paddingLeft\");\n          } else if (textAlign == \"right\" || textAlign == \"end\") {\n            x = -this.get(\"paddingRight\");\n          }\n        }\n\n        this.text.set(\"x\", x);\n      }\n    }\n  });\n  Object.defineProperty(Label.prototype, \"_setMaxDimentions\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var rotation = this.get(\"rotation\");\n      var vertical = rotation == 90 || rotation == 270;\n      var maxWidth = this.get(\"maxWidth\", Infinity);\n\n      if ($type.isNumber(maxWidth)) {\n        this.text.set(vertical ? \"maxHeight\" : \"maxWidth\", maxWidth - this.get(\"paddingLeft\", 0) - this.get(\"paddingRight\", 0));\n      } else {\n        this.text.set(vertical ? \"maxHeight\" : \"maxWidth\", undefined);\n      }\n\n      var maxHeight = this.get(\"maxHeight\", Infinity);\n\n      if ($type.isNumber(maxHeight)) {\n        this.text.set(vertical ? \"maxWidth\" : \"maxHeight\", maxHeight - this.get(\"paddingTop\", 0) - this.get(\"paddingBottom\", 0));\n      } else {\n        this.text.set(vertical ? \"maxWidth\" : \"maxHeight\", undefined);\n      }\n    }\n  });\n  Object.defineProperty(Label.prototype, \"_setDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem) {\n      _super.prototype._setDataItem.call(this, dataItem);\n\n      this._markDirtyKey(\"text\");\n\n      if (this.text.get(\"populateText\")) {\n        this.text.markDirtyText();\n      }\n    }\n  });\n  /**\r\n   * Returns text with populated placeholders and formatting if `populateText` is\r\n   * set to `true`.\r\n   *\r\n   * @return Populated text\r\n   */\n\n  Object.defineProperty(Label.prototype, \"getText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      return this._text._getText();\n    }\n  });\n  Object.defineProperty(Label, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Label\"\n  });\n  Object.defineProperty(Label, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Container.classNames.concat([Label.className])\n  });\n  return Label;\n}(Container);\n\nexport { Label };","map":{"version":3,"sources":["../../../../../src/.internal/core/render/Label.ts"],"names":[],"mappings":";AAIA,SAAS,IAAT,QAAqB,gBAArB;AACA,SAAS,GAAT,EAAc,IAAd,QAA0B,iBAA1B;AACA,SAAS,SAAT,QAAiE,aAAjE;AAEA,OAAO,KAAM,MAAb,MAAyB,uBAAzB;AACA,OAAO,KAAM,KAAb,MAAwB,sBAAxB;AAgMA;;;;AAIG;;AACH,IAAA,KAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA2B,EAAA,SAAA,CAAA,KAAA,EAAA,MAAA,CAAA;;AAA3B,WAAA,KAAA,GAAA;AAAA,QAAA,KAAA,GAAA,MAAA,KAAA,IAAA,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,IAAA;;AAKC,IAAA,MAAA,CAAA,cAAA,CAAA,KAAA,EAAA,OAAA,EAAA;sBAAA;wBAAA;oBAAA;;AAAA,KAAA;AAEA,IAAA,MAAA,CAAA,cAAA,CAAA,KAAA,EAAA,WAAA,EAAA;sBAAA;wBAAA;oBAAA;aAAqC,CACpC,MADoC,EAEpC,MAFoC,EAGpC,WAHoC,EAIpC,YAJoC,EAKpC,UALoC,EAMpC,WANoC,EAOpC,YAPoC,EAQpC,WARoC,EASpC,aAToC,EAUpC,aAVoC,EAWpC,YAXoC,EAYpC,eAZoC,EAapC,eAboC,EAcpC,eAdoC,EAepC;AACA;AACA,kBAjBoC,EAkBpC,eAlBoC,EAmBpC;AACA;AACA;AACA;AACA;AACA,iBAxBoC,EAyBpC,cAzBoC,EA0BpC,mBA1BoC,EA2BpC,YA3BoC,EA4BpC,UA5BoC,EA6BpC,UA7BoC,EA8BpC,cA9BoC,EA+BpC,MA/BoC,EAgCpC,kBAhCoC;AAArC,KAAA;;AAkJA;;AAzGA,EAAA,MAAA,CAAA,cAAA,CAAW,KAAA,CAAA,SAAX,EAAW,MAAX,EAAe;AAHf;;AAEG;SACH,eAAA;AACC,aAAO,KAAK,KAAZ;AACA,KAFc;qBAAA;;AAAA,GAAf;;;;;WAIA,iBAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACC,MAAA,MAAA,CAAA,SAAA,CAAM,SAAN,CAAe,IAAf,CAAe,IAAf;;AAEA,WAAK,SAAL;;AAEA,MAAA,MAAM,CAAC,IAAP,CAAY,KAAK,SAAjB,EAA4B,UAAC,QAAD,EAAS;AACpC,YAAM,SAAS,GAAG,KAAI,CAAC,GAAL,CAAS,QAAT,CAAlB;;AACA,YAAI,SAAS,IAAI,SAAjB,EAA4B;AAC3B,UAAA,KAAI,CAAC,KAAL,CAAW,GAAX,CAAe,QAAf,EAAgC,SAAhC;AACA;AACD,OALD;AAMA;;;;;;WAED,iBAAA;AACC,WAAK,KAAL,GAAa,KAAK,QAAL,CAAc,IAAd,CAAmB,IAAI,CAAC,GAAL,CAAS,KAAK,KAAd,EAAqB,EAArB,CAAnB,CAAb;AACA;;;;;;WAED,iBAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACC,MAAA,MAAA,CAAA,SAAA,CAAM,eAAN,CAAqB,IAArB,CAAqB,IAArB;;AAEA,MAAA,MAAM,CAAC,IAAP,CAAY,KAAK,SAAjB,EAA4B,UAAC,QAAD,EAAS;AACpC,QAAA,KAAI,CAAC,KAAL,CAAW,GAAX,CAAe,QAAf,EAAgC,KAAI,CAAC,GAAL,CAAS,QAAT,CAAhC;AACA,OAFD;;AAIA,UAAI,KAAK,OAAL,CAAa,UAAb,CAAJ,EAA8B;AAC7B,aAAK,iBAAL;AACA;;AAED,UAAI,KAAK,OAAL,CAAa,WAAb,CAAJ,EAA+B;AAC9B,aAAK,iBAAL;AACA;;AAED,UAAI,KAAK,OAAL,CAAa,UAAb,CAAJ,EAA8B;AAC7B,aAAK,iBAAL;AACA;;AAED,UAAI,KAAK,OAAL,CAAa,WAAb,KAA6B,KAAK,OAAL,CAAa,OAAb,CAAjC,EAAwD;AACvD,YAAM,SAAS,GAAG,KAAK,GAAL,CAAS,WAAT,CAAlB;AACA,YAAI,CAAC,GAAA,KAAA,CAAL;;AACA,YAAI,KAAK,GAAL,CAAS,OAAT,KAAqB,IAAzB,EAA+B;AAC9B,cAAI,SAAS,IAAI,OAAjB,EAA0B;AACzB,YAAA,CAAC,GAAG,IAAJ;AACA,WAFD,MAGK,IAAI,SAAS,IAAI,QAAjB,EAA2B;AAC/B,YAAA,CAAC,GAAG,GAAJ;AACA,WAFI,MAGA;AACJ,YAAA,CAAC,GAAG,CAAJ;AACA;AACD,SAVD,MAWK;AACJ,cAAI,SAAS,IAAI,MAAb,IAAuB,SAAS,IAAI,OAAxC,EAAiD;AAChD,YAAA,CAAC,GAAG,KAAK,GAAL,CAAS,aAAT,CAAJ;AACA,WAFD,MAGK,IAAI,SAAS,IAAI,OAAb,IAAwB,SAAS,IAAI,KAAzC,EAAgD;AACpD,YAAA,CAAC,GAAG,CAAC,KAAK,GAAL,CAAS,cAAT,CAAL;AACA;AACD;;AAED,aAAK,IAAL,CAAU,GAAV,CAAc,GAAd,EAAmB,CAAnB;AACA;AACD;;;;;;WAED,iBAAA;AACC,UAAM,QAAQ,GAAG,KAAK,GAAL,CAAS,UAAT,CAAjB;AACA,UAAM,QAAQ,GAAG,QAAQ,IAAI,EAAZ,IAAkB,QAAQ,IAAI,GAA/C;AAEA,UAAM,QAAQ,GAAG,KAAK,GAAL,CAAS,UAAT,EAAqB,QAArB,CAAjB;;AACA,UAAI,KAAK,CAAC,QAAN,CAAe,QAAf,CAAJ,EAA8B;AAC7B,aAAK,IAAL,CAAU,GAAV,CAAc,QAAQ,GAAG,WAAH,GAAiB,UAAvC,EAAmD,QAAQ,GAAG,KAAK,GAAL,CAAS,aAAT,EAAwB,CAAxB,CAAX,GAAwC,KAAK,GAAL,CAAS,cAAT,EAAyB,CAAzB,CAA3F;AACA,OAFD,MAGK;AACJ,aAAK,IAAL,CAAU,GAAV,CAAc,QAAQ,GAAG,WAAH,GAAiB,UAAvC,EAAmD,SAAnD;AACA;;AAED,UAAM,SAAS,GAAG,KAAK,GAAL,CAAS,WAAT,EAAsB,QAAtB,CAAlB;;AACA,UAAI,KAAK,CAAC,QAAN,CAAe,SAAf,CAAJ,EAA+B;AAC9B,aAAK,IAAL,CAAU,GAAV,CAAc,QAAQ,GAAG,UAAH,GAAgB,WAAtC,EAAmD,SAAS,GAAG,KAAK,GAAL,CAAS,YAAT,EAAuB,CAAvB,CAAZ,GAAwC,KAAK,GAAL,CAAS,eAAT,EAA0B,CAA1B,CAA3F;AACA,OAFD,MAGK;AACJ,aAAK,IAAL,CAAU,GAAV,CAAc,QAAQ,GAAG,UAAH,GAAgB,WAAtC,EAAmD,SAAnD;AACA;AACD;;;;;;WAED,eAAoB,QAApB,EAA2D;AAC1D,MAAA,MAAA,CAAA,SAAA,CAAM,YAAN,CAAkB,IAAlB,CAAkB,IAAlB,EAAmB,QAAnB;;AACA,WAAK,aAAL,CAAmB,MAAnB;;AACA,UAAI,KAAK,IAAL,CAAU,GAAV,CAAc,cAAd,CAAJ,EAAmC;AAClC,aAAK,IAAL,CAAU,aAAV;AACA;AACD;;AAED;;;;;AAKG;;;;;;WACH,iBAAA;AACC,aAAO,KAAK,KAAL,CAAW,QAAX,EAAP;AACA;;AA9GD,EAAA,MAAA,CAAA,cAAA,CAAA,KAAA,EAAA,WAAA,EAAA;oBAAA;sBAAA;kBAAA;WAAkC;AAAlC,GAAA;AACA,EAAA,MAAA,CAAA,cAAA,CAAA,KAAA,EAAA,YAAA,EAAA;oBAAA;sBAAA;kBAAA;WAA0C,SAAS,CAAC,UAAV,CAAqB,MAArB,CAA4B,CAAC,KAAK,CAAC,SAAP,CAA5B;AAA1C,GAAA;AA8GD,SAAA,KAAA;AAAC,CAzJD,CAA2B,SAA3B,CAAA;;SAAa,K","sourcesContent":["import type { Color } from \"../util/Color\";\nimport type { Percent } from \"../util/Percent\";\nimport type { DataItem, IComponentDataItem } from \"./Component\";\n\nimport { Text } from \"../render/Text\";\nimport { p50, p100 } from \"../util/Percent\";\nimport { Container, IContainerPrivate, IContainerSettings } from \"./Container\";\n\nimport * as  $array from \"../../core/util/Array\";\nimport * as  $type from \"../../core/util/Type\";\n\n\nexport interface ILabelSettings extends IContainerSettings {\n\n\t/**\n\t * Labels' text.\n\t */\n\ttext?: string;\n\n\t/**\n\t * Text color.\n\t */\n\tfill?: Color;\n\n\t/**\n\t * Alignment.\n\t */\n\ttextAlign?: \"start\" | \"end\" | \"left\" | \"right\" | \"center\";\n\n\t/**\n\t * Font family to use for the label.\n\t *\n\t * Multiple fonts can be separated by commas.\n\t */\n\tfontFamily?: string;\n\n\t/**\n\t * Font size in misc any supported CSS format (pixel, point, em, etc.).\n\t */\n\tfontSize?: string | number;\n\n\t/**\n\t * Font weight.\n\t */\n\tfontWeight?: \"normal\" | \"bold\" | \"bolder\" | \"lighter\" | \"100\" | \"200\" | \"300\" | \"400\" | \"500\" | \"600\" | \"700\" | \"800\" | \"900\";\n\n\t/**\n\t * Font style.\n\t */\n\tfontStyle?: \"normal\" | \"italic\" | \"oblique\";\n\n\n\t/**\n\t * Font variant.\n\t */\n\tfontVariant?: \"normal\" | \"small-caps\";\n\n\t/**\n\t * Line height in percent or absolute pixels.\n\t */\n\tlineHeight?: Percent | number;\n\n\t/**\n\t * How mouch of the height should be considered to go below baseline.\n\t *\n\t * @default 0.19\n\t */\n\tbaselineRatio?: number;\n\n\t/**\n\t * Opacity of the label.\n\t *\n\t * 0 - fully transparent; 1 - fully opaque.\n\t */\n\topacity?: number;\n\n\t/**\n\t * Text direction.\n\t *\n\t * @default \"ltr\"\n\t */\n\tdirection?: \"ltr\" | \"rtl\";\n\n\t/**\n\t * A base line to use when aligning text chunks vertically.\n\t */\n\ttextBaseline?: \"top\" | \"hanging\" | \"middle\" | \"alphabetic\" | \"ideographic\" | \"bottom\";\n\n\t/**\n\t * How to handle labels that do not fit into its designated space.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/#Oversized_text} for more info\n\t */\n\toversizedBehavior?: \"none\" | \"hide\" | \"fit\" | \"wrap\" | \"truncate\";\n\n\t/**\n\t * Whether words can be broken when truncating or wrapping text.\n\t *\n\t * @default false\n\t */\n\tbreakWords?: boolean;\n\n\t/**\n\t * Ellipsis characters to use when truncating text.\n\t *\n\t * Will use Unicode ellipsis symbol (`\"…\"`) by default, which might not be\n\t * available in all fonts. If ellipsis looks broken, use different\n\t * characters. E.g.:\n\t *\n\t * ```TypeScript\n\t * label.set(\"ellipsis\", \"...\");\n\t * ```\n\t * ```JavaScript\n\t * label.set(\"ellipsis\", \"...\");\n\t * ```\n\t *\n\t *\n\t * @default \"…\"\n\t */\n\tellipsis?: string;\n\n\t/**\n\t * Minimum relative scale allowed for label when scaling down\n\t * when `oversizedBehavior` is set to `\"fit\"`.\n\t *\n\t * If fitting the label would require it to scale beyond `minScale` it would\n\t * be hidden instead.\n\t */\n\tminScale?: number;\n\n\t/**\n\t * If set to `true` the label will parse `text` for data placeholders and\n\t * will try to populate them with actual data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/#Data_placeholders} for more info\n\t */\n\tpopulateText?: boolean;\n\n\t/**\n\t * If set to `true`, will ignore in-line formatting blocks and will display\n\t * text exactly as it is.\n\t *\n\t * @default false\n\t */\n\tignoreFormatting?: boolean;\n\n\t/**\n\t * Color of the element's shadow.\n\t *\n\t * For this to work at least one of the following needs to be set as well:\n\t * `shadowBlur`, `shadowOffsetX`, `shadowOffsetY`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowColor?: Color | null;\n\n\t/**\n\t * Blurriness of the the shadow.\n\t *\n\t * The bigger the number, the more blurry shadow will be.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowBlur?: number;\n\n\t/**\n\t * Horizontal shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetX?: number;\n\n\t/**\n\t * Vertical shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetY?: number;\n\n\t/**\n\t * Opacity of the shadow (0-1).\n\t *\n\t * If not set, will use the same as `fillOpacity` of the element.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOpacity?: number;\n\n\t// The following migh be supported some day:\n\t// padding?: number;\n\t// stroke?: number;\n\t// strokeThickness?: number;\n\t// trim?: number;\n\t// wordWrap?: boolean;\n\t// leading?: number;\n\t// letterSpacing?: number;\n}\n\nexport interface ILabelPrivate extends IContainerPrivate {\n}\n\n/**\n * Creates a label with support for in-line styling and data bindings.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info\n */\nexport class Label extends Container {\n\n\tdeclare public _settings: ILabelSettings;\n\tdeclare public _privateSettings: ILabelPrivate;\n\n\tprotected _text!: Text;\n\n\tprotected _textKeys: Array<string> = [\n\t\t\"text\",\n\t\t\"fill\",\n\t\t\"textAlign\",\n\t\t\"fontFamily\",\n\t\t\"fontSize\",\n\t\t\"fontStyle\",\n\t\t\"fontWeight\",\n\t\t\"fontStyle\",\n\t\t\"fontVariant\",\n\t\t\"shadowColor\",\n\t\t\"shadowBlur\",\n\t\t\"shadowOffsetX\",\n\t\t\"shadowOffsetY\",\n\t\t\"shadowOpacity\",\n\t\t// \"leading\",\n\t\t// \"letterSpacing\",\n\t\t\"lineHeight\",\n\t\t\"baselineRatio\",\n\t\t//\"padding\",\n\t\t// \"stroke\",\n\t\t// \"strokeThickness\",\n\t\t// \"trim\",\n\t\t// \"wordWrap\",\n\t\t\"direction\",\n\t\t\"textBaseline\",\n\t\t\"oversizedBehavior\",\n\t\t\"breakWords\",\n\t\t\"ellipsis\",\n\t\t\"minScale\",\n\t\t\"populateText\",\n\t\t\"role\",\n\t\t\"ignoreFormatting\"\n\t];\n\n\tpublic static className: string = \"Label\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([Label.className]);\n\n\t/**\n\t * @ignore Text is not to be used directly\n\t */\n\tpublic get text(): Text {\n\t\treturn this._text;\n\t}\n\n\tprotected _afterNew() {\n\t\tsuper._afterNew();\n\n\t\tthis._makeText();\n\n\t\t$array.each(this._textKeys, (property) => {\n\t\t\tconst propValue = this.get(property as any);\n\t\t\tif (propValue != undefined) {\n\t\t\t\tthis._text.set(property as any, propValue);\n\t\t\t}\n\t\t})\n\t}\n\n\tpublic _makeText() {\n\t\tthis._text = this.children.push(Text.new(this._root, {}));\n\t}\n\n\tpublic _updateChildren() {\n\t\tsuper._updateChildren();\n\n\t\t$array.each(this._textKeys, (property) => {\n\t\t\tthis._text.set(property as any, this.get(property as any));\n\t\t})\n\n\t\tif (this.isDirty(\"maxWidth\")) {\n\t\t\tthis._setMaxDimentions();\n\t\t}\n\n\t\tif (this.isDirty(\"maxHeight\")) {\n\t\t\tthis._setMaxDimentions();\n\t\t}\n\n\t\tif (this.isDirty(\"rotation\")) {\n\t\t\tthis._setMaxDimentions();\n\t\t}\n\n\t\tif (this.isDirty(\"textAlign\") || this.isDirty(\"width\")) {\n\t\t\tconst textAlign = this.get(\"textAlign\");\n\t\t\tlet x: number | Percent | undefined;\n\t\t\tif (this.get(\"width\") != null) {\n\t\t\t\tif (textAlign == \"right\") {\n\t\t\t\t\tx = p100;\n\t\t\t\t}\n\t\t\t\telse if (textAlign == \"center\") {\n\t\t\t\t\tx = p50;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (textAlign == \"left\" || textAlign == \"start\") {\n\t\t\t\t\tx = this.get(\"paddingLeft\");\n\t\t\t\t}\n\t\t\t\telse if (textAlign == \"right\" || textAlign == \"end\") {\n\t\t\t\t\tx = -this.get(\"paddingRight\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.text.set(\"x\", x);\n\t\t}\n\t}\n\n\tprotected _setMaxDimentions() {\n\t\tconst rotation = this.get(\"rotation\");\n\t\tconst vertical = rotation == 90 || rotation == 270;\n\n\t\tconst maxWidth = this.get(\"maxWidth\", Infinity);\n\t\tif ($type.isNumber(maxWidth)) {\n\t\t\tthis.text.set(vertical ? \"maxHeight\" : \"maxWidth\", maxWidth - this.get(\"paddingLeft\", 0) - this.get(\"paddingRight\", 0));\n\t\t}\n\t\telse {\n\t\t\tthis.text.set(vertical ? \"maxHeight\" : \"maxWidth\", undefined);\n\t\t}\n\n\t\tconst maxHeight = this.get(\"maxHeight\", Infinity);\n\t\tif ($type.isNumber(maxHeight)) {\n\t\t\tthis.text.set(vertical ? \"maxWidth\" : \"maxHeight\", maxHeight - this.get(\"paddingTop\", 0) - this.get(\"paddingBottom\", 0));\n\t\t}\n\t\telse {\n\t\t\tthis.text.set(vertical ? \"maxWidth\" : \"maxHeight\", undefined);\n\t\t}\n\t}\n\n\tpublic _setDataItem(dataItem?: DataItem<IComponentDataItem>): void {\n\t\tsuper._setDataItem(dataItem);\n\t\tthis._markDirtyKey(\"text\")\n\t\tif (this.text.get(\"populateText\")) {\n\t\t\tthis.text.markDirtyText();\n\t\t}\n\t}\n\n\t/**\n\t * Returns text with populated placeholders and formatting if `populateText` is\n\t * set to `true`.\n\t *\n\t * @return Populated text\n\t */\n\tpublic getText(): string {\n\t\treturn this._text._getText();\n\t}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}