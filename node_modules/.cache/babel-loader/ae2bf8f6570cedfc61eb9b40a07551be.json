{"ast":null,"code":"import { Color } from \"./Color\";\nimport * as $type from \"./Type\";\nvar TextFormatter = /** @class */function () {\n  function TextFormatter() {}\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  Object.defineProperty(TextFormatter, \"escape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(/\\[\\[/g, this.prefix + \"1\").replace(/([^\\/]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").replace(/\\]\\]/g, this.prefix + \"2\").replace(/\\{\\{/g, this.prefix + \"3\").replace(/\\}\\}/g, this.prefix + \"4\").replace(/\\'\\'/g, this.prefix + \"5\");\n    }\n  });\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  Object.defineProperty(TextFormatter, \"unescape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").replace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").replace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").replace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").replace(new RegExp(this.prefix + \"5\", \"g\"), \"'\");\n    }\n  });\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n  Object.defineProperty(TextFormatter, \"cleanUp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n    }\n  });\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n  Object.defineProperty(TextFormatter, \"chunk\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text, quotedBlocks, noFormatting) {\n      if (quotedBlocks === void 0) {\n        quotedBlocks = false;\n      }\n      if (noFormatting === void 0) {\n        noFormatting = false;\n      }\n      // Init result\n      var res = [];\n      // Replace double (escaped) square spaces and quotes with temporary codes\n      text = this.escape(text);\n      // Deal with style blocks\n      var chunks = quotedBlocks ? text.split(\"'\") : [text];\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i];\n        // Empty?\n        if (chunk === \"\") {\n          continue;\n        }\n        if (i % 2 === 0) {\n          // Text outside quotes\n          // Parse for style blocks which are \"text\" chunks, the rest chunks are\n          // \"value\"\n          chunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n          chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n            // Placeholder?\n            if (chunk2 === $type.PLACEHOLDER) {\n              continue;\n            }\n            // Empty?\n            if (chunk2 === \"\") {\n              continue;\n            }\n            // Block or value\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"value\",\n                \"text\": chunk2\n              });\n            } else {\n              res.push({\n                \"type\": noFormatting ? \"value\" : \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        } else {\n          // A text within doublequotes\n          // All chunks are \"text\"\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n            // Empty?\n            if (chunk2 === \"\") {\n              continue;\n            }\n            // Block or text\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"text\",\n                \"text\": chunk2\n              });\n            } else if (this.isImage(chunk2)) {\n              res.push({\n                \"type\": \"image\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            } else {\n              res.push({\n                \"type\": \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        }\n      }\n      return res;\n    }\n  });\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore\r\n   * @param  text  Format\r\n   * @return true if it is an image\r\n   */\n  Object.defineProperty(TextFormatter, \"isImage\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.match(/img[ ]?:/) ? true : false;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"getTextStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (style) {\n      // let textStyle: string[] = [];\n      // let textFill: string | undefined;\n      var format = {};\n      if (style == \"\" || style == \"[ ]\") {\n        return {};\n      }\n      // TODO: cache\n      // let cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n      // if (cached) {\n      // \treturn cached;\n      // }\n      // Pre-process quoted text\n      var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n      if (q) {\n        for (var i = 0; i < q.length; i++) {\n          style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n        }\n      }\n      // Get style parts\n      var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n      // Empty?\n      if (!b) {\n        return {};\n      }\n      //console.log(b)\n      // Check each part\n      for (var i = 0; i < b.length; i++) {\n        if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n          format.fontWeight = b[i];\n        } else if (b[i] == \"/\") {\n          // Just closing tag\n          // Do nothing\n        } else if (!b[i].match(/:/)) {\n          // Color\n          format.fill = Color.fromString(b[i]);\n        } else {\n          var p = b[i].split(/:[ ]*/);\n          format[p[0]] = p[1];\n          //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n          //b[i] = b[i].replace(/\\+/g, \" \");\n        }\n      }\n      // TODO: cache\n      // registry.setCache(\"translateStyleShortcuts_\" + style, res);\n      return format;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"prefix\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"__amcharts__\"\n  });\n  return TextFormatter;\n}();\nexport { TextFormatter };","map":{"version":3,"names":["Color","$type","TextFormatter","value","text","replace","prefix","RegExp","quotedBlocks","noFormatting","res","escape","chunks","split","i","length","chunk","PLACEHOLDER","chunks2","i2","chunk2","cleanUp","unescape","push","isImage","match","style","format","q","b","fontWeight","fill","fromString","p","Object","defineProperty"],"sources":["../../../../../src/.internal/core/util/TextFormatter.ts"],"sourcesContent":["import { Color } from \"./Color\"\nimport type { ITextStyle } from \"../render/backend/Renderer\"\nimport * as $type from \"./Type\";\n\n/**\n * Defines an interface for an object that holds a chunk of text.\n */\nexport interface ITextChunk {\n\n\t/**\n\t * Type of the chunk.\n\t */\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\n\n\t/**\n\t * Text.\n\t */\n\t\"text\": string\n\n}\n\nexport class TextFormatter {\n\n\tpublic static prefix = \"__amcharts__\";\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic static escape(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, this.prefix + \"1\").\n\t\t\treplace(/([^\\/]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").\n\t\t\treplace(/\\]\\]/g, this.prefix + \"2\").\n\t\t\treplace(/\\{\\{/g, this.prefix + \"3\").\n\t\t\treplace(/\\}\\}/g, this.prefix + \"4\").\n\t\t\treplace(/\\'\\'/g, this.prefix + \"5\");\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic static unescape(text: string): string {\n\t\treturn text.\n\t\t\treplace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").\n\t\t\treplace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").\n\t\t\treplace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").\n\t\t\treplace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").\n\t\t\treplace(new RegExp(this.prefix + \"5\", \"g\"), \"'\");\n\t}\n\n\t/**\n\t * Cleans up the text text for leftover double square brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Cleaned up text\n\t */\n\tpublic static cleanUp(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, \"[\").\n\t\t\treplace(/\\]\\]/g, \"]\").\n\t\t\treplace(/\\{\\{/g, \"{\").\n\t\t\treplace(/\\}\\}/g, \"}\").\n\t\t\treplace(/\\'\\'/g, \"'\");\n\t}\n\n\t/**\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\n\t *\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\n\t * also single out text blocks enclosed within single quotes that no\n\t * formatting should be applied to, and they should be displayed as is.\n\t *\n\t * Default for the above is `false`, so that you can use single quote in text\n\t * without escaping it.\n\t *\n\t * If enabled, single quotes can be escaped by doubling it - adding two\n\t * single quotes, which will be replaced by a one single quote in the final\n\t * output.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text          Text to chunk\n\t * @param quotedBlocks  Use quoted blocks\n\t * @param noFormatting  Formatting blocks will be treated as regular text\n\t * @return Array of string chunks\n\t */\n\tpublic static chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\n\n\t\t// Init result\n\t\tlet res: ITextChunk[] = [];\n\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\n\t\ttext = this.escape(text);\n\n\t\t// Deal with style blocks\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\tlet chunk = chunks[i];\n\n\t\t\t// Empty?\n\t\t\tif (chunk === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((i % 2) === 0) {\n\n\t\t\t\t// Text outside quotes\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\n\t\t\t\t// \"value\"\n\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Placeholder?\n\t\t\t\t\tif (chunk2 === $type.PLACEHOLDER) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or value\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"value\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// A text within doublequotes\n\t\t\t\t// All chunks are \"text\"\n\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or text\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isImage(chunk2)) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Checks if supplied format contains image information and should be\n\t * formatted as such.\n\t * I.e.: `[img: myImage.png]`\n\t *\n\t * @ignore\n\t * @param  text  Format\n\t * @return true if it is an image\n\t */\n\tpublic static isImage(text: string): boolean {\n\t\treturn text.match(/img[ ]?:/) ? true : false;\n\t}\n\n\tpublic static getTextStyle(style: string): ITextStyle {\n\n\t\t// let textStyle: string[] = [];\n\t\t// let textFill: string | undefined;\n\t\tlet format: ITextStyle = {};\n\n\t\tif (style == \"\" || style == \"[ ]\") {\n\t\t\treturn {};\n\t\t}\n\n\t\t// TODO: cache\n\t\t// let cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n\t\t// if (cached) {\n\t\t// \treturn cached;\n\t\t// }\n\n\t\t// Pre-process quoted text\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\t\tif (q) {\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n\t\t\t}\n\t\t}\n\n\t\t// Get style parts\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n\n\t\t// Empty?\n\t\tif (!b) {\n\t\t\treturn {};\n\t\t}\n\n\t\t//console.log(b)\n\n\t\t// Check each part\n\t\tfor (let i: number = 0; i < b.length; i++) {\n\n\t\t\tif (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n\t\t\t\t(<any>format).fontWeight = b[i];\n\t\t\t}\n\t\t\telse if (b[i] == \"/\") {\n\t\t\t\t// Just closing tag\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if (!b[i].match(/:/)) {\n\t\t\t\t// Color\n\t\t\t\tformat.fill = Color.fromString(b[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst p = b[i].split(/:[ ]*/);\n\t\t\t\t(<any>format)[p[0]] = p[1];\n\t\t\t\t//textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n\t\t\t\t//b[i] = b[i].replace(/\\+/g, \" \");\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO: cache\n\t\t// registry.setCache(\"translateStyleShortcuts_\" + style, res);\n\n\t\treturn format;\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}