{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n/**\r\n * Creates a duration axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\r\n * @important\r\n */\nvar DurationAxis = /** @class */function (_super) {\n  __extends(DurationAxis, _super);\n  function DurationAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n  Object.defineProperty(DurationAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, strictMode) {\n      var e_1, _a;\n      var minMaxStep;\n      var durationFormatter = this.getDurationFormatter();\n      var baseUnit = this.get(\"baseUnit\");\n      // we don't allow to go to smaller units, setting so to avoid invalidation\n      this.setRaw(\"maxPrecision\", 0);\n      if (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n        // will fail if 0\n        if (gridCount <= 1) {\n          gridCount = 1;\n        }\n        gridCount = Math.round(gridCount);\n        var initialMin = min;\n        var initialMax = max;\n        var difference = max - min;\n        // in case min and max is the same, use max\n        if (difference === 0) {\n          difference = Math.abs(max);\n        }\n        var step = difference / gridCount;\n        var divisors = [60, 30, 20, 15, 10, 2, 1];\n        var realDivisor = 1;\n        if (baseUnit == \"hour\") {\n          divisors = [24, 12, 6, 4, 2, 1];\n        }\n        try {\n          for (var divisors_1 = __values(divisors), divisors_1_1 = divisors_1.next(); !divisors_1_1.done; divisors_1_1 = divisors_1.next()) {\n            var divisor = divisors_1_1.value;\n            if (difference / divisor > gridCount) {\n              realDivisor = divisor;\n              break;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (divisors_1_1 && !divisors_1_1.done && (_a = divisors_1.return)) _a.call(divisors_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n        var count = Math.ceil((max - min) / realDivisor / gridCount);\n        var exponent = Math.log(Math.abs(count)) * Math.LOG10E;\n        var power = Math.pow(10, Math.floor(exponent)) / 10;\n        var reducedCount = count / power;\n        // find closest to divisor\n        var closest = $math.closest(divisors, reducedCount);\n        count = closest * power;\n        step = realDivisor * count;\n        min = Math.floor(min / step) * step;\n        max = Math.ceil(max / step) * step;\n        if (strictMode) {\n          min -= step;\n          if (min < 0 && initialMin >= 0) {\n            min = 0;\n          }\n          max += step;\n          if (max > 0 && initialMax <= 0) {\n            max = 0;\n          }\n        }\n        minMaxStep = {\n          min: min,\n          max: max,\n          step: step\n        };\n      } else {\n        minMaxStep = _super.prototype._adjustMinMax.call(this, min, max, gridCount, strictMode);\n      }\n      // choose duration formatter based on step\n      this.setPrivate(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n      return minMaxStep;\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_formatText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var formatter = this.getDurationFormatter();\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  Object.defineProperty(DurationAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var formatter = this.getDurationFormatter();\n      var extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n      var decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n      var value = $math.round(this.positionToValue(position), decimals);\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  Object.defineProperty(DurationAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DurationAxis\"\n  });\n  Object.defineProperty(DurationAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DurationAxis.className])\n  });\n  return DurationAxis;\n}(ValueAxis);\nexport { DurationAxis };","map":{"version":3,"names":["ValueAxis","$utils","$math","DurationAxis","_super","__extends","_this","apply","arguments","Object","defineProperty","value","_settings","themeTags","mergeTags","prototype","_afterNew","call","min","max","gridCount","strictMode","minMaxStep","durationFormatter","getDurationFormatter","baseUnit","get","setRaw","Math","round","initialMin","initialMax","difference","abs","step","divisors","realDivisor","divisors_1","__values","divisors_1_1","next","done","divisor","count","ceil","exponent","log","LOG10E","power","pow","floor","reducedCount","closest","_adjustMinMax","setPrivate","getFormat","formatter","format","getPrivate","position","extraDecimals","decimals","positionToValue","classNames","concat","className"],"sources":["../../../../../../src/.internal/charts/xy/axes/DurationAxis.ts"],"sourcesContent":["import type { AxisRenderer } from \"./AxisRenderer\";\nimport type { TimeUnit } from \"../../../core/util/Time\"\n\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IValueAxisEvents, IMinMaxStep } from \"./ValueAxis\";\n\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n\nexport interface IDurationAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * A base unit (granularity) of data.\n\t *\n\t * Used to indicate what are the base units of your data.\n\t *\n\t * Available options: `\"millisecond\"`, `\"second\"` (default), `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/#Base_unit} for more info\n\t * @default \"second\"\n\t */\n\tbaseUnit?: TimeUnit\n\n}\n\nexport interface IDurationAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDurationAxisPrivate extends IValueAxisPrivate {\n\tdurationFormat: string;\n}\n\nexport interface IDurationAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a duration axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\n * @important\n */\nexport class DurationAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DurationAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DurationAxis.className]);\n\n\tdeclare public _settings: IDurationAxisSettings<R>;\n\tdeclare public _privateSettings: IDurationAxisPrivate;\n\tdeclare public _dataItemSettings: IDurationAxisDataItem;\n\tdeclare public _events: IDurationAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, strictMode?: boolean): IMinMaxStep {\n\n\t\tlet minMaxStep: IMinMaxStep;\n\n\t\tconst durationFormatter = this.getDurationFormatter();\n\t\tconst baseUnit = this.get(\"baseUnit\");\n\t\t// we don't allow to go to smaller units, setting so to avoid invalidation\n\t\tthis.setRaw(\"maxPrecision\", 0);\n\n\t\tif (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n\t\t\t// will fail if 0\n\t\t\tif (gridCount <= 1) {\n\t\t\t\tgridCount = 1;\n\t\t\t}\n\n\t\t\tgridCount = Math.round(gridCount);\n\n\t\t\tlet initialMin: number = min;\n\t\t\tlet initialMax: number = max;\n\n\t\t\tlet difference = max - min;\n\n\t\t\t// in case min and max is the same, use max\n\t\t\tif (difference === 0) {\n\t\t\t\tdifference = Math.abs(max);\n\t\t\t}\n\n\t\t\tlet step = difference / gridCount;\n\n\t\t\tlet divisors = [60, 30, 20, 15, 10, 2, 1];\n\t\t\tlet realDivisor = 1;\n\n\t\t\tif (baseUnit == \"hour\") {\n\t\t\t\tdivisors = [24, 12, 6, 4, 2, 1];\n\t\t\t}\n\n\t\t\tfor (let divisor of divisors) {\n\t\t\t\tif (difference / divisor > gridCount) {\n\t\t\t\t\trealDivisor = divisor;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet count = Math.ceil(((max - min) / realDivisor) / gridCount);\n\n\t\t\tlet exponent: number = Math.log(Math.abs(count)) * Math.LOG10E;\n\t\t\tlet power = Math.pow(10, Math.floor(exponent)) / 10;\n\t\t\tlet reducedCount = count / power;\n\n\t\t\t// find closest to divisor\n\t\t\tlet closest = $math.closest(divisors, reducedCount);\n\t\t\tcount = closest * power;\n\n\t\t\tstep = realDivisor * count;\n\n\t\t\tmin = Math.floor(min / step) * step;\n\t\t\tmax = Math.ceil(max / step) * step;\n\n\t\t\tif (strictMode) {\n\t\t\t\tmin -= step;\n\t\t\t\tif (min < 0 && initialMin >= 0) {\n\t\t\t\t\tmin = 0;\n\t\t\t\t}\n\t\t\t\tmax += step;\n\n\t\t\t\tif (max > 0 && initialMax <= 0) {\n\t\t\t\t\tmax = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tminMaxStep = { min: min, max: max, step: step };\n\t\t}\n\t\telse {\n\t\t\tminMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);\n\t\t}\n\n\t\t// choose duration formatter based on step\n\t\tthis.setPrivate(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n\n\t\treturn minMaxStep;\n\t}\n\n\tprotected _formatText(value: number) {\n\t\tconst formatter = this.getDurationFormatter();\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\tconst formatter = this.getDurationFormatter();\n\t\tconst extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n\t\tconst decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n\t\tconst value = $math.round(this.positionToValue(position), decimals);\n\n\t\treturn formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n\t}\t\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}