{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\n/**\r\n * Creates a date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\r\n * @important\r\n */\n\nvar DateAxis =\n/** @class */\nfunction (_super) {\n  __extends(DateAxis, _super);\n\n  function DateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\n      _super.prototype._afterNew.call(this);\n\n      this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      if (this.isDirty(\"baseInterval\")) {\n        this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var _this = this;\n\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        this.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n        var groupInterval = this.getPrivate(\"groupInterval\");\n\n        if (groupInterval) {\n          this.setPrivateRaw(\"baseInterval\", groupInterval);\n        } else {\n          this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n        }\n\n        if (this.isDirty(\"groupInterval\")) {\n          var groupInterval_1 = this.get(\"groupInterval\");\n\n          if (groupInterval_1) {\n            this.setRaw(\"groupIntervals\", [groupInterval_1]);\n          }\n        }\n\n        if (this.isDirty(\"groupData\")) {\n          if (!this._dataGrouped) {\n            if (this.get(\"groupData\")) {\n              $array.each(this.series, function (series) {\n                _this._groupSeriesData(series);\n              });\n            } else {\n              var baseInterval = this.get(\"baseInterval\");\n              var mainDataSetId_1 = baseInterval.timeUnit + baseInterval.count;\n              $array.each(this.series, function (series) {\n                series.setDataSet(mainDataSetId_1);\n              });\n              this.setPrivateRaw(\"baseInterval\", baseInterval);\n              this.setPrivateRaw(\"groupInterval\", undefined);\n              this.markDirtyExtremes();\n            }\n\n            this._dataGrouped = true;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupSeriesData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(series) {\n      var _this = this;\n\n      if (this.get(\"groupData\")) {\n        // make array of intervals which will be used;\n        var intervals_1 = [];\n        var baseDuration_1 = this.baseMainDuration();\n        var groupIntervals = this.get(\"groupIntervals\");\n\n        if (groupIntervals) {}\n\n        $array.each(groupIntervals, function (interval) {\n          var intervalDuration = $time.getIntervalDuration(interval);\n\n          if (intervalDuration > baseDuration_1) {\n            intervals_1.push(interval);\n          }\n        });\n        series._dataSets = {};\n        var key_1 = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n        var fields_1;\n        var baseAxis = series.get(\"baseAxis\");\n\n        if (series.get(\"xAxis\") === baseAxis) {\n          fields_1 = series._valueYFields;\n        } else if (series.get(\"yAxis\") === baseAxis) {\n          fields_1 = series._valueXFields;\n        }\n\n        var dataItems_1 = series._mainDataItems;\n        var baseInterval = this.get(\"baseInterval\");\n        var mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n        series._dataSets[mainDataSetId] = dataItems_1;\n        $array.eachContinue(intervals_1, function (interval) {\n          var previousTime = -Infinity;\n          var dataSetId = interval.timeUnit + interval.count;\n          series._dataSets[dataSetId] = [];\n          var newDataItem;\n          var sum = {};\n          var count = {};\n          var groupFieldValues = {};\n          var workingFields = {};\n          $array.each(fields_1, function (field) {\n            sum[field] = 0;\n            count[field] = 0;\n            groupFieldValues[field] = series.get(field + \"Grouped\");\n            workingFields[field] = field + \"Working\";\n          });\n          $array.each(dataItems_1, function (dataItem) {\n            var time = dataItem.get(key_1);\n            var roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, _this._root.locale.firstDayOfWeek, _this._root.utc).getTime();\n            var dataContext;\n\n            if (previousTime < roundedTime) {\n              dataContext = $object.copy(dataItem.dataContext);\n              newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n\n              series._dataSets[dataSetId].push(newDataItem);\n\n              $array.each(fields_1, function (field) {\n                var value = dataItem.get(field);\n\n                if ($type.isNumber(value)) {\n                  newDataItem.setRaw(field, value);\n                  newDataItem.setRaw(workingFields[field], value);\n                  count[field]++;\n                  sum[field] += value;\n                }\n              });\n            } else {\n              $array.each(fields_1, function (field) {\n                var groupKey = groupFieldValues[field];\n                var value = dataItem.get(field);\n\n                if (value !== undefined) {\n                  var currentValue = newDataItem.get(field);\n\n                  switch (groupKey) {\n                    case \"close\":\n                      newDataItem.setRaw(field, value);\n                      break;\n\n                    case \"sum\":\n                      newDataItem.setRaw(field, currentValue + value);\n                      break;\n\n                    case \"open\":\n                      break;\n\n                    case \"low\":\n                      if (value < currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n\n                    case \"high\":\n                      if (value > currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n\n                    case \"average\":\n                      count[field]++;\n                      sum[field] += value;\n                      var average = sum[field] / count[field];\n                      newDataItem.setRaw(field, average);\n                      break;\n\n                    case \"extreme\":\n                      if (Math.abs(value) > Math.abs(currentValue)) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n                  }\n\n                  newDataItem.setRaw(workingFields[field], newDataItem.get(field));\n                  var dataContext_1 = $object.copy(dataItem.dataContext);\n                  dataContext_1[key_1] = roundedTime;\n                  newDataItem.dataContext = dataContext_1;\n                }\n              });\n            }\n\n            previousTime = roundedTime;\n          });\n\n          if (series._dataSets[dataSetId].length < _this.get(\"groupCount\", Infinity)) {\n            return false;\n          }\n\n          return true;\n        });\n\n        if (series._dataSetId) {\n          series.setDataSet(series._dataSetId);\n        }\n\n        this.markDirtySize();\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_clearDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      _super.prototype._clearDirty.call(this);\n\n      this._groupingCalculated = false;\n      this._dataGrouped = false;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var _this = this;\n\n      _super.prototype._handleRangeChange.call(this);\n\n      var selectionMin = this.getPrivate(\"selectionMin\");\n      var selectionMax = this.getPrivate(\"selectionMax\");\n\n      if ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n        if (this.get(\"groupData\") && !this._groupingCalculated) {\n          this._groupingCalculated = true;\n          var baseInterval = this.get(\"baseInterval\");\n          var modifiedDifference = selectionMax - selectionMin + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n          var groupInterval = this.get(\"groupInterval\");\n\n          if (!groupInterval) {\n            var groupIntervals = this.get(\"groupIntervals\");\n\n            if (groupIntervals) {\n              groupInterval = $time.chooseInterval(0, modifiedDifference, this.get(\"groupCount\", Infinity), groupIntervals);\n\n              if ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n                groupInterval = __assign({}, baseInterval);\n              }\n            }\n          }\n\n          var current = this.getPrivate(\"groupInterval\");\n\n          if (groupInterval && (!current || current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count)) {\n            this.setPrivateRaw(\"groupInterval\", groupInterval);\n            this.setPrivateRaw(\"baseInterval\", groupInterval);\n\n            if (groupInterval) {\n              var newId_1 = groupInterval.timeUnit + groupInterval.count;\n              $array.each(this.series, function (series) {\n                if (series.get(\"baseAxis\") === _this) {\n                  series.setDataSet(newId_1);\n                }\n              });\n              this.markDirtyExtremes();\n            }\n          }\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.get(\"baseAxis\") === _this) {\n            var fieldName_1 = _this.getPrivate(\"name\") + _this.get(\"renderer\").getPrivate(\"letter\");\n\n            var start = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMin);\n            });\n\n            if (start.index > 0) {\n              start.index -= 1;\n            }\n\n            var end = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMax);\n            });\n            series.setPrivate(\"startIndex\", start.index);\n            series.setPrivate(\"endIndex\", end.index);\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(min, max, gridCount, _strictMode) {\n      return {\n        min: min,\n        max: max,\n        step: (max - min) / gridCount\n      };\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"intervalDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      return this._intervalDuration;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var selectionMin = this.getPrivate(\"selectionMin\");\n        var selectionMax = this.getPrivate(\"selectionMax\");\n        var renderer = this.get(\"renderer\");\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var value = selectionMin;\n        var i = 0;\n        var intervals = this.get(\"gridIntervals\");\n        var gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n        if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n          gridInterval = __assign({}, baseInterval);\n        }\n\n        var intervalDuration = $time.getIntervalDuration(gridInterval);\n        this._intervalDuration = intervalDuration;\n        var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n        value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min)).getTime();\n        var previousValue = value - intervalDuration;\n        var format = void 0;\n        var formats = this.get(\"dateFormats\");\n\n        while (value < selectionMax + intervalDuration) {\n          var dataItem = void 0;\n\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n\n            this._dataItems.push(dataItem);\n\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n\n          this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          dataItem.setRaw(\"value\", value);\n          dataItem.setRaw(\"endValue\", $time.round(new Date(value + intervalDuration * 1.1), gridInterval.timeUnit, gridInterval.count).getTime());\n          var date = new Date(value);\n          format = formats[gridInterval.timeUnit];\n\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if (gridInterval.timeUnit != \"year\") {\n              if ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n                format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n              }\n            }\n          }\n\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", this._root.dateFormatter.format(date, format));\n          }\n\n          this._prepareDataItem(dataItem, gridInterval.count);\n\n          previousValue = value;\n          value = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\n          i++;\n        }\n\n        for (var j = i; j < this.dataItems.length; j++) {\n          this.dataItems[j].hide();\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n      }\n\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(min) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n      var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      return startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(max) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n      var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      return startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n    }\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns a duration of user-defined `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"baseMainDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      return $time.getIntervalDuration(this.get(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"processSeriesDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem, fields) {\n      var _this = this;\n\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      dataItem.open = {};\n      dataItem.close = {};\n      $array.each(fields, function (field) {\n        var value = dataItem.get(field);\n\n        if ($type.isNumber(value)) {\n          var startTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, _this._root.locale.firstDayOfWeek, _this._root.utc).getTime();\n          var endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, _this._root.utc).getTime();\n          dataItem.open[field] = startTime;\n          dataItem.close[field] = endTime;\n        }\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"roundAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(position, location) {\n      var value = this.positionToValue(position);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      value = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n      var endValue = value;\n\n      if (location > 0) {\n        endValue = $time.add(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n      }\n\n      return this.valueToPosition(value + (endValue - value) * location);\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(position) {\n      //@todo number formatter + tag\n      var format = this.get(\"dateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n      return this._root.dateFormatter.format(new Date(this.positionToValue(position)), this.get(\"tooltipDateFormat\", format));\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(series, position) {\n      var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      var value = this.positionToValue(position);\n      var result = $array.getSortedIndex(series.dataItems, function (dataItem) {\n        var diValue = 0;\n\n        if (dataItem.open) {\n          diValue = dataItem.open[fieldName];\n        }\n\n        return $order.compare(diValue, value);\n      });\n\n      if (series.get(\"snapTooltip\")) {\n        var first = series.dataItems[result.index - 1];\n        var second = series.dataItems[result.index];\n\n        if (first && second) {\n          if (first.open && second.close) {\n            var open_1 = first.open[fieldName];\n            var close_1 = second.close[fieldName];\n\n            if (Math.abs(value - open_1) > Math.abs(value - close_1)) {\n              return second;\n            }\n          }\n        }\n\n        return first;\n      } else {\n        // @todo check if is in range\n        var dataItem = series.dataItems[result.index - 1];\n\n        if (dataItem) {\n          if (dataItem.open && dataItem.close) {\n            var open_2 = dataItem.open[fieldName];\n            var close_2 = dataItem.close[fieldName];\n\n            if (value >= open_2 && value <= close_2) {\n              return dataItem;\n            }\n          }\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"shouldGap\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(dataItem, nextItem, autoGapCount, fieldName) {\n      var value1 = dataItem.get(fieldName);\n      var value2 = nextItem.get(fieldName);\n\n      if (value2 - value1 > this.baseDuration() * autoGapCount) {\n        return true;\n      }\n\n      return false;\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"zoomToDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(start, end, duration) {\n      this.zoomToValues(start.getTime(), end.getTime(), duration);\n    }\n  });\n  /**\r\n   * Returns a `Date` object corresponding to specific position within plot\r\n   * area.\r\n   *\r\n   * @param   position  Pposition\r\n   * @return            Date\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"positionToDate\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(position) {\n      return new Date(this.positionToValue(position));\n    }\n  });\n  /**\r\n   * Returns a relative position within plot area that corresponds to specific\r\n   * date.\r\n   *\r\n   * @param   date  Date\r\n   * @return        Position\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"dateToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(date) {\n      return this.valueToPosition(date.getTime());\n    }\n  });\n  Object.defineProperty(DateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DateAxis\"\n  });\n  Object.defineProperty(DateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DateAxis.className])\n  });\n  return DateAxis;\n}(ValueAxis);\n\nexport { DateAxis };","map":{"version":3,"sources":["../../../../../../src/.internal/charts/xy/axes/DateAxis.ts"],"names":[],"mappings":"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","sourcesContent":["import { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport type { XYSeries, IXYSeriesDataItem } from \"../series/XYSeries\";\nimport { ValueAxis, IValueAxisSettings, IValueAxisPrivate, IValueAxisDataItem, IMinMaxStep, IValueAxisEvents } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\n\nexport interface IDateAxisSettings<R extends AxisRenderer> extends IValueAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * @default 1\n\t */\n\tendLocation?: number;\n\n\t/**\n\t * Should axis group data items togeter dynamically?\n\t *\n\t * @default false\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupData?: boolean;\n\n\t/**\n\t * Maximum number of data items in the view before data grouping kicks in.\n\t *\n\t * @default 500\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupCount?: number;\n\n\t/**\n\t * Force data item grouping to specific interval.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to group data items into.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Dynamic_data_item_grouping} for more info\n\t */\n\tgroupIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string | Intl.DateTimeFormatOptions };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\n\t */\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\n\n}\n\nexport interface IDateAxisDataItem extends IValueAxisDataItem {\n}\n\nexport interface IDateAxisPrivate extends IValueAxisPrivate {\n\n\t/**\n\t * Current group interval.\n\t */\n\tgroupInterval?: ITimeInterval;\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n}\n\nexport interface IDateAxisEvents extends IValueAxisEvents {\n}\n\n/**\n * Creates a date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\n * @important\n */\nexport class DateAxis<R extends AxisRenderer> extends ValueAxis<R> {\n\tpublic static className: string = \"DateAxis\";\n\tpublic static classNames: Array<string> = ValueAxis.classNames.concat([DateAxis.className]);\n\n\tdeclare public _settings: IDateAxisSettings<R>;\n\tdeclare public _privateSettings: IDateAxisPrivate;\n\tdeclare public _dataItemSettings: IDateAxisDataItem;\n\tdeclare public _events: IDateAxisEvents;\n\n\tprotected _dataGrouped: boolean = false;\n\tprotected _groupingCalculated: boolean = false;\n\tprotected _intervalDuration: number = 1;\n\n\tpublic _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tsuper._afterNew();\n\n\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\t}\n\n\tpublic _updateChildren(){\n\t\tif(this.isDirty(\"baseInterval\")){\n\t\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\t\t}\n\t}\n\n\n\tprotected _groupData() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif (($type.isNumber(min) && $type.isNumber(max))) {\n\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n\n\t\t\tconst groupInterval = this.getPrivate(\"groupInterval\")!;\n\t\t\tif (groupInterval) {\n\t\t\t\tthis.setPrivateRaw(\"baseInterval\", groupInterval);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\t\t\t}\n\n\n\t\t\tif (this.isDirty(\"groupInterval\")) {\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\")!;\n\t\t\t\tif (groupInterval) {\n\t\t\t\t\tthis.setRaw(\"groupIntervals\", [groupInterval]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isDirty(\"groupData\")) {\n\t\t\t\tif (!this._dataGrouped) {\n\t\t\t\t\tif (this.get(\"groupData\")) {\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tthis._groupSeriesData(series);\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\t\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tseries.setDataSet(mainDataSetId);\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tthis.setPrivateRaw(\"baseInterval\", baseInterval);\n\t\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", undefined);\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t\tthis._dataGrouped = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic _groupSeriesData(series: XYSeries) {\n\t\tif (this.get(\"groupData\")) {\n\t\t\t// make array of intervals which will be used;\n\t\t\tlet intervals: ITimeInterval[] = [];\n\t\t\tlet baseDuration = this.baseMainDuration();\n\n\t\t\tlet groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\tif (groupIntervals) { }\n\t\t\t$array.each(groupIntervals, (interval) => {\n\t\t\t\tlet intervalDuration = $time.getIntervalDuration(interval);\n\t\t\t\tif (intervalDuration > baseDuration) {\n\t\t\t\t\tintervals.push(interval);\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tseries._dataSets = {};\n\n\t\t\tconst key = this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!;\n\t\t\tlet fields: Array<string>;\n\n\t\t\tconst baseAxis = series.get(\"baseAxis\");\n\n\t\t\tif (series.get(\"xAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueYFields;\n\t\t\t}\n\t\t\telse if (series.get(\"yAxis\") === baseAxis) {\n\t\t\t\tfields = series._valueXFields;\n\t\t\t}\n\n\t\t\tlet dataItems = series._mainDataItems;\n\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\t\t\tlet mainDataSetId: string = baseInterval.timeUnit + baseInterval.count;\n\n\t\t\tseries._dataSets[mainDataSetId] = dataItems;\n\n\t\t\t$array.eachContinue(intervals, (interval) => {\n\n\t\t\t\tlet previousTime = -Infinity;\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\n\t\t\t\tseries._dataSets[dataSetId] = [];\n\n\t\t\t\tlet newDataItem: DataItem<IXYSeriesDataItem>;\n\n\t\t\t\tlet sum: { [index: string]: number } = {};\n\t\t\t\tlet count: { [index: string]: number } = {};\n\n\t\t\t\tlet groupFieldValues: { [index: string]: string } = {};\n\t\t\t\tlet workingFields: { [index: string]: string } = {};\n\n\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\tsum[field] = 0;\n\t\t\t\t\tcount[field] = 0;\n\t\t\t\t\tgroupFieldValues[field] = series.get((field + \"Grouped\") as any);\n\t\t\t\t\tworkingFields[field] = field + \"Working\";\n\t\t\t\t})\n\n\n\t\t\t\t$array.each(dataItems, (dataItem) => {\n\t\t\t\t\tlet time = dataItem.get(key as any);\n\t\t\t\t\tlet roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\t\t\t\tlet dataContext: any;\n\n\t\t\t\t\tif (previousTime < roundedTime) {\n\t\t\t\t\t\tdataContext = $object.copy(dataItem.dataContext);\n\n\t\t\t\t\t\tnewDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n\t\t\t\t\t\tseries._dataSets[dataSetId].push(newDataItem);\n\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif ($type.isNumber(value)) {\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, value);\n\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$array.each(fields, (field) => {\n\t\t\t\t\t\t\tlet groupKey = groupFieldValues[field];\n\t\t\t\t\t\t\tlet value = dataItem.get(field as any);\n\t\t\t\t\t\t\tif (value !== undefined) {\n\n\t\t\t\t\t\t\t\tlet currentValue = newDataItem.get(field as any);\n\n\t\t\t\t\t\t\t\tswitch (groupKey) {\n\t\t\t\t\t\t\t\t\tcase \"close\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, currentValue + value);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"open\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"low\":\n\t\t\t\t\t\t\t\t\t\tif (value < currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"high\":\n\t\t\t\t\t\t\t\t\t\tif (value > currentValue) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"average\":\n\t\t\t\t\t\t\t\t\t\tcount[field]++;\n\t\t\t\t\t\t\t\t\t\tsum[field] += value;\n\t\t\t\t\t\t\t\t\t\tlet average = sum[field] / count[field];\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, average);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase \"extreme\":\n\t\t\t\t\t\t\t\t\t\tif (Math.abs(value) > Math.abs(currentValue)) {\n\t\t\t\t\t\t\t\t\t\t\tnewDataItem.setRaw(field as any, value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnewDataItem.setRaw(workingFields[field] as any, newDataItem.get(field as any));\n\t\t\t\t\t\t\t\tlet dataContext: any = $object.copy(dataItem.dataContext);\n\t\t\t\t\t\t\t\tdataContext[key as any] = roundedTime\n\t\t\t\t\t\t\t\tnewDataItem.dataContext = dataContext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tpreviousTime = roundedTime;\n\t\t\t\t})\n\n\t\t\t\tif (series._dataSets[dataSetId].length < this.get(\"groupCount\", Infinity)) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t})\n\t\t\tif(series._dataSetId){\n\t\t\t\tseries.setDataSet(series._dataSetId);\n\t\t\t}\n\t\t\tthis.markDirtySize();\n\t\t}\n\t}\n\n\tpublic _clearDirty() {\n\t\tsuper._clearDirty();\n\t\tthis._groupingCalculated = false;\n\t\tthis._dataGrouped = false;\n\t}\n\n\tprotected _handleRangeChange() {\n\t\tsuper._handleRangeChange();\n\n\t\tconst selectionMin = this.getPrivate(\"selectionMin\");\n\t\tconst selectionMax = this.getPrivate(\"selectionMax\");\n\n\t\tif ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n\n\t\t\tif (this.get(\"groupData\") && !this._groupingCalculated) {\n\t\t\t\tthis._groupingCalculated = true;\n\t\t\t\tlet baseInterval = this.get(\"baseInterval\");\n\n\t\t\t\tlet modifiedDifference = (selectionMax - selectionMin) + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n\t\t\t\tlet groupInterval = this.get(\"groupInterval\");\n\n\t\t\t\tif (!groupInterval) {\n\t\t\t\t\tconst groupIntervals = this.get(\"groupIntervals\")!;\n\t\t\t\t\tif (groupIntervals) {\n\t\t\t\t\t\tgroupInterval = $time.chooseInterval(0, modifiedDifference, this.get(\"groupCount\", Infinity), groupIntervals);\n\t\t\t\t\t\tif ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n\t\t\t\t\t\t\tgroupInterval = { ...baseInterval };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet current = this.getPrivate(\"groupInterval\");\n\n\t\t\t\tif (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count))) {\n\t\t\t\t\tthis.setPrivateRaw(\"groupInterval\", groupInterval);\n\t\t\t\t\tthis.setPrivateRaw(\"baseInterval\", groupInterval!);\n\n\t\t\t\t\tif (groupInterval) {\n\t\t\t\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\n\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\t\t\t\tseries.setDataSet(newId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.markDirtyExtremes();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.get(\"baseAxis\") === this) {\n\t\t\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\n\t\t\t\t\tconst start = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMin);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (start.index > 0) {\n\t\t\t\t\t\tstart.index -= 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst end = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\t\t\t\treturn $order.compare(dataItem.get(fieldName), selectionMax);\n\t\t\t\t\t});\n\n\t\t\t\t\tseries.setPrivate(\"startIndex\", start.index);\n\t\t\t\t\tseries.setPrivate(\"endIndex\", end.index);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, _strictMode?: boolean): IMinMaxStep {\n\t\treturn { min: min, max: max, step: (max - min) / gridCount };\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic intervalDuration(): number {\n\t\treturn this._intervalDuration;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tconst selectionMin = this.getPrivate(\"selectionMin\")! as number;\n\t\t\tconst selectionMax = this.getPrivate(\"selectionMax\")! as number;\n\t\t\tconst renderer = this.get(\"renderer\");\n\t\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\t\tlet value = selectionMin;\n\t\t\tlet i = 0;\n\n\t\t\tconst intervals = this.get(\"gridIntervals\")!;\n\t\t\tlet gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n\t\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\t\tgridInterval = { ...baseInterval };\n\t\t\t}\n\n\t\t\tconst intervalDuration = $time.getIntervalDuration(gridInterval);\n\t\t\tthis._intervalDuration = intervalDuration;\n\n\t\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\t\tvalue = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min)).getTime();\n\t\t\tlet previousValue = value - intervalDuration;\n\t\t\tlet format: string | Intl.DateTimeFormatOptions;\n\t\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\t\twhile (value < selectionMax + intervalDuration) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\t\t\t\tdataItem.setRaw(\"endValue\", $time.round(new Date(value + intervalDuration * 1.1), gridInterval.timeUnit, gridInterval.count).getTime());\n\t\t\t\t\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tformat = formats[gridInterval.timeUnit];\n\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\t\t\t\t\tif (gridInterval.timeUnit != \"year\") {\n\t\t\t\t\t\tif ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n\t\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem, gridInterval.count);\n\n\t\t\t\tpreviousValue = value;\n\n\t\t\t\tvalue = $time.add(new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.utc).getTime();\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis.dataItems[j].hide();\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n\t}\n\n\tprotected _fixMax(max: number) {\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tlet startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\n\t\treturn startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\t/**\n\t * Returns a duration of user-defined `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseMainDuration(): number {\n\t\treturn $time.getIntervalDuration(this.get(\"baseInterval\"));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic processSeriesDataItem(dataItem: DataItem<IXYSeriesDataItem>, fields: Array<string>) {\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tdataItem.open = {};\n\t\tdataItem.close = {};\n\n\t\t$array.each(fields, (field) => {\n\t\t\tlet value = dataItem.get(field as any);\n\t\t\tif ($type.isNumber(value)) {\n\t\t\t\tlet startTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\t\t\tlet endTime = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\t\t\t\tdataItem.open![field] = startTime;\n\t\t\t\tdataItem.close![field] = endTime;\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\tlet openValue;\n\t\tlet closeValue;\n\n\t\tif (dataItem.open && dataItem.close) {\n\t\t\topenValue = dataItem.open[field];\n\t\t\tcloseValue = dataItem.close[field];\n\t\t}\n\t\telse {\n\t\t\topenValue = dataItem.get(field as any)\n\t\t\tcloseValue = openValue;\n\t\t}\n\n\t\tlet value = openValue + (closeValue - openValue) * cellLocation;\n\n\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\tlet value = this.positionToValue(position);\n\t\tlet baseInterval = this.getPrivate(\"baseInterval\");\n\t\tvalue = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc).getTime();\n\t\tlet endValue = value;\n\t\tif (location > 0) {\n\t\t\tendValue = $time.add(new Date(value), baseInterval.timeUnit, baseInterval.count, this._root.utc).getTime();\n\t\t}\n\t\treturn this.valueToPosition(value + (endValue - value) * location);\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\n\t\tlet format = this.get(\"dateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\treturn this._root.dateFormatter.format(new Date(this.positionToValue(position)), this.get(\"tooltipDateFormat\", format));\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\t\tconst result = $array.getSortedIndex(series.dataItems, (dataItem) => {\n\t\t\tvar diValue = 0;\n\t\t\tif (dataItem.open) {\n\t\t\t\tdiValue = dataItem.open[fieldName];\n\t\t\t}\n\t\t\t\n\t\t\treturn $order.compare(diValue, value);\n\t\t});\n\n\t\tif (series.get(\"snapTooltip\")) {\n\t\t\tlet first = series.dataItems[result.index - 1];\n\t\t\tlet second = series.dataItems[result.index];\n\n\t\t\tif (first && second) {\n\t\t\t\tif (first.open && second.close) {\n\t\t\t\t\tlet open = first.open[fieldName];\n\t\t\t\t\tlet close = second.close[fieldName];\n\n\t\t\t\t\tif (Math.abs(value - open) > Math.abs(value - close)) {\n\t\t\t\t\t\treturn second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t}\n\t\telse {\n\t\t\t// @todo check if is in range\n\t\t\tconst dataItem = series.dataItems[result.index - 1];\n\n\t\t\tif (dataItem) {\n\t\t\t\tif (dataItem.open && dataItem.close) {\n\t\t\t\t\tlet open = dataItem.open[fieldName];\n\t\t\t\t\tlet close = dataItem.close[fieldName];\n\n\t\t\t\t\tif (value >= open && value <= close) {\n\t\t\t\t\t\treturn dataItem;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic shouldGap(dataItem: DataItem<IXYSeriesDataItem>, nextItem: DataItem<IXYSeriesDataItem>, autoGapCount: number, fieldName: string): boolean {\n\t\tconst value1 = dataItem.get(fieldName as any);\n\t\tconst value2 = nextItem.get(fieldName as any);\n\n\t\tif (value2 - value1 > this.baseDuration() * autoGapCount) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` dates.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start Date\n\t * @param  end       End Date\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToDates(start: Date, end: Date, duration?: number) {\n\t\tthis.zoomToValues(start.getTime(), end.getTime(), duration);\n\t}\n\n\t/**\n\t * Returns a `Date` object corresponding to specific position within plot\n\t * area.\n\t *\n\t * @param   position  Pposition\n\t * @return            Date\n\t */\n\tpublic positionToDate(position: number): Date {\n\t\treturn new Date(this.positionToValue(position));\n\t}\n\n\t/**\n\t * Returns a relative position within plot area that corresponds to specific\n\t * date.\n\t *\n\t * @param   date  Date\n\t * @return        Position\n\t */\n\tpublic dateToPosition(date: Date): number {\n\t\treturn this.valueToPosition(date.getTime());\n\t}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}