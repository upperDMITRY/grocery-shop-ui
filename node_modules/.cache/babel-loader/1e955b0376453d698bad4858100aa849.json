{"ast":null,"code":"/** @ignore */\n\n/** */\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n/**\r\n * @ignore\r\n */\n\nexport function populateString(target, string) {\n  if (string != null) {\n    string = \"\" + string;\n    string = TextFormatter.escape(string);\n    var tags = string.match(/\\{([^}]+)\\}/g);\n    var i = void 0;\n\n    if (tags) {\n      for (i = 0; i < tags.length; i++) {\n        var tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n        var value = getTagValue(target, tag, \"\");\n\n        if (value == null) {\n          value = \"\";\n        }\n\n        string = string.split(tags[i]).join(value);\n      }\n    }\n\n    string = TextFormatter.unescape(string);\n  } else {\n    string = \"\";\n  } // TODO: apply adapter?\n\n\n  return string;\n}\n/**\r\n * @ignore\r\n */\n\nfunction getTagValue(target, tagName, format) {\n  var value;\n  var dataItem = target.dataItem; // Parse parts\n\n  var parts = [];\n  var reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;\n  ;\n  var matches;\n\n  while (true) {\n    matches = reg.exec(tagName);\n\n    if (matches === null) {\n      break;\n    }\n\n    if (matches[3]) {\n      // Simple property\n      parts.push({\n        prop: matches[3]\n      }); // Check if maybe we should force a formatter on this value\n\n      var dateFields = target.getDateFormatter().get(\"dateFields\", []);\n      var numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n      var durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n\n      if (dateFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDate\",\n          params: []\n        });\n      } else if (numericFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatNumber\",\n          params: []\n        });\n      } else if (durationFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDuration\",\n          params: []\n        });\n      }\n    } else {\n      // Method\n      // Parse parameters\n      var params = [];\n\n      if ($utils.trim(matches[2]) != \"\") {\n        var reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n        var matches2 = void 0;\n\n        while (true) {\n          matches2 = reg2.exec(matches[2]);\n\n          if (matches2 === null) {\n            break;\n          }\n\n          params.push(matches2[1] || matches2[2] || matches2[3]);\n        }\n      }\n\n      parts.push({\n        method: matches[1],\n        params: params\n      });\n    }\n  } // Check if we can retrieve the value from data item\n\n\n  if (dataItem) {\n    // Check values\n    value = getTagValueFromObject(target, parts, dataItem._settings); // Check properties\n\n    if (value == null || $type.isObject(value)) {\n      // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n      value = getTagValueFromObject(target, parts, dataItem);\n    } // Check data context\n\n\n    var dataContext = dataItem.dataContext;\n\n    if (value == null && dataContext) {\n      value = getTagValueFromObject(target, parts, dataContext); // Maybe it's a literal dot-separated name of the key in dataContext?\n\n      if (value == null) {\n        value = getTagValueFromObject(target, [{\n          prop: tagName\n        }], dataContext);\n      } // scond data context level sometimes exist (tree map)\n\n\n      if (value == null && dataContext.dataContext) {\n        value = getTagValueFromObject(target, parts, dataContext.dataContext);\n      }\n    } // Check component's data item\n\n\n    if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n      value = getTagValue(dataItem.component, tagName, format);\n    }\n  } // Check sprite's properties\n\n\n  if (value == null) {\n    value = getTagValueFromObject(target, parts, target);\n  } // Finally, check the parent\n\n\n  if (value == null && target.parent) {\n    value = getTagValue(target.parent, tagName, format);\n  }\n\n  return value;\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction getTagValueFromObject(target, parts, object, format) {\n  var current = object;\n  var formatApplied = false;\n\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n\n    if (part.prop) {\n      // Regular property\n      if (current instanceof Sprite) {\n        current = current.get(part.prop) || current.getPrivate(part.prop) || current[part.prop];\n      } else if (current.get) {\n        current = current.get(part.prop) || current[part.prop];\n      } else {\n        current = current[part.prop];\n      }\n\n      if (current == null) {\n        // Not set, return undefined\n        return;\n      }\n    } else {\n      // Method\n      switch (part.method) {\n        case \"formatNumber\":\n          var numberValue = $type.toNumber(current);\n\n          if (numberValue != null) {\n            current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"formatDate\":\n          var dateValue = $type.toDate(current);\n\n          if (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n            // Was not able to get date out of value, quitting and letting\n            // calling method try another value\n            return;\n          }\n\n          if (dateValue != null) {\n            current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"formatDuration\":\n          var durationValue = $type.toNumber(current);\n\n          if (durationValue != null) {\n            current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"urlEncode\":\n        case \"encodeURIComponent\":\n          current = encodeURIComponent(current);\n          break;\n\n        default:\n          if (current[part.method]) {\n            current[part.method].apply(object, part.params);\n          }\n\n          break;\n      }\n    }\n  } // Apply default format if it wasn't applied explicitly\n\n\n  if (!formatApplied) {\n    var formatParts = [{\n      method: \"\",\n      params: format\n    }];\n\n    if (format == null) {\n      // Format is not set\n      // Determine from the type of the value\n      if ($type.isNumber(current)) {\n        formatParts[0].method = \"formatNumber\";\n        formatParts[0].params = \"\";\n      } else if ($type.isDate(current)) {\n        formatParts[0].method = \"formatDate\";\n        formatParts[0].params = \"\";\n      }\n    } else {\n      // Format set\n      // Try to determine formatter based on the format\n      var formatterType = $utils.getFormat(format); // format\n\n      if (formatterType === \"number\") {\n        formatParts[0].method = \"formatNumber\";\n      } else if (formatterType === \"date\") {\n        formatParts[0].method = \"formatDate\";\n      } else if (formatterType === \"duration\") {\n        formatParts[0].method = \"formatDuration\";\n      }\n    } // Apply format\n\n\n    if (formatParts[0].method) {\n      current = getTagValueFromObject(target, formatParts, current);\n    }\n  }\n\n  return current;\n}","map":{"version":3,"sources":["../../../../../src/.internal/core/util/PopulateString.ts"],"names":[],"mappings":"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","sourcesContent":["/** @ignore *//** */\n\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n\n/**\n * @ignore\n */\nexport function populateString(target: Sprite, string: string): string {\n\tif (string != null) {\n\t\tstring = \"\" + string;\n\t\tstring = TextFormatter.escape(string);\n\t\tlet tags = string.match(/\\{([^}]+)\\}/g);\n\t\tlet i;\n\t\tif (tags) {\n\t\t\tfor (i = 0; i < tags.length; i++) {\n\t\t\t\tlet tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n\t\t\t\tlet value = getTagValue(target, tag, \"\");\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = \"\";\n\t\t\t\t}\n\n\t\t\t\tstring = string.split(tags[i]).join(value);\n\t\t\t}\n\t\t}\n\t\tstring = TextFormatter.unescape(string);\n\t}\n\telse {\n\t\tstring = \"\";\n\t}\n\n\t// TODO: apply adapter?\n\treturn string;\n}\n\n/**\n * @ignore\n */\nfunction getTagValue(target: Sprite, tagName: string, format?: string): string {\n\tlet value: any;\n\tconst dataItem = target.dataItem;\n\n\t// Parse parts\n\tlet parts: any[] = [];\n\tlet reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;;\n\tlet matches;\n\n\twhile (true) {\n\t\tmatches = reg.exec(tagName);\n\n\t\tif (matches === null) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (matches[3]) {\n\t\t\t// Simple property\n\t\t\tparts.push({\n\t\t\t\tprop: matches[3]\n\t\t\t});\n\n\t\t\t// Check if maybe we should force a formatter on this value\n\t\t\tconst dateFields = target.getDateFormatter().get(\"dateFields\", []);\n\t\t\tconst numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n\t\t\tconst durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n\t\t\tif ((<any>dateFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatDate\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((<any>numericFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatNumber\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((<any>durationFields).indexOf(matches[3]) !== -1) {\n\t\t\t\tparts.push({\n\t\t\t\t\tmethod: \"formatDuration\",\n\t\t\t\t\tparams: []\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Method\n\t\t\t// Parse parameters\n\t\t\tlet params: any[] = [];\n\t\t\tif ($utils.trim(matches[2]) != \"\") {\n\t\t\t\tlet reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n\t\t\t\tlet matches2;\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tmatches2 = reg2.exec(matches[2]);\n\n\t\t\t\t\tif (matches2 === null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.push(matches2[1] || matches2[2] || matches2[3])\n\t\t\t\t}\n\t\t\t}\n\t\t\tparts.push({\n\t\t\t\tmethod: matches[1],\n\t\t\t\tparams: params\n\t\t\t})\n\t\t}\n\t}\n\n\t// Check if we can retrieve the value from data item\n\tif (dataItem) {\n\n\n\t\t// Check values\n\t\tvalue = getTagValueFromObject(target, parts, dataItem._settings);\n\n\t\t// Check properties\n\t\tif (value == null || $type.isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n\t\t\tvalue = getTagValueFromObject(target, parts, dataItem);\n\t\t}\n\n\t\t// Check data context\n\t\tlet dataContext: any = dataItem.dataContext;\n\n\t\tif (value == null && dataContext) {\n\t\t\tvalue = getTagValueFromObject(target, parts, dataContext);\n\n\t\t\t// Maybe it's a literal dot-separated name of the key in dataContext?\n\t\t\tif (value == null) {\n\t\t\t\tvalue = getTagValueFromObject(target, [{\n\t\t\t\t\tprop: tagName\n\t\t\t\t}], dataContext);\n\t\t\t}\n\n\t\t\t// scond data context level sometimes exist (tree map)\n\t\t\tif (value == null && dataContext.dataContext) {\n\t\t\t\tvalue = getTagValueFromObject(target, parts, dataContext.dataContext);\n\t\t\t}\n\t\t}\n\n\t\t// Check component's data item\n\t\tif (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n\t\t\tvalue = getTagValue(dataItem.component, tagName, format);\n\t\t}\n\t}\n\n\t// Check sprite's properties\n\tif (value == null) {\n\t\tvalue = getTagValueFromObject(target, parts, target);\n\t}\n\n\t// Finally, check the parent\n\tif (value == null && target.parent) {\n\t\tvalue = getTagValue(target.parent, tagName, format);\n\t}\n\n\treturn value;\n}\n\n/**\n * @ignore\n */\nfunction getTagValueFromObject(target: Sprite, parts: any[], object: any, format?: string): any {\n\tlet current: any = object;\n\tlet formatApplied = false;\n\tfor (let i = 0, len = parts.length; i < len; i++) {\n\t\tlet part = parts[i];\n\t\tif (part.prop) {\n\t\t\t// Regular property\n\t\t\tif (current instanceof Sprite) {\n\t\t\t\tcurrent = current.get(part.prop) || current.getPrivate(part.prop) || (<any>current)[part.prop];\n\t\t\t}\n\t\t\telse if (current.get) {\n\t\t\t\tcurrent = current.get(part.prop) || (<any>current)[part.prop];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent = current[part.prop];\n\t\t\t}\n\t\t\tif (current == null) {\n\t\t\t\t// Not set, return undefined\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Method\n\n\t\t\tswitch (part.method) {\n\t\t\t\tcase \"formatNumber\":\n\t\t\t\t\tlet numberValue = $type.toNumber(current);\n\t\t\t\t\tif (numberValue != null) {\n\t\t\t\t\t\tcurrent = target.getNumberFormatter().format(\n\t\t\t\t\t\t\tnumberValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"formatDate\":\n\t\t\t\t\tlet dateValue = $type.toDate(current);\n\t\t\t\t\tif (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n\t\t\t\t\t\t// Was not able to get date out of value, quitting and letting\n\t\t\t\t\t\t// calling method try another value\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (dateValue != null) {\n\t\t\t\t\t\tcurrent = target.getDateFormatter().format(\n\t\t\t\t\t\t\tdateValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"formatDuration\":\n\t\t\t\t\tlet durationValue = $type.toNumber(current);\n\t\t\t\t\tif (durationValue != null) {\n\t\t\t\t\t\tcurrent = target.getDurationFormatter().format(\n\t\t\t\t\t\t\tdurationValue,\n\t\t\t\t\t\t\tformat || part.params[0] || undefined,\n\t\t\t\t\t\t\tpart.params[1] || undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t\tformatApplied = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"urlEncode\":\n\t\t\t\tcase \"encodeURIComponent\":\n\t\t\t\t\tcurrent = encodeURIComponent(current);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (current[part.method]) {\n\t\t\t\t\t\tcurrent[part.method].apply(object, part.params);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply default format if it wasn't applied explicitly\n\tif (!formatApplied) {\n\n\t\tlet formatParts = [{\n\t\t\tmethod: \"\",\n\t\t\tparams: format\n\t\t}];\n\n\t\tif (format == null) {\n\n\t\t\t// Format is not set\n\t\t\t// Determine from the type of the value\n\t\t\tif ($type.isNumber(current)) {\n\t\t\t\tformatParts[0].method = \"formatNumber\";\n\t\t\t\tformatParts[0].params = \"\";\n\t\t\t}\n\t\t\telse if ($type.isDate(current)) {\n\t\t\t\tformatParts[0].method = \"formatDate\";\n\t\t\t\tformatParts[0].params = \"\";\n\t\t\t}\n\n\t\t}\n\t\telse {\n\n\t\t\t// Format set\n\t\t\t// Try to determine formatter based on the format\n\t\t\tlet formatterType: string = $utils.getFormat(format);\n\n\t\t\t// format\n\t\t\tif (formatterType === \"number\") {\n\t\t\t\tformatParts[0].method = \"formatNumber\";\n\t\t\t}\n\t\t\telse if (formatterType === \"date\") {\n\t\t\t\tformatParts[0].method = \"formatDate\";\n\t\t\t}\n\t\t\telse if (formatterType === \"duration\") {\n\t\t\t\tformatParts[0].method = \"formatDuration\";\n\t\t\t}\n\n\t\t}\n\n\t\t// Apply format\n\t\tif (formatParts[0].method) {\n\t\t\tcurrent = getTagValueFromObject(target, formatParts, current);\n\t\t}\n\n\t}\n\n\treturn current;\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}