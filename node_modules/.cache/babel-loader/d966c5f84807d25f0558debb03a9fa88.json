{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { Color } from \"./Color\";\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\nvar ColorSet = /** @class */function (_super) {\n  __extends(ColorSet, _super);\n  function ColorSet() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  //protected _currentPass: number = 0;\n  Object.defineProperty(ColorSet.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // Applying themes because color set will not have parent\n      _super.prototype._afterNewApplyThemes.call(this);\n    }\n  });\n  Object.defineProperty(ColorSet.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n      if (this.isDirty(\"startIndex\")) {\n        this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ColorSet.prototype, \"generateColors\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\n      var pass = this.getPrivate(\"currentPass\");\n      var colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n      if (!this.getPrivate(\"numColors\")) {\n        this.setPrivate(\"numColors\", colors.length);\n      }\n      //const len = colors.length;\n      var len = this.getPrivate(\"numColors\");\n      //const start = len - this.getPrivate(\"numColors\")!;\n      var start = 0;\n      var passOptions = this.get(\"passOptions\");\n      var reuse = this.get(\"reuse\");\n      for (var i = start; i < len; i++) {\n        if (reuse) {\n          colors.push(colors[i]);\n        } else {\n          var hsl = colors[i].toHSL();\n          var h = hsl.h + (passOptions.hue || 0) * pass;\n          while (h > 1) h -= 1;\n          var s = hsl.s + (passOptions.saturation || 0) * pass;\n          //if (s > 1) s -= Math.floor(s);\n          if (s > 1) s = 1;\n          if (s < 0) s = 0;\n          var l = hsl.l + (passOptions.lightness || 0) * pass;\n          //if (l > 1) l -= Math.floor(l);\n          while (l > 1) l -= 1;\n          colors.push(Color.fromHSL(h, s, l));\n        }\n      }\n    }\n  });\n  /**\r\n   * Returns a [[Color]] at specific index.\r\n   *\r\n   * If there's no color at this index, a new color is generated.\r\n   *\r\n   * @param   index  Index\r\n   * @return         Color\r\n   */\n  Object.defineProperty(ColorSet.prototype, \"getIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      var colors = this.get(\"colors\", []);\n      var saturation = this.get(\"saturation\");\n      if (index >= colors.length) {\n        this.generateColors();\n        return this.getIndex(index);\n      }\n      return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\n    }\n  });\n  /**\r\n   * Returns next [[Color]] in the list.\r\n   *\r\n   * If the list is out of colors, new ones are generated dynamically.\r\n   */\n  Object.defineProperty(ColorSet.prototype, \"next\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var currentStep = this.getPrivate(\"currentStep\", 0);\n      this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n      return this.getIndex(currentStep);\n    }\n  });\n  /**\r\n   * Resets counter to the start of the list, so the next call for `next()` will\r\n   * return the first color.\r\n   */\n  Object.defineProperty(ColorSet.prototype, \"reset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n    }\n  });\n  Object.defineProperty(ColorSet, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"ColorSet\"\n  });\n  Object.defineProperty(ColorSet, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Entity.classNames.concat([ColorSet.className])\n  });\n  return ColorSet;\n}(Entity);\nexport { ColorSet };","map":{"version":3,"names":["Entity","Color","ColorSet","_super","__extends","value","prototype","_afterNewApplyThemes","call","_beforeChanged","isDirty","setPrivate","get","getPrivate","pass","colors","fromHex","length","len","start","passOptions","reuse","i","push","hsl","toHSL","h","hue","s","saturation","l","lightness","fromHSL","index","generateColors","getIndex","saturate","currentStep","Object","defineProperty","classNames","concat","className"],"sources":["../../../../../src/.internal/core/util/ColorSet.ts"],"sourcesContent":["import { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\";\nimport { Color } from \"./Color\";\n\n\nexport interface IColorSetSettings extends IEntitySettings {\n\n\t/**\n\t * List of colors in the set.\n\t */\n\tcolors?: Color[];\n\n\t/**\n\t * A step size when using `next()`.\n\t *\n\t * E.g. setting to `2` will make it return every second color in the list.\n\t *\n\t * @default 1\n\t */\n\tstep?: number;\n\n\t/**\n\t * Start iterating colors from specific index.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * If set to `true`, color set will reuse existing colors from the list\n\t * inestead of generating new ones.\n\t *\n\t * @default false\n\t */\n\treuse?: boolean;\n\n\t/**\n\t * A base color to generate new colors from if `colors` is not specified.\n\t * @type {[type]}\n\t */\n\tbaseColor?: Color;\n\n\t/**\n\t * A set of tranformation to apply to base list of colors when the set runs\n\t * out of colors and generates additional ones.\n\t */\n\tpassOptions?: IColorSetStepOptions;\n\n\t/**\n\t * If set, each returned color will be applied saturation.\n\t */\n\tsaturation?: number;\n\n\t// count?: number;\n}\n\nexport interface IColorSetPrivate extends IEntityPrivate {\n\n\tcurrentStep?: number;\n\tcurrentPass?: number;\n\n\t/**\n\t * @ignore\n\t */\n\tnumColors?: number;\n\n}\n\nexport interface IColorSetStepOptions {\n\n\t/**\n\t * Value to add to \"hue\".\n\t */\n\thue?: number;\n\n\t/**\n\t * Value to add to \"saturation\".\n\t */\n\tsaturation?: number;\n\n\t/**\n\t * Value to add to \"lightness\".\n\t */\n\tlightness?: number;\n\n}\n\n\n/**\n * An object which holds list of colors and can generate new ones.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\n */\nexport class ColorSet extends Entity {\n\tpublic static className: string = \"ColorSet\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([ColorSet.className]);\n\n\tdeclare public _settings: IColorSetSettings;\n\tdeclare public _privateSettings: IColorSetPrivate;\n\n\t//protected _currentPass: number = 0;\n\n\tprotected _afterNew() {\n\t\t// Applying themes because color set will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t}\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\t\tif (this.isDirty(\"startIndex\")) {\n\t\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0))\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic generateColors(): void {\n\t\tthis.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1)\n\t\tconst pass = this.getPrivate(\"currentPass\");\n\t\tconst colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\t\tif (!this.getPrivate(\"numColors\")) {\n\t\t\tthis.setPrivate(\"numColors\", colors.length);\n\t\t}\n\t\t//const len = colors.length;\n\t\tconst len = this.getPrivate(\"numColors\")!;\n\t\t//const start = len - this.getPrivate(\"numColors\")!;\n\t\tconst start = 0;\n\t\tconst passOptions = this.get(\"passOptions\")!;\n\t\tconst reuse = this.get(\"reuse\");\n\t\tfor (let i = start; i < len; i++) {\n\t\t\tif (reuse) {\n\t\t\t\tcolors.push(colors[i])\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst hsl = colors[i]!.toHSL();\n\t\t\t\tlet h = hsl.h + (passOptions.hue || 0) * pass!;\n\t\t\t\twhile (h > 1) h -= 1;\n\n\t\t\t\tlet s = hsl.s + (passOptions.saturation || 0) * pass!;\n\t\t\t\t//if (s > 1) s -= Math.floor(s);\n\t\t\t\tif (s > 1) s = 1;\n\t\t\t\tif (s < 0) s = 0;\n\n\t\t\t\tlet l = hsl.l + (passOptions.lightness || 0) * pass!;\n\t\t\t\t//if (l > 1) l -= Math.floor(l);\n\t\t\t\twhile (l > 1) l -= 1;\n\t\t\t\tcolors.push(Color.fromHSL(h, s, l));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a [[Color]] at specific index.\n\t *\n\t * If there's no color at this index, a new color is generated.\n\t *\n\t * @param   index  Index\n\t * @return         Color\n\t */\n\tpublic getIndex(index: number): Color {\n\t\tconst colors = this.get(\"colors\", []);\n\t\tconst saturation = this.get(\"saturation\");\n\t\tif (index >= colors.length) {\n\t\t\tthis.generateColors();\n\t\t\treturn this.getIndex(index);\n\t\t}\n\n\t\treturn saturation != null ? Color.saturate(colors[index], saturation!) : colors[index];\n\t}\n\n\t/**\n\t * Returns next [[Color]] in the list.\n\t *\n\t * If the list is out of colors, new ones are generated dynamically.\n\t */\n\tpublic next() {\n\t\tlet currentStep = this.getPrivate(\"currentStep\", 0);\n\t\tthis.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n\t\treturn this.getIndex(currentStep);\n\t}\n\n\t/**\n\t * Resets counter to the start of the list, so the next call for `next()` will\n\t * return the first color.\n\t */\n\tpublic reset() {\n\t\tthis.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}