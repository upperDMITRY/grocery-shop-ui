{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { TextFormatter } from \"./TextFormatter\";\nimport * as $object from \"./Object\";\nimport * as $utils from \"./Utils\";\nimport * as $type from \"./Type\";\n/**\r\n * Number formatter\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\r\n * @important\r\n */\n\nvar NumberFormatter =\n/** @class */\nfunction (_super) {\n  __extends(NumberFormatter, _super);\n\n  function NumberFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(NumberFormatter.prototype, \"_setDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      // Defaults\n      this._setDefault(\"negativeBase\", 0);\n\n      this._setDefault(\"numberFormat\", \"#,###.#####\");\n\n      this._setDefault(\"smallNumberThreshold\", 1.00);\n\n      var bns = \"_big_number_suffix_\";\n      var sns = \"_small_number_suffix_\";\n      var bs = \"_byte_suffix_\";\n\n      this._setDefault(\"bigNumberPrefixes\", [{\n        \"number\": 1e+3,\n        \"suffix\": this._t(bns + \"3\")\n      }, {\n        \"number\": 1e+6,\n        \"suffix\": this._t(bns + \"6\")\n      }, {\n        \"number\": 1e+9,\n        \"suffix\": this._t(bns + \"9\")\n      }, {\n        \"number\": 1e+12,\n        \"suffix\": this._t(bns + \"12\")\n      }, {\n        \"number\": 1e+15,\n        \"suffix\": this._t(bns + \"15\")\n      }, {\n        \"number\": 1e+18,\n        \"suffix\": this._t(bns + \"18\")\n      }, {\n        \"number\": 1e+21,\n        \"suffix\": this._t(bns + \"21\")\n      }, {\n        \"number\": 1e+24,\n        \"suffix\": this._t(bns + \"24\")\n      }]);\n\n      this._setDefault(\"smallNumberPrefixes\", [{\n        \"number\": 1e-24,\n        \"suffix\": this._t(sns + \"24\")\n      }, {\n        \"number\": 1e-21,\n        \"suffix\": this._t(sns + \"21\")\n      }, {\n        \"number\": 1e-18,\n        \"suffix\": this._t(sns + \"18\")\n      }, {\n        \"number\": 1e-15,\n        \"suffix\": this._t(sns + \"15\")\n      }, {\n        \"number\": 1e-12,\n        \"suffix\": this._t(sns + \"12\")\n      }, {\n        \"number\": 1e-9,\n        \"suffix\": this._t(sns + \"9\")\n      }, {\n        \"number\": 1e-6,\n        \"suffix\": this._t(sns + \"6\")\n      }, {\n        \"number\": 1e-3,\n        \"suffix\": this._t(sns + \"3\")\n      }]);\n\n      this._setDefault(\"bytePrefixes\", [{\n        \"number\": 1,\n        suffix: this._t(bs + \"B\")\n      }, {\n        \"number\": 1024,\n        suffix: this._t(bs + \"KB\")\n      }, {\n        \"number\": 1048576,\n        suffix: this._t(bs + \"MB\")\n      }, {\n        \"number\": 1073741824,\n        suffix: this._t(bs + \"GB\")\n      }, {\n        \"number\": 1099511627776,\n        suffix: this._t(bs + \"TB\")\n      }, {\n        \"number\": 1125899906842624,\n        suffix: this._t(bs + \"PB\")\n      }]);\n\n      _super.prototype._setDefaults.call(this);\n    }\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value() {\n      _super.prototype._beforeChanged.call(this);\n    }\n  });\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"format\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(_value, format, precision) {\n      // no format passed in or \"Number\"\n      if (format == null || $type.isString(format) && format.toLowerCase() === \"number\") {\n        format = this.get(\"numberFormat\", \"\");\n      } // Init return value\n\n\n      var formatted; // Cast to number just in case\n      // TODO: maybe use better casting\n\n      var source = Number(_value); // Is it a built-in format or Intl.NumberFormatOptions\n\n      if ($type.isObject(format)) {\n        try {\n          if (this.get(\"intlLocales\")) {\n            return new Intl.NumberFormat(this.get(\"intlLocales\"), format).format(source);\n          } else {\n            return new Intl.NumberFormat(undefined, format).format(source);\n          }\n        } catch (e) {\n          return \"Invalid\";\n        }\n      } else {\n        // Clean format\n        format = $utils.cleanFormat(format); // Get format info (it will also deal with parser caching)\n\n        var info = this.parseFormat(format, this._root.language); // format and replace the number\n\n        var details = void 0;\n\n        if (source > this.get(\"negativeBase\")) {\n          details = info.positive;\n        } else if (source < this.get(\"negativeBase\")) {\n          details = info.negative;\n        } else {\n          details = info.zero;\n        } // Adjust precision\n\n\n        if (precision != null && !details.mod) {\n          details = $object.copy(details);\n          details.decimals.active = source == 0 ? 0 : precision;\n        } // Format\n\n\n        formatted = details.template.split($type.PLACEHOLDER).join(this.applyFormat(source, details));\n      }\n\n      return formatted;\n    }\n  });\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. \"#,###.00\"\r\n   * @param language Language\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"parseFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(format, language) {\n      // Check cache\n      // TODO\n      // let cached = this.getCache(format);\n      // if (cached != null) {\n      // \treturn cached;\n      // }\n      var _this = this;\n\n      var thousandSeparator = language.translateEmpty(\"_thousandSeparator\");\n      var decimalSeparator = language.translateEmpty(\"_decimalSeparator\"); // init format parse info holder\n\n      var info = {\n        \"positive\": {\n          \"thousands\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"interval\": -1,\n            \"separator\": thousandSeparator\n          },\n          \"decimals\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"separator\": decimalSeparator\n          },\n          \"template\": \"\",\n          \"source\": \"\",\n          \"parsed\": false\n        },\n        \"negative\": {\n          \"thousands\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"interval\": -1,\n            \"separator\": thousandSeparator\n          },\n          \"decimals\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"separator\": decimalSeparator\n          },\n          \"template\": \"\",\n          \"source\": \"\",\n          \"parsed\": false\n        },\n        \"zero\": {\n          \"thousands\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"interval\": -1,\n            \"separator\": thousandSeparator\n          },\n          \"decimals\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"separator\": decimalSeparator\n          },\n          \"template\": \"\",\n          \"source\": \"\",\n          \"parsed\": false\n        }\n      }; // Escape double vertical bars (that mean display one vertical bar)\n\n      format = format.replace(\"||\", $type.PLACEHOLDER2); // Split it up and deal with different formats\n\n      var parts = format.split(\"|\");\n      info.positive.source = parts[0];\n\n      if (typeof parts[2] === \"undefined\") {\n        info.zero = info.positive;\n      } else {\n        info.zero.source = parts[2];\n      }\n\n      if (typeof parts[1] === \"undefined\") {\n        info.negative = info.positive;\n      } else {\n        info.negative.source = parts[1];\n      } // Parse each\n\n\n      $object.each(info, function (_part, item) {\n        // Already parsed\n        if (item.parsed) {\n          return;\n        } // Check cached\n        // TODO\n        // if (typeof this.getCache(item.source) !== \"undefined\") {\n        // \tinfo[part] = this.getCache(item.source);\n        // \treturn;\n        // }\n        // Begin parsing\n\n\n        var partFormat = item.source; // Just \"Number\"?\n\n        if (partFormat.toLowerCase() === \"number\") {\n          partFormat = _this.get(\"numberFormat\", \"#,###.#####\");\n        } // Let TextFormatter split into chunks\n\n\n        var chunks = TextFormatter.chunk(partFormat, true);\n\n        for (var i = 0; i < chunks.length; i++) {\n          var chunk = chunks[i]; // replace back double vertical bar\n\n          chunk.text = chunk.text.replace($type.PLACEHOLDER2, \"|\");\n\n          if (chunk.type === \"value\") {\n            // Parse format\n            // Look for codes\n            var matches = chunk.text.match(/[#0.,]+[ ]?[abesABES%!]?[abesABES‰!]?/);\n\n            if (matches) {\n              if (matches === null || matches[0] === \"\") {\n                // no codes here - assume string\n                // nothing to do here\n                item.template += chunk.text;\n              } else {\n                // look for the format modifiers at the end\n                var mods = matches[0].match(/[abesABES%‰!]{2}|[abesABES%‰]{1}$/);\n\n                if (mods) {\n                  item.mod = mods[0].toLowerCase();\n                  item.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰!]{1}$/) ? true : false;\n                } // break the format up\n\n\n                var a = matches[0].split(\".\"); // Deal with thousands\n\n                if (a[0] === \"\") {// No directives for thousands\n                  // Leave default settings (no formatting)\n                } else {\n                  // Counts\n                  item.thousands.active = (a[0].match(/0/g) || []).length;\n                  item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active; // Separator interval\n\n                  var b = a[0].split(\",\");\n\n                  if (b.length === 1) {// No thousands separators\n                    // Do nothing\n                  } else {\n                    // Use length fo the last chunk as thousands length\n                    item.thousands.interval = (b.pop() || \"\").length;\n\n                    if (item.thousands.interval === 0) {\n                      item.thousands.interval = -1;\n                    }\n                  }\n                } // Deal with decimals\n\n\n                if (typeof a[1] === \"undefined\") {// No directives for decimals\n                  // Leave at defaults (no formatting)\n                } else {\n                  // Counts\n                  item.decimals.active = (a[1].match(/0/g) || []).length;\n                  item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n                } // Add special code to template\n\n\n                item.template += chunk.text.split(matches[0]).join($type.PLACEHOLDER);\n              }\n            }\n          } else {\n            // Quoted string - take it as it is\n            item.template += chunk.text;\n          }\n        } // Apply style formatting\n        //item.template = getTextFormatter().format(item.template, this.outputFormat);\n        // Save cache\n        // TODO\n        //this.setCache(item.source, item);\n        // Mark this as parsed\n\n\n        item.parsed = true;\n      }); // Save cache (the whole thing)\n      // TODO\n      //this.setCache(format, info);\n\n      return info;\n    }\n  });\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"applyFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(_value2, details) {\n      // Use absolute values\n      var negative = _value2 < 0;\n      _value2 = Math.abs(_value2); // Recalculate according to modifier\n\n      var prefix = \"\",\n          suffix = \"\";\n      var mods = details.mod ? details.mod.split(\"\") : [];\n\n      if (mods.indexOf(\"b\") !== -1) {\n        var a_1 = this.applyPrefix(_value2, this.get(\"bytePrefixes\"), mods.indexOf(\"!\") !== -1);\n        _value2 = a_1[0];\n        prefix = a_1[1];\n        suffix = a_1[2];\n\n        if (details.modSpacing) {\n          suffix = \" \" + suffix;\n        }\n      } else if (mods.indexOf(\"a\") !== -1) {\n        var a_2 = this.applyPrefix(_value2, _value2 < this.get(\"smallNumberThreshold\") ? this.get(\"smallNumberPrefixes\") : this.get(\"bigNumberPrefixes\"), mods.indexOf(\"!\") !== -1);\n        _value2 = a_2[0];\n        prefix = a_2[1];\n        suffix = a_2[2];\n\n        if (details.modSpacing) {\n          suffix = \" \" + suffix;\n        }\n      } else if (mods.indexOf(\"%\") !== -1) {\n        var ol = Math.min(_value2.toString().length + 2, 21);\n        _value2 *= 100;\n        _value2 = parseFloat(_value2.toPrecision(ol));\n        suffix = \"%\";\n      } else if (mods.indexOf(\"‰\") !== -1) {\n        var ol = Math.min(_value2.toString().length + 3, 21);\n        _value2 *= 1000;\n        _value2 = parseFloat(_value2.toPrecision(ol));\n        suffix = \"‰\";\n      } // Round to passive\n\n\n      if (mods.indexOf(\"e\") !== -1) {\n        // convert the value to exponential\n        var exp = void 0;\n\n        if (details.decimals.passive >= 0) {\n          exp = _value2.toExponential(details.decimals.passive).split(\"e\");\n        } else {\n          exp = _value2.toExponential().split(\"e\");\n        }\n\n        _value2 = Number(exp[0]);\n        suffix = \"e\" + exp[1];\n\n        if (details.modSpacing) {\n          suffix = \" \" + suffix;\n        }\n      } else if (details.decimals.passive === 0) {\n        _value2 = Math.round(_value2);\n      } else if (details.decimals.passive > 0) {\n        var d = Math.pow(10, details.decimals.passive);\n        _value2 = Math.round(_value2 * d) / d;\n      } // Init return value\n\n\n      var res = \"\"; // Calc integer and decimal parts\n\n      var a = $type.numberToString(_value2).split(\".\"); // Format integers\n\n      var ints = a[0]; // Pad integers to active length\n\n      if (ints.length < details.thousands.active) {\n        ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n      } // Insert thousands separators\n\n\n      if (details.thousands.interval > 0) {\n        var ip = [];\n        var intsr = ints.split(\"\").reverse().join(\"\");\n\n        for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n          var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\n          if (c !== \"\") {\n            ip.unshift(c);\n          }\n        }\n\n        ints = ip.join(details.thousands.separator);\n      } // Add integers\n\n\n      res += ints; // Add decimals\n\n      if (a.length === 1) {\n        a.push(\"\");\n      }\n\n      var decs = a[1]; // Fill zeros?\n\n      if (decs.length < details.decimals.active) {\n        decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n      }\n\n      if (decs !== \"\") {\n        res += details.decimals.separator + decs;\n      } // Can't have empty return value\n\n\n      if (res === \"\") {\n        res = \"0\";\n      } // Add minus sign back\n\n\n      if (_value2 !== 0 && negative && mods.indexOf(\"s\") === -1) {\n        res = \"-\" + res;\n      } // Add suffixes/prefixes\n\n\n      if (prefix) {\n        res = prefix + res;\n      }\n\n      if (suffix) {\n        res += suffix;\n      }\n\n      return res;\n    }\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"applyPrefix\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(_value3, prefixes, force) {\n      if (force === void 0) {\n        force = false;\n      }\n\n      var newvalue = _value3;\n      var prefix = \"\";\n      var suffix = \"\";\n      var applied = false;\n      var k = 1;\n\n      for (var i = 0, len = prefixes.length; i < len; i++) {\n        if (prefixes[i].number <= _value3) {\n          if (prefixes[i].number === 0) {\n            newvalue = 0;\n          } else {\n            newvalue = _value3 / prefixes[i].number;\n            k = prefixes[i].number;\n          }\n\n          prefix = prefixes[i].prefix;\n          suffix = prefixes[i].suffix;\n          applied = true;\n        }\n      }\n\n      if (!applied && force && prefixes.length && _value3 != 0) {\n        // Prefix was not applied. Use the first prefix.\n        newvalue = _value3 / prefixes[0].number;\n        prefix = prefixes[0].prefix;\n        suffix = prefixes[0].suffix;\n        applied = true;\n      }\n\n      if (applied) {\n        newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)));\n      }\n\n      return [newvalue, prefix, suffix];\n    }\n  });\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"escape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text) {\n      return text.replace(\"||\", $type.PLACEHOLDER2);\n    }\n  });\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"unescape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text) {\n      return text.replace($type.PLACEHOLDER2, \"|\");\n    }\n  });\n  return NumberFormatter;\n}(Entity);\n\nexport { NumberFormatter };","map":{"version":3,"sources":["../../../../../src/.internal/core/util/NumberFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Language } from \"./Language\";\n\nimport { Entity, IEntitySettings, IEntityPrivate } from \"./Entity\"\nimport { TextFormatter } from \"./TextFormatter\";\n\nimport * as $object from \"./Object\";\nimport * as $utils from \"./Utils\";\nimport * as $type from \"./Type\";\n\n/**\n * @ignore\n */\nexport interface INumberSuffix {\n\tnumber: number;\n\tsuffix: string;\n}\n\nexport interface INumberFormatterSettings extends IEntitySettings {\n\n\t/**\n\t * Number format to be used when formatting numbers.\n\t *\n\t * @default \"#,###.#####\"\n\t */\n\tnumberFormat?: string | Intl.NumberFormatOptions;\n\n\t/**\n\t * A threshold value for negative numbers.\n\t *\n\t * @default 0\n\t */\n\tnegativeBase?: number;\n\n\t/**\n\t * Prefixes and thresholds to group big numbers into, e.g. 1M.\n\t *\n\t * Used in conjunction with `a` modifier of the number format.\n\t */\n\tbigNumberPrefixes?: INumberSuffix[];\n\n\t/**\n\t * Prefixes and thresholds to group small numbers into, e.g. 1m.\n\t *\n\t * Used in conjunction with `a` modifier of the number format.\n\t */\n\tsmallNumberPrefixes?: INumberSuffix[];\n\n\t/**\n\t * All numbers below this value are considered small.\n\t *\n\t * @default 1\n\t */\n\tsmallNumberThreshold?: number;\n\n\t/**\n\t * Prefixes to and thresholds to use when grouping data size numbers, e.g. 1MB.\n\t *\n\t * Used in conjunction with `b` modifier of the number format.\n\t */\n\tbytePrefixes?: INumberSuffix[];\n\n\t/**\n\t * Indicates which fields in data should be considered numeric.\n\t *\n\t * It is used when formatting data placeholder values.\n\t */\n\tnumericFields?: string[];\n\n\t/**\n\t * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\n\t *\n\t * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\n\t * @param value Locales\n\t */\n\tintlLocales?: string;\n\n}\n\nexport interface INumberFormatterPrivate extends IEntityPrivate {\n}\n\n/**\n * Number formatter\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\n * @important\n */\nexport class NumberFormatter extends Entity {\n\tdeclare public _settings: INumberFormatterSettings;\n\tdeclare public _privateSettings: INumberFormatterPrivate;\n\n\tprotected _setDefaults() {\n\t\t// Defaults\n\t\tthis._setDefault(\"negativeBase\", 0);\n\t\tthis._setDefault(\"numberFormat\", \"#,###.#####\");\n\t\tthis._setDefault(\"smallNumberThreshold\", 1.00);\n\n\t\tconst bns = \"_big_number_suffix_\";\n\t\tconst sns = \"_small_number_suffix_\";\n\t\tconst bs = \"_byte_suffix_\";\n\n\t\tthis._setDefault(\"bigNumberPrefixes\", [\n\t\t\t{ \"number\": 1e+3, \"suffix\": this._t(bns + \"3\") },\n\t\t\t{ \"number\": 1e+6, \"suffix\": this._t(bns + \"6\") },\n\t\t\t{ \"number\": 1e+9, \"suffix\": this._t(bns + \"9\") },\n\t\t\t{ \"number\": 1e+12, \"suffix\": this._t(bns + \"12\") },\n\t\t\t{ \"number\": 1e+15, \"suffix\": this._t(bns + \"15\") },\n\t\t\t{ \"number\": 1e+18, \"suffix\": this._t(bns + \"18\") },\n\t\t\t{ \"number\": 1e+21, \"suffix\": this._t(bns + \"21\") },\n\t\t\t{ \"number\": 1e+24, \"suffix\": this._t(bns + \"24\") }\n\t\t]);\n\n\t\tthis._setDefault(\"smallNumberPrefixes\", [\n\t\t\t{ \"number\": 1e-24, \"suffix\": this._t(sns + \"24\") },\n\t\t\t{ \"number\": 1e-21, \"suffix\": this._t(sns + \"21\") },\n\t\t\t{ \"number\": 1e-18, \"suffix\": this._t(sns + \"18\") },\n\t\t\t{ \"number\": 1e-15, \"suffix\": this._t(sns + \"15\") },\n\t\t\t{ \"number\": 1e-12, \"suffix\": this._t(sns + \"12\") },\n\t\t\t{ \"number\": 1e-9, \"suffix\": this._t(sns + \"9\") },\n\t\t\t{ \"number\": 1e-6, \"suffix\": this._t(sns + \"6\") },\n\t\t\t{ \"number\": 1e-3, \"suffix\": this._t(sns + \"3\") }\n\t\t]);\n\n\t\tthis._setDefault(\"bytePrefixes\", [\n\t\t\t{ \"number\": 1, suffix: this._t(bs + \"B\") },\n\t\t\t{ \"number\": 1024, suffix: this._t(bs + \"KB\") },\n\t\t\t{ \"number\": 1048576, suffix: this._t(bs + \"MB\") },\n\t\t\t{ \"number\": 1073741824, suffix: this._t(bs + \"GB\") },\n\t\t\t{ \"number\": 1099511627776, suffix: this._t(bs + \"TB\") },\n\t\t\t{ \"number\": 1125899906842624, suffix: this._t(bs + \"PB\") }\n\t\t]);\n\n\t\tsuper._setDefaults();\n\t}\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\t}\n\n\t/**\n\t * Formats the number according to specific format.\n\t *\n\t * @param value   Value to format\n\t * @param format  Format to apply\n\t * @return Formatted number\n\t */\n\tpublic format(value: number | string, format?: string | Intl.NumberFormatOptions, precision?: number): string {\n\n\t\t// no format passed in or \"Number\"\n\t\tif (format == null || ($type.isString(format) && format.toLowerCase() === \"number\")) {\n\t\t\tformat = this.get(\"numberFormat\", \"\");\n\t\t}\n\n\t\t// Init return value\n\t\tlet formatted;\n\n\t\t// Cast to number just in case\n\t\t// TODO: maybe use better casting\n\t\tlet source: number = Number(value);\n\n\t\t// Is it a built-in format or Intl.NumberFormatOptions\n\t\tif ($type.isObject(format)) {\n\t\t\ttry {\n\t\t\t\tif (this.get(\"intlLocales\")) {\n\t\t\t\t\treturn new Intl.NumberFormat(this.get(\"intlLocales\"), <Intl.NumberFormatOptions>format).format(source);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Intl.NumberFormat(undefined, <Intl.NumberFormatOptions>format).format(source);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\treturn \"Invalid\";\n\t\t\t}\n\n\t\t}\n\t\telse {\n\n\t\t\t// Clean format\n\t\t\tformat = $utils.cleanFormat(format!);\n\n\t\t\t// Get format info (it will also deal with parser caching)\n\t\t\tlet info = this.parseFormat(format, this._root.language);\n\n\n\t\t\t// format and replace the number\n\t\t\tlet details;\n\t\t\tif (source > this.get(\"negativeBase\")) {\n\t\t\t\tdetails = info.positive;\n\t\t\t}\n\t\t\telse if (source < this.get(\"negativeBase\")) {\n\t\t\t\tdetails = info.negative;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdetails = info.zero;\n\t\t\t}\n\n\t\t\t// Adjust precision\n\t\t\tif (precision != null && !details.mod) {\n\t\t\t\tdetails = $object.copy(details);\n\t\t\t\tdetails.decimals.active = source == 0 ? 0 : precision;\n\t\t\t}\n\n\t\t\t// Format\n\t\t\tformatted = details.template.split($type.PLACEHOLDER).join(this.applyFormat(source, details));\n\n\t\t}\n\n\t\treturn formatted;\n\t}\n\n\t/**\n\t * Parses supplied format into structured object which can be used to format\n\t * the number.\n\t *\n\t * @param format Format string, i.e. \"#,###.00\"\n\t * @param language Language\n\t * @ignore\n\t */\n\tprotected parseFormat(format: string, language: Language): any {\n\n\t\t// Check cache\n\t\t// TODO\n\t\t// let cached = this.getCache(format);\n\t\t// if (cached != null) {\n\t\t// \treturn cached;\n\t\t// }\n\n\t\tconst thousandSeparator = language.translateEmpty(\"_thousandSeparator\");\n\t\tconst decimalSeparator = language.translateEmpty(\"_decimalSeparator\")\n\n\t\t// init format parse info holder\n\t\tlet info: any = {\n\t\t\t\"positive\": {\n\t\t\t\t\"thousands\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"interval\": -1,\n\t\t\t\t\t\"separator\": thousandSeparator\n\t\t\t\t},\n\t\t\t\t\"decimals\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"separator\": decimalSeparator\n\t\t\t\t},\n\t\t\t\t\"template\": \"\",\n\t\t\t\t\"source\": \"\",\n\t\t\t\t\"parsed\": false\n\t\t\t},\n\t\t\t\"negative\": {\n\t\t\t\t\"thousands\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"interval\": -1,\n\t\t\t\t\t\"separator\": thousandSeparator\n\t\t\t\t},\n\t\t\t\t\"decimals\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"separator\": decimalSeparator\n\t\t\t\t},\n\t\t\t\t\"template\": \"\",\n\t\t\t\t\"source\": \"\",\n\t\t\t\t\"parsed\": false\n\t\t\t},\n\t\t\t\"zero\": {\n\t\t\t\t\"thousands\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"interval\": -1,\n\t\t\t\t\t\"separator\": thousandSeparator\n\t\t\t\t},\n\t\t\t\t\"decimals\": {\n\t\t\t\t\t\"active\": -1,\n\t\t\t\t\t\"passive\": -1,\n\t\t\t\t\t\"separator\": decimalSeparator\n\t\t\t\t},\n\t\t\t\t\"template\": \"\",\n\t\t\t\t\"source\": \"\",\n\t\t\t\t\"parsed\": false\n\t\t\t}\n\t\t};\n\n\t\t// Escape double vertical bars (that mean display one vertical bar)\n\t\tformat = format.replace(\"||\", $type.PLACEHOLDER2);\n\n\t\t// Split it up and deal with different formats\n\t\tlet parts = format.split(\"|\");\n\t\tinfo.positive.source = parts[0];\n\n\t\tif (typeof parts[2] === \"undefined\") {\n\t\t\tinfo.zero = info.positive;\n\t\t}\n\t\telse {\n\t\t\tinfo.zero.source = parts[2];\n\t\t}\n\n\t\tif (typeof parts[1] === \"undefined\") {\n\t\t\tinfo.negative = info.positive;\n\t\t}\n\t\telse {\n\t\t\tinfo.negative.source = parts[1];\n\t\t}\n\n\t\t// Parse each\n\t\t$object.each(info, (_part, item) => {\n\t\t\t// Already parsed\n\t\t\tif (item.parsed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check cached\n\t\t\t// TODO\n\t\t\t// if (typeof this.getCache(item.source) !== \"undefined\") {\n\t\t\t// \tinfo[part] = this.getCache(item.source);\n\t\t\t// \treturn;\n\t\t\t// }\n\n\t\t\t// Begin parsing\n\t\t\tlet partFormat = item.source;\n\n\t\t\t// Just \"Number\"?\n\t\t\tif (partFormat.toLowerCase() === \"number\") {\n\t\t\t\tpartFormat = this.get(\"numberFormat\", \"#,###.#####\");\n\t\t\t}\n\n\t\t\t// Let TextFormatter split into chunks\n\t\t\tlet chunks = TextFormatter.chunk(partFormat, true);\n\t\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\t\tlet chunk = chunks[i];\n\n\t\t\t\t// replace back double vertical bar\n\t\t\t\tchunk.text = chunk.text.replace($type.PLACEHOLDER2, \"|\");\n\n\t\t\t\tif (chunk.type === \"value\") {\n\t\t\t\t\t// Parse format\n\n\t\t\t\t\t// Look for codes\n\t\t\t\t\tlet matches: string[] | null = chunk.text.match(/[#0.,]+[ ]?[abesABES%!]?[abesABES‰!]?/);\n\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tif (matches === null || matches[0] === \"\") {\n\t\t\t\t\t\t\t// no codes here - assume string\n\t\t\t\t\t\t\t// nothing to do here\n\t\t\t\t\t\t\titem.template += chunk.text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\t// look for the format modifiers at the end\n\t\t\t\t\t\t\tlet mods: string[] | null = matches[0].match(/[abesABES%‰!]{2}|[abesABES%‰]{1}$/);\n\n\t\t\t\t\t\t\tif (mods) {\n\t\t\t\t\t\t\t\titem.mod = mods[0].toLowerCase();\n\t\t\t\t\t\t\t\titem.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰!]{1}$/) ? true : false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// break the format up\n\t\t\t\t\t\t\tlet a = matches[0].split(\".\");\n\n\t\t\t\t\t\t\t// Deal with thousands\n\t\t\t\t\t\t\tif (a[0] === \"\") {\n\t\t\t\t\t\t\t\t// No directives for thousands\n\t\t\t\t\t\t\t\t// Leave default settings (no formatting)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Counts\n\t\t\t\t\t\t\t\titem.thousands.active = (a[0].match(/0/g) || []).length;\n\t\t\t\t\t\t\t\titem.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\n\n\t\t\t\t\t\t\t\t// Separator interval\n\t\t\t\t\t\t\t\tlet b = a[0].split(\",\");\n\t\t\t\t\t\t\t\tif (b.length === 1) {\n\t\t\t\t\t\t\t\t\t// No thousands separators\n\t\t\t\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// Use length fo the last chunk as thousands length\n\t\t\t\t\t\t\t\t\titem.thousands.interval = (b.pop() || \"\").length;\n\n\t\t\t\t\t\t\t\t\tif (item.thousands.interval === 0) {\n\t\t\t\t\t\t\t\t\t\titem.thousands.interval = -1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Deal with decimals\n\t\t\t\t\t\t\tif (typeof (a[1]) === \"undefined\") {\n\t\t\t\t\t\t\t\t// No directives for decimals\n\t\t\t\t\t\t\t\t// Leave at defaults (no formatting)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// Counts\n\t\t\t\t\t\t\t\titem.decimals.active = (a[1].match(/0/g) || []).length;\n\t\t\t\t\t\t\t\titem.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add special code to template\n\t\t\t\t\t\t\titem.template += chunk.text.split(matches[0]).join($type.PLACEHOLDER);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Quoted string - take it as it is\n\t\t\t\t\titem.template += chunk.text;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply style formatting\n\t\t\t//item.template = getTextFormatter().format(item.template, this.outputFormat);\n\n\t\t\t// Save cache\n\t\t\t// TODO\n\t\t\t//this.setCache(item.source, item);\n\n\t\t\t// Mark this as parsed\n\t\t\titem.parsed = true;\n\n\t\t});\n\n\t\t// Save cache (the whole thing)\n\t\t// TODO\n\t\t//this.setCache(format, info);\n\n\t\treturn info;\n\t}\n\n\t/**\n\t * Applies parsed format to a numeric value.\n\t *\n\t * @param value    Value\n\t * @param details  Parsed format as returned by parseFormat()\n\t * @return Formatted number\n\t * @ignore\n\t */\n\tprotected applyFormat(value: number, details: any): string {\n\n\t\t// Use absolute values\n\t\tlet negative: boolean = value < 0;\n\t\tvalue = Math.abs(value);\n\n\t\t// Recalculate according to modifier\n\t\tlet prefix: string = \"\", suffix: string = \"\";\n\t\tlet mods: string[] = details.mod ? details.mod.split(\"\") : [];\n\t\tif (mods.indexOf(\"b\") !== -1) {\n\t\t\tlet a = this.applyPrefix(value, this.get(\"bytePrefixes\")!, mods.indexOf(\"!\") !== -1);\n\t\t\tvalue = a[0];\n\t\t\tprefix = a[1];\n\t\t\tsuffix = a[2];\n\t\t\tif (details.modSpacing) {\n\t\t\t\tsuffix = \" \" + suffix;\n\t\t\t}\n\t\t}\n\t\telse if (mods.indexOf(\"a\") !== -1) {\n\t\t\tlet a = this.applyPrefix(value, value < this.get(\"smallNumberThreshold\")! ? this.get(\"smallNumberPrefixes\")! : this.get(\"bigNumberPrefixes\")!, mods.indexOf(\"!\") !== -1);\n\t\t\tvalue = a[0];\n\t\t\tprefix = a[1];\n\t\t\tsuffix = a[2];\n\t\t\tif (details.modSpacing) {\n\t\t\t\tsuffix = \" \" + suffix;\n\t\t\t}\n\t\t}\n\t\telse if (mods.indexOf(\"%\") !== -1) {\n\t\t\tlet ol = Math.min(value.toString().length + 2, 21);\n\t\t\tvalue *= 100;\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\n\t\t\tsuffix = \"%\";\n\t\t}\n\t\telse if (mods.indexOf(\"‰\") !== -1) {\n\t\t\tlet ol = Math.min(value.toString().length + 3, 21);\n\t\t\tvalue *= 1000;\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\n\t\t\tsuffix = \"‰\";\n\t\t}\n\n\t\t// Round to passive\n\t\tif (mods.indexOf(\"e\") !== -1) {\n\t\t\t// convert the value to exponential\n\t\t\tlet exp: string[];\n\t\t\tif (details.decimals.passive >= 0) {\n\t\t\t\texp = value.toExponential(details.decimals.passive).split(\"e\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\texp = value.toExponential().split(\"e\");\n\t\t\t}\n\t\t\tvalue = Number(exp[0]);\n\t\t\tsuffix = \"e\" + exp[1];\n\t\t\tif (details.modSpacing) {\n\t\t\t\tsuffix = \" \" + suffix;\n\t\t\t}\n\t\t}\n\t\telse if (details.decimals.passive === 0) {\n\t\t\tvalue = Math.round(value);\n\t\t}\n\t\telse if (details.decimals.passive > 0) {\n\t\t\tlet d: number = Math.pow(10, details.decimals.passive);\n\t\t\tvalue = Math.round(value * d) / d;\n\t\t}\n\n\t\t// Init return value\n\t\tlet res: string = \"\";\n\n\t\t// Calc integer and decimal parts\n\t\tlet a = $type.numberToString(value).split(\".\");\n\n\t\t// Format integers\n\t\tlet ints = a[0];\n\n\t\t// Pad integers to active length\n\t\tif (ints.length < details.thousands.active) {\n\t\t\tints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n\t\t}\n\n\t\t// Insert thousands separators\n\t\tif (details.thousands.interval > 0) {\n\t\t\tlet ip: string[] = [];\n\t\t\tlet intsr: string = ints.split(\"\").reverse().join(\"\");\n\t\t\tfor (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n\t\t\t\tlet c: string = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\t\t\t\tif (c !== \"\") {\n\t\t\t\t\tip.unshift(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tints = ip.join(details.thousands.separator);\n\t\t}\n\n\t\t// Add integers\n\t\tres += ints;\n\n\t\t// Add decimals\n\t\tif (a.length === 1) {\n\t\t\ta.push(\"\");\n\t\t}\n\t\tlet decs: string = a[1];\n\n\t\t// Fill zeros?\n\t\tif (decs.length < details.decimals.active) {\n\t\t\tdecs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n\t\t}\n\n\t\tif (decs !== \"\") {\n\t\t\tres += details.decimals.separator + decs;\n\t\t}\n\n\t\t// Can't have empty return value\n\t\tif (res === \"\") {\n\t\t\tres = \"0\";\n\t\t}\n\n\t\t// Add minus sign back\n\t\tif (value !== 0 && negative && (mods.indexOf(\"s\") === -1)) {\n\t\t\tres = \"-\" + res;\n\t\t}\n\n\t\t// Add suffixes/prefixes\n\t\tif (prefix) {\n\t\t\tres = prefix + res;\n\t\t}\n\t\tif (suffix) {\n\t\t\tres += suffix;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\n\tprotected applyPrefix(value: number, prefixes: any[], force: boolean = false): any[] {\n\t\tlet newvalue = value;\n\t\tlet prefix = \"\";\n\t\tlet suffix = \"\";\n\t\tlet applied = false;\n\t\tlet k = 1;\n\n\t\tfor (let i = 0, len = prefixes.length; i < len; i++) {\n\t\t\tif (prefixes[i].number <= value) {\n\t\t\t\tif (prefixes[i].number === 0) {\n\t\t\t\t\tnewvalue = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewvalue = value / prefixes[i].number;\n\t\t\t\t\tk = prefixes[i].number;\n\t\t\t\t}\n\t\t\t\tprefix = prefixes[i].prefix;\n\t\t\t\tsuffix = prefixes[i].suffix;\n\t\t\t\tapplied = true;\n\t\t\t}\n\t\t}\n\n\n\t\tif (!applied && force && prefixes.length && value != 0) {\n\t\t\t// Prefix was not applied. Use the first prefix.\n\t\t\tnewvalue = value / prefixes[0].number;\n\t\t\tprefix = prefixes[0].prefix;\n\t\t\tsuffix = prefixes[0].suffix;\n\t\t\tapplied = true;\n\t\t}\n\n\t\tif (applied) {\n\t\t\tnewvalue = parseFloat(\n\t\t\t\tnewvalue.toPrecision(\n\t\t\t\t\tMath.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn [newvalue, prefix, suffix];\n\t}\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic escape(text: string): string {\n\t\treturn text.replace(\"||\", $type.PLACEHOLDER2);\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic unescape(text: string): string {\n\t\treturn text.replace($type.PLACEHOLDER2, \"|\");\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}