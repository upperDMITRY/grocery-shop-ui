{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { CategoryAxis } from \"./CategoryAxis\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Category-based date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\r\n * @important\r\n */\nvar CategoryDateAxis = /** @class */function (_super) {\n  __extends(CategoryDateAxis, _super);\n  function CategoryDateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_itemMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n  Object.defineProperty(CategoryDateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.fields.push(\"category\");\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      // temp\n      this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n      var renderer = this.get(\"renderer\");\n      var len = this.dataItems.length;\n      var startIndex = this.startIndex();\n      if (startIndex > 0) {\n        startIndex--;\n      }\n      var endIndex = this.endIndex();\n      if (endIndex < len) {\n        endIndex++;\n      }\n      var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n      var frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n      startIndex = Math.floor(startIndex / frequency) * frequency;\n      this._frequency = frequency;\n      for (var j = 0; j < len; j++) {\n        this.dataItems[j].hide();\n      }\n      var startTime = Number(this.dataItems[startIndex].get(\"category\"));\n      var endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n      var realDuration = endTime - startTime - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\n      // if all items are on axis\n      var gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n      var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n        gridInterval = __assign({}, baseInterval);\n      }\n      var formats = this.get(\"dateFormats\");\n      var previousValue = -Infinity;\n      var previousIndex = -Infinity;\n      var previousUnitValue = -Infinity;\n      var format;\n      var selectedItems = [];\n      var changed = false;\n      for (var i = startIndex; i < endIndex; i++) {\n        var dataItem = this.dataItems[i];\n        var index = dataItem.get(\"index\");\n        var skip = false;\n        var value = Number(dataItem.get(\"category\"));\n        var date = new Date(value);\n        var unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n        format = formats[gridInterval.timeUnit];\n        var added = false;\n        if (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n              format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n              if (index - frequency * 0.5 < previousIndex) {\n                selectedItems.pop();\n              }\n              selectedItems.push({\n                format: format,\n                dataItem: dataItem\n              });\n              changed = true;\n              added = true;\n              previousIndex = index;\n              previousUnitValue = unitValue;\n            }\n          }\n        }\n        var shouldAdd = false;\n        if (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n          if (index - previousIndex >= frequency) {\n            shouldAdd = true;\n          }\n        } else {\n          if (unitValue % gridInterval.count === 0) {\n            if (unitValue != previousUnitValue) {\n              shouldAdd = true;\n            }\n          }\n        }\n        if (!added && shouldAdd) {\n          if (index - frequency * 0.7 < previousIndex) {\n            if (changed) {\n              skip = true;\n            }\n          }\n          if (!skip) {\n            selectedItems.push({\n              format: format,\n              dataItem: dataItem\n            });\n            previousIndex = index;\n            previousUnitValue = unitValue;\n          }\n          changed = false;\n        }\n        previousValue = value;\n      }\n      if (selectedItems.length > 0) {\n        var f_1 = selectedItems[0].dataItem.get(\"index\", 0);\n        $array.each(selectedItems, function (item) {\n          var dataItem = item.dataItem;\n          var format = item.format;\n          _this._createAssets(dataItem, []);\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n          var value = Number(dataItem.get(\"category\"));\n          var date = new Date(value);\n          var label = dataItem.get(\"label\");\n          if (label) {\n            label.set(\"text\", _this._root.dateFormatter.format(date, format));\n          }\n          f_1++;\n          _this._prepareDataItem(dataItem, f_1, frequency);\n        });\n      }\n    }\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n  Object.defineProperty(CategoryDateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  Object.defineProperty(CategoryDateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      var dataItem = this.dataItems[this.axisPositionToIndex(position)];\n      if (dataItem) {\n        var format = this.get(\"dateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n        return this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n      }\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_updateTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (tooltip, position) {\n      tooltip.label.set(\"text\", this.getTooltipText(position));\n    }\n  });\n  Object.defineProperty(CategoryDateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"CategoryDateAxis\"\n  });\n  Object.defineProperty(CategoryDateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: CategoryAxis.classNames.concat([CategoryDateAxis.className])\n  });\n  return CategoryDateAxis;\n}(CategoryAxis);\nexport { CategoryDateAxis };","map":{"version":3,"names":["CategoryAxis","$time","$type","$array","$utils","CategoryDateAxis","_super","__extends","_this","apply","arguments","Object","defineProperty","value","_settings","themeTags","mergeTags","fields","push","prototype","_afterNew","call","setPrivateRaw","get","renderer","len","dataItems","length","startIndex","endIndex","maxCount","axisLength","Math","max","Number","MAX_SAFE_INTEGER","frequency","min","ceil","floor","_frequency","j","hide","startTime","endTime","realDuration","baseDuration","gridInterval","chooseInterval","nextGridUnit","getNextUnit","timeUnit","baseInterval","getPrivate","getIntervalDuration","__assign","formats","previousValue","Infinity","previousIndex","previousUnitValue","format","selectedItems","changed","i","dataItem","index","skip","date","Date","unitValue","getUnitValue","added","isNumber","checkChange","_root","utc","pop","shouldAdd","count","f_1","each","item","_createAssets","isHidden","show","label","set","dateFormatter","_prepareDataItem","position","axisPositionToIndex","tooltip","getTooltipText","classNames","concat","className"],"sources":["../../../../../../src/.internal/charts/xy/axes/CategoryDateAxis.ts"],"sourcesContent":["import type { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport { CategoryAxis, ICategoryAxisSettings, ICategoryAxisPrivate, ICategoryAxisDataItem, ICategoryAxisEvents } from \"./CategoryAxis\";\nimport type { ITimeInterval } from \"../../../core/util/Time\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport type { Tooltip } from \"../../../core/render/Tooltip\";\n\nexport interface ICategoryDateAxisSettings<R extends AxisRenderer> extends ICategoryAxisSettings<R> {\n\n\t/**\n\t * Indicates granularity of data.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Data_granularity} for more info\n\t */\n\tbaseInterval: ITimeInterval;\n\n\t/**\n\t * A list of intervals the axis is allowed to show grid/labels on.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Grid_granularity} for more info\n\t */\n\tgridIntervals?: Array<ITimeInterval>;\n\n\t/**\n\t * Display \"period change\" labels using different format.\n\t *\n\t * If set to `true`, will use `periodChangeDateFormats` instead\n\t * of `dateFormats` for such labels, e.g. for month start.\n\t *\n\t * @default true\n\t */\n\tmarkUnitChange?: boolean;\n\n\t/**\n\t * Date formats used for intermediate labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tdateFormats?: { [index: string]: string };\n\n\t/**\n\t * Date formats used for \"period change\" labels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/#Date_formats} for more info\n\t */\n\tperiodChangeDateFormats?: { [index: string]: string };\n\n\t/**\n\t * A date format to use for axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\n\t */\n\ttooltipDateFormat?: string;\n\n}\n\nexport interface ICategoryDateAxisDataItem extends ICategoryAxisDataItem {\n}\n\nexport interface ICategoryDateAxisPrivate extends ICategoryAxisPrivate {\n\n\t/**\n\t * Current base interval.\n\t */\n\tbaseInterval: ITimeInterval;\n\n}\n\nexport interface ICategoryDateAxisEvents extends ICategoryAxisEvents {\n}\n\n\n/**\n * Category-based date axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\n * @important\n */\nexport class CategoryDateAxis<R extends AxisRenderer> extends CategoryAxis<R> {\n\tpublic static className: string = \"CategoryDateAxis\";\n\tpublic static classNames: Array<string> = CategoryAxis.classNames.concat([CategoryDateAxis.className]);\n\n\tdeclare public _settings: ICategoryDateAxisSettings<R>;\n\tdeclare public _privateSettings: ICategoryDateAxisPrivate;\n\tdeclare public _dataItemSettings: ICategoryDateAxisDataItem;\n\tdeclare public _events: ICategoryDateAxisEvents;\n\n\tprotected _frequency: number = 1;\n\n\tprotected _itemMap: { [index: string]: DataItem<ICategoryDateAxisDataItem> } = {};\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.fields.push(\"category\");\n\t\tsuper._afterNew();\n\t}\n\n\n\tprotected _prepareAxisItems() {\n\t\t// temp\n\t\tthis.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n\n\t\tconst renderer = this.get(\"renderer\");\n\t\tconst len = this.dataItems.length;\n\n\t\tlet startIndex = this.startIndex();\n\t\tif (startIndex > 0) {\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tlet endIndex = this.endIndex();\n\t\tif (endIndex < len) {\n\t\t\tendIndex++;\n\t\t}\n\n\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1 / Number.MAX_SAFE_INTEGER);\n\n\t\tlet frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\n\t\tthis._frequency = frequency;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tthis.dataItems[j].hide();\n\t\t}\n\n\t\tlet startTime = Number(this.dataItems[startIndex].get(\"category\"));\n\t\tlet endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n\n\t\tlet realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\n\n\t\t// if all items are on axis\n\t\tlet gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\")!);\n\t\tconst nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n\t\tconst baseInterval = this.getPrivate(\"baseInterval\");\n\n\t\tif ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n\t\t\tgridInterval = { ...baseInterval };\n\t\t}\n\n\t\tconst formats = this.get(\"dateFormats\")!;\n\n\t\tlet previousValue = -Infinity;\n\t\tlet previousIndex = -Infinity;\n\t\tlet previousUnitValue = -Infinity;\n\t\tlet format: string;\n\n\t\tlet selectedItems: Array<{ format: string, dataItem: DataItem<ICategoryDateAxisDataItem> }> = [];\n\t\tlet changed = false;\n\n\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\tlet dataItem = this.dataItems[i];\n\t\t\tlet index = dataItem.get(\"index\")!;\n\t\t\tlet skip = false;\n\n\t\t\tlet value = Number(dataItem.get(\"category\"));\n\t\t\tlet date = new Date(value);\n\t\t\tlet unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n\n\t\t\tformat = formats[gridInterval.timeUnit];\n\t\t\tlet added = false;\n\n\t\t\tif (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n\t\t\t\tif (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n\n\t\t\t\t\tif ($time.checkChange(date, new Date(previousValue), nextGridUnit, this._root.utc)) {\n\t\t\t\t\t\tformat = this.get(\"periodChangeDateFormats\")![gridInterval.timeUnit];\n\n\t\t\t\t\t\tif (index - frequency * 0.5 < previousIndex) {\n\t\t\t\t\t\t\tselectedItems.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tselectedItems.push({ format: format, dataItem: dataItem });\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\tpreviousIndex = index;\n\t\t\t\t\t\tpreviousUnitValue = unitValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet shouldAdd = false;\n\t\t\tif (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n\t\t\t\tif (index - previousIndex >= frequency) {\n\t\t\t\t\tshouldAdd = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (unitValue % gridInterval.count === 0) {\n\t\t\t\t\tif (unitValue != previousUnitValue) {\n\t\t\t\t\t\tshouldAdd = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!added && shouldAdd) {\n\t\t\t\tif (index - frequency * 0.7 < previousIndex) {\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skip) {\n\t\t\t\t\tselectedItems.push({ format: format, dataItem: dataItem });\n\t\t\t\t\tpreviousIndex = index;\n\t\t\t\t\tpreviousUnitValue = unitValue;\n\t\t\t\t}\n\t\t\t\tchanged = false;\n\n\t\t\t}\n\n\t\t\tpreviousValue = value;\n\n\t\t}\n\n\t\tif (selectedItems.length > 0) {\n\t\t\tlet f = selectedItems[0].dataItem.get(\"index\", 0);\n\n\t\t\t$array.each(selectedItems, (item) => {\n\t\t\t\tconst dataItem = item.dataItem;\n\t\t\t\tconst format = item.format;\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tlet value = Number(dataItem.get(\"category\"));\n\t\t\t\tlet date = new Date(value);\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._root.dateFormatter.format(date, format!));\n\t\t\t\t}\n\t\t\t\tf++;\n\t\t\t\tthis._prepareDataItem(dataItem, f, frequency);\n\t\t\t})\n\n\t\t}\n\t}\n\n\t/**\n\t * Returns a duration of currently active `baseInterval` in milliseconds.\n\t *\n\t * @return Duration\n\t */\n\tpublic baseDuration(): number {\n\t\treturn $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n\t}\n\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tlet dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\n\t\tif (dataItem) {\n\t\t\tlet format = this.get(\"dateFormats\")![this.getPrivate(\"baseInterval\").timeUnit];\n\t\t\treturn this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n\t\t}\n\t}\n\n\tprotected _updateTooltipText(tooltip: Tooltip, position: number) {\n\t\ttooltip.label.set(\"text\", this.getTooltipText(position));\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}