{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Axis } from \"./Axis\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport { populateString } from \"../../../core/util/PopulateString\";\n/**\r\n * Creates a category axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info\r\n * @important\r\n */\nvar CategoryAxis = /** @class */function (_super) {\n  __extends(CategoryAxis, _super);\n  function CategoryAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_itemMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n  Object.defineProperty(CategoryAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.fields.push(\"category\");\n      this.setPrivateRaw(\"name\", \"category\");\n      this.addTag(\"category\");\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"_prepareChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      _super.prototype._prepareChildren.call(this);\n      var len = this.dataItems.length;\n      var i = 0;\n      if (this._valuesDirty) {\n        $array.each(this.dataItems, function (dataItem) {\n          dataItem.setRaw(\"index\", i);\n          _this._itemMap[dataItem.get(\"category\")] = dataItem;\n          i++;\n        });\n        this.setPrivateRaw(\"maxZoomFactor\", len);\n      }\n      this.setPrivateRaw(\"startIndex\", Math.max(Math.round(this.get(\"start\", 0) * len), 0));\n      this.setPrivateRaw(\"endIndex\", Math.min(Math.round(this.get(\"end\", 1) * len), len));\n      if (this._sizeDirty || this._valuesDirty || this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"endIndex\") || this.isPrivateDirty(\"startIndex\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\")) {\n        if (this.dataItems.length > 0) {\n          this._handleRangeChange();\n          this._prepareAxisItems();\n          this._updateAxisRanges();\n        }\n      }\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      $array.each(this.series, function (series) {\n        var startCategory = _this.dataItems[_this.startIndex()].get(\"category\");\n        var endCategory = _this.dataItems[_this.endIndex() - 1].get(\"category\");\n        var baseAxis = series.get(\"baseAxis\");\n        var xAxis = series.get(\"xAxis\");\n        var yAxis = series.get(\"yAxis\");\n        if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {\n          series._markDirtyAxes();\n        } else if (baseAxis === _this) {\n          var key = void 0;\n          var openKey = void 0;\n          var otherAxis = yAxis;\n          if (xAxis === baseAxis) {\n            if (series.get(\"categoryXField\")) {\n              key = \"categoryX\";\n            }\n            if (series.get(\"openCategoryXField\")) {\n              openKey = \"openCategoryX\";\n            }\n          } else if (yAxis === baseAxis) {\n            if (series.get(\"categoryYField\")) {\n              key = \"categoryY\";\n            }\n            if (series.get(\"openCategoryYField\")) {\n              openKey = \"openCategoryY\";\n            }\n            otherAxis = xAxis;\n          }\n          if (otherAxis.className == \"ValueAxis\") {\n            if (key || openKey) {\n              var startDataItem = void 0;\n              var endDataItem = void 0;\n              for (var i = 0, len = series.dataItems.length; i < len; i++) {\n                var dataItem = series.dataItems[i];\n                if (key) {\n                  if (dataItem.get(key) === startCategory) {\n                    startDataItem = dataItem;\n                    break;\n                  }\n                }\n                if (openKey) {\n                  if (dataItem.get(openKey) === startCategory) {\n                    startDataItem = dataItem;\n                    break;\n                  }\n                }\n              }\n              for (var i = series.dataItems.length - 1; i >= 0; i--) {\n                var dataItem = series.dataItems[i];\n                if (key) {\n                  if (dataItem.get(key) === endCategory) {\n                    endDataItem = dataItem;\n                    break;\n                  }\n                }\n                if (openKey) {\n                  if (dataItem.get(openKey) === endCategory) {\n                    endDataItem = dataItem;\n                    break;\n                  }\n                }\n              }\n              if (startDataItem) {\n                series.setPrivate(\"startIndex\", series.dataItems.indexOf(startDataItem));\n              }\n              if (endDataItem) {\n                series.setPrivate(\"endIndex\", series.dataItems.indexOf(endDataItem) + 1);\n              }\n            }\n          }\n          series._markDirtyAxes(); // must be outside\n        }\n      });\n    }\n  });\n\n  Object.defineProperty(CategoryAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var renderer = this.get(\"renderer\");\n      var len = this.dataItems.length;\n      var startIndex = this.startIndex();\n      if (startIndex > 0) {\n        startIndex--;\n      }\n      var endIndex = this.endIndex();\n      if (endIndex < len) {\n        endIndex++;\n      }\n      var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n      var frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));\n      startIndex = Math.floor(startIndex / frequency) * frequency;\n      this._frequency = frequency;\n      for (var j = 0; j < len; j++) {\n        this.dataItems[j].hide();\n      }\n      var f = this.dataItems[startIndex].get(\"index\", 0);\n      for (var i = startIndex; i < endIndex; i = i + frequency) {\n        var dataItem = this.dataItems[i];\n        this._createAssets(dataItem, []);\n        if (dataItem.isHidden()) {\n          dataItem.show();\n        }\n        this._prepareDataItem(dataItem, f, frequency);\n        f++;\n      }\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"_prepareDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, fillIndex, count) {\n      var renderer = this.get(\"renderer\");\n      var categoryLocation = dataItem.get(\"categoryLocation\", 0);\n      var endCategoryLocation = dataItem.get(\"endCategoryLocation\", 1);\n      var index = dataItem.get(\"index\");\n      if (!$type.isNumber(index)) {\n        index = this.categoryToIndex(dataItem.get(\"category\"));\n      }\n      var position = this.indexToPosition(index, categoryLocation);\n      var endCategory = dataItem.get(\"endCategory\");\n      var endIndex;\n      if (endCategory) {\n        endIndex = this.categoryToIndex(endCategory);\n        if (!$type.isNumber(endIndex)) {\n          endIndex = index;\n        }\n      } else {\n        endIndex = index;\n      }\n      var endPosition = this.indexToPosition(endIndex, endCategoryLocation);\n      var fillEndIndex;\n      var fillEndPosition;\n      if (dataItem.get(\"isRange\")) {\n        fillEndIndex = endIndex;\n      } else {\n        fillEndIndex = index + this._frequency - 1;\n      }\n      fillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);\n      renderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n      renderer.updateGrid(dataItem.get(\"grid\"), position, endPosition);\n      renderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n      renderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n      this._processBullet(dataItem);\n      renderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n      var fillRule = this.get(\"fillRule\");\n      if (fillRule) {\n        fillRule(dataItem, fillIndex);\n      }\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"startIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var len = this.dataItems.length;\n      return Math.min(Math.max(this.getPrivate(\"startIndex\", 0), 0), len - 1);\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"endIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var len = this.dataItems.length;\n      return Math.max(1, Math.min(this.getPrivate(\"endIndex\", len), len));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"baseValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"basePosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return 0;\n    }\n  });\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific category index.\r\n   *\r\n   * @param   value  Index\r\n   * @return         X coordinate\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var axisDataItem = this._itemMap[value];\n      if (axisDataItem) {\n        return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n      }\n      return NaN;\n    }\n  });\n  /**\r\n   * Returns Y coordinate in pixels corresponding to specific category index.\r\n   *\r\n   * @param   value  Index\r\n   * @return         Y coordinate\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var axisDataItem = this._itemMap[value];\n      if (axisDataItem) {\n        return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n      }\n      return NaN;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, _axisLocation) {\n      var category = dataItem.get(field);\n      var axisDataItem = this._itemMap[category];\n      if (axisDataItem) {\n        return this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n      }\n      return NaN;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, _axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, _axisLocation) {\n      var category = dataItem.get(field);\n      var axisDataItem = this._itemMap[category];\n      if (axisDataItem) {\n        return this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n      }\n      return NaN;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, _axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));\n    }\n  });\n  /**\r\n   * Converts category index to a relative position.\r\n   *\r\n   * `location` indicates relative position within category: 0 - start, 1 - end.\r\n   *\r\n   * If not set, will use middle (0.5) of the category.\r\n   *\r\n   * @param   index     Index\r\n   * @param   location  Location\r\n   * @return            Index\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"indexToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index, location) {\n      if (!$type.isNumber(location)) {\n        location = 0.5;\n      }\n      var len = this.dataItems.length;\n      var startLocation = this.get(\"startLocation\", 0);\n      var endLocation = this.get(\"endLocation\", 1);\n      len -= startLocation;\n      len -= 1 - endLocation;\n      var position = (index + location - startLocation) / len;\n      var dataItem = this.dataItems[index];\n      if (dataItem) {\n        position += dataItem.get(\"deltaPosition\", 0);\n      }\n      return position;\n    }\n  });\n  /**\r\n   * Returns an index of a category.\r\n   *\r\n   * @param   category  Category to look up\r\n   * @return            Index\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"categoryToIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (category) {\n      var dataItem = this._itemMap[category];\n      if (dataItem) {\n        return dataItem.get(\"index\");\n      }\n      return NaN;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"dataItemToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      return this.indexToPosition(dataItem.get(\"index\"));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"roundAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position, location) {\n      return this.indexToPosition(this.axisPositionToIndex(position), location);\n    }\n  });\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"axisPositionToIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var len = this.dataItems.length;\n      return $math.fitToRange(Math.floor(position * len), 0, len - 1); //$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      var dataItem = this.dataItems[this.axisPositionToIndex(position)];\n      if (dataItem) {\n        var label = dataItem.get(\"label\");\n        if (label) {\n          return populateString(label, this.get(\"tooltipText\", \"\"));\n        }\n      }\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"_updateTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (tooltip, position) {\n      tooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);\n      tooltip.label.text.markDirtyText();\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series, position) {\n      if (this.dataItems.length > 0) {\n        var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n        var index = this.axisPositionToIndex(position);\n        // try simple first\n        var seriesDataItem = series.dataItems[index];\n        var axisDataItem = this.dataItems[index];\n        var category = axisDataItem.get(\"category\");\n        if (seriesDataItem && axisDataItem) {\n          if (seriesDataItem.get(fieldName) === category) {\n            return seriesDataItem;\n          }\n        }\n        // if not found, try looking\n        for (var i = 0, len = series.dataItems.length; i < len; i++) {\n          var dataItem = series.dataItems[i];\n          if (dataItem.get(fieldName) === category) {\n            return dataItem;\n          }\n        }\n      }\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` indexes.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start index\r\n   * @param  end       End index\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  Object.defineProperty(CategoryAxis.prototype, \"zoomToIndexes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration) {\n      var len = this.dataItems.length;\n      this.zoom(start / len, end / len, duration);\n    }\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"zoomToCategories\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (startCategory, endCategory, duration) {\n      this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);\n    }\n  });\n  Object.defineProperty(CategoryAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"CategoryAxis\"\n  });\n  Object.defineProperty(CategoryAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Axis.classNames.concat([CategoryAxis.className])\n  });\n  return CategoryAxis;\n}(Axis);\nexport { CategoryAxis };","map":{"version":3,"names":["Axis","$array","$type","$math","$utils","populateString","CategoryAxis","_super","__extends","_this","apply","arguments","Object","defineProperty","value","_settings","themeTags","mergeTags","fields","push","setPrivateRaw","addTag","prototype","_afterNew","call","_prepareChildren","len","dataItems","length","i","_valuesDirty","each","dataItem","setRaw","_itemMap","get","Math","max","round","min","_sizeDirty","isDirty","isPrivateDirty","_handleRangeChange","_prepareAxisItems","_updateAxisRanges","series","startCategory","startIndex","endCategory","endIndex","baseAxis","xAxis","yAxis","_markDirtyAxes","key","openKey","otherAxis","className","startDataItem","endDataItem","setPrivate","indexOf","renderer","maxCount","axisLength","Number","MAX_SAFE_INTEGER","frequency","ceil","floor","_frequency","j","hide","f","_createAssets","isHidden","show","_prepareDataItem","_updateGhost","fillIndex","count","categoryLocation","endCategoryLocation","index","isNumber","categoryToIndex","position","indexToPosition","endPosition","fillEndIndex","fillEndPosition","updateLabel","updateGrid","updateTick","updateFill","_processBullet","updateBullet","fillRule","getPrivate","axisDataItem","positionToCoordinate","NaN","field","cellLocation","_axisLocation","category","getDataItemPositionX","getDataItemPositionY","location","startLocation","endLocation","axisPositionToIndex","fitToRange","label","tooltip","_setDataItem","text","markDirtyText","fieldName","seriesDataItem","start","end","duration","zoom","zoomToIndexes","classNames","concat"],"sources":["../../../../../../src/.internal/charts/xy/axes/CategoryAxis.ts"],"sourcesContent":["import type { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport { Axis, IAxisSettings, IAxisPrivate, IAxisDataItem, IAxisEvents } from \"./Axis\";\nimport type { IXYSeriesDataItem, XYSeries } from \"../series/XYSeries\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport { populateString } from \"../../../core/util/PopulateString\";\nimport type { Tooltip } from \"../../../core/render/Tooltip\";\n\nexport interface ICategoryAxisSettings<R extends AxisRenderer> extends IAxisSettings<R> {\n\n\t/**\n\t * A function that can be used to specify how to configure axis fills.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_fills} for more info\n\t */\n\tfillRule?: (dataItem: DataItem<ICategoryAxisDataItem>, index?: number) => void;\n\n\t/**\n\t * A field in data which holds categories.\n\t */\n\tcategoryField: string;\n\n\t/**\n\t * Relative location of where axis cell starts: 0 - beginning, 1 - end.\n\t *\n\t * @default 0\n\t */\n\tstartLocation?: number;\n\n\t/**\n\t * Relative location of where axis cell ends: 0 - beginning, 1 - end.\n\t *\n\t * @default 1\n\t */\n\tendLocation?: number;\n}\n\nexport interface ICategoryAxisDataItem extends IAxisDataItem {\n\n\t/**\n\t * Named category.\n\t */\n\tcategory?: string;\n\n\t/**\n\t * Named end category (for axis items that span multiple categories, like\n\t * axis ranges).\n\t */\n\tendCategory?: string;\n\n\t/**\n\t * Index of the data item.\n\t */\n\tindex?: number;\n\n\t/**\n\t * Relative location of the category within cell: 0 - start, 1 - end.\n\t */\n\tcategoryLocation?: number;\n\n\t/**\n\t * Relative location of the end category within cell: 0 - start, 1 - end.\n\t */\n\tendCategoryLocation?: number;\n\n\t/**\n\t * A distance to shift data item relative to its original position.\n\t *\n\t * The value is 0 to 1, where 1 is full witdth of the axis.\n\t *\n\t * Can be used to sort data items without modifying order of the actual data.\n\t */\n\tdeltaPosition?: number;\n\n}\n\nexport interface ICategoryAxisPrivate extends IAxisPrivate {\n\n\t/**\n\t * Start index of the current zoom scope.\n\t */\n\tstartIndex?: number;\n\n\t/**\n\t * End index of the current zoom scope.\n\t */\n\tendIndex?: number;\n\n}\n\nexport interface ICategoryAxisEvents extends IAxisEvents {\n\n}\n\n/**\n * Creates a category axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info\n * @important\n */\nexport class CategoryAxis<R extends AxisRenderer> extends Axis<R> {\n\tpublic static className: string = \"CategoryAxis\";\n\tpublic static classNames: Array<string> = Axis.classNames.concat([CategoryAxis.className]);\n\n\tdeclare public _settings: ICategoryAxisSettings<R>;\n\tdeclare public _privateSettings: ICategoryAxisPrivate;\n\tdeclare public _dataItemSettings: ICategoryAxisDataItem;\n\tdeclare public _events: ICategoryAxisEvents;\n\n\tprotected _frequency: number = 1;\n\n\tprotected _itemMap: { [index: string]: DataItem<ICategoryAxisDataItem> } = {};\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.fields.push(\"category\");\n\t\tthis.setPrivateRaw(\"name\", \"category\");\n\t\tthis.addTag(\"category\");\n\t\tsuper._afterNew();\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tconst len = this.dataItems.length;\n\t\tlet i = 0;\n\t\tif (this._valuesDirty) {\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tdataItem.setRaw(\"index\", i);\n\t\t\t\tthis._itemMap[dataItem.get(\"category\") as string] = dataItem;\n\t\t\t\ti++;\n\t\t\t})\n\n\t\t\tthis.setPrivateRaw(\"maxZoomFactor\", len);\n\t\t}\n\n\t\tthis.setPrivateRaw(\"startIndex\", Math.max(Math.round(this.get(\"start\", 0) * len), 0));\t\t\n\t\tthis.setPrivateRaw(\"endIndex\", Math.min(Math.round(this.get(\"end\", 1) * len), len));\t\t\n\n\t\tif (this._sizeDirty || this._valuesDirty || (this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"endIndex\") || this.isPrivateDirty(\"startIndex\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\"))) {\n\t\t\tif (this.dataItems.length > 0) {\n\t\t\t\tthis._handleRangeChange();\n\t\t\t\tthis._prepareAxisItems();\n\t\t\t\tthis._updateAxisRanges();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _handleRangeChange() {\n\t\t$array.each(this.series, (series) => {\n\t\t\tlet startCategory = this.dataItems[this.startIndex()].get(\"category\");\n\t\t\tlet endCategory = this.dataItems[this.endIndex() - 1].get(\"category\");\n\n\t\t\tlet baseAxis = series.get(\"baseAxis\");\n\t\t\tlet xAxis = series.get(\"xAxis\");\n\t\t\tlet yAxis = series.get(\"yAxis\");\n\n\t\t\tif (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {\n\t\t\t\tseries._markDirtyAxes();\n\t\t\t}\n\t\t\telse if (baseAxis === this) {\n\t\t\t\tlet key: string | undefined;\n\t\t\t\tlet openKey: string | undefined;\n\t\t\t\tlet otherAxis = yAxis;\n\t\t\t\tif (xAxis === baseAxis) {\n\t\t\t\t\tif (series.get(\"categoryXField\")) {\n\t\t\t\t\t\tkey = \"categoryX\";\n\t\t\t\t\t}\n\t\t\t\t\tif (series.get(\"openCategoryXField\")) {\n\t\t\t\t\t\topenKey = \"openCategoryX\";\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (yAxis === baseAxis) {\n\t\t\t\t\tif (series.get(\"categoryYField\")) {\n\t\t\t\t\t\tkey = \"categoryY\";\n\t\t\t\t\t}\n\t\t\t\t\tif (series.get(\"openCategoryYField\")) {\n\t\t\t\t\t\topenKey = \"openCategoryY\";\n\t\t\t\t\t}\n\t\t\t\t\totherAxis = xAxis;\n\t\t\t\t}\n\n\t\t\t\tif (otherAxis.className == \"ValueAxis\") {\n\n\t\t\t\t\tif (key || openKey) {\n\t\t\t\t\t\tlet startDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\t\t\t\t\t\tlet endDataItem: DataItem<IXYSeriesDataItem> | undefined;\n\n\t\t\t\t\t\tfor (let i = 0, len = series.dataItems.length; i < len; i++) {\n\t\t\t\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\t\t\t\tif (key) {\n\t\t\t\t\t\t\t\tif (dataItem.get(key as any) === startCategory) {\n\t\t\t\t\t\t\t\t\tstartDataItem = dataItem;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (openKey) {\n\t\t\t\t\t\t\t\tif (dataItem.get(openKey as any) === startCategory) {\n\t\t\t\t\t\t\t\t\tstartDataItem = dataItem;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\t\t\t\tif (key) {\n\t\t\t\t\t\t\t\tif (dataItem.get(key as any) === endCategory) {\n\t\t\t\t\t\t\t\t\tendDataItem = dataItem;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (openKey) {\n\t\t\t\t\t\t\t\tif (dataItem.get(openKey as any) === endCategory) {\n\t\t\t\t\t\t\t\t\tendDataItem = dataItem;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (startDataItem) {\n\t\t\t\t\t\t\tseries.setPrivate(\"startIndex\", series.dataItems.indexOf(startDataItem));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (endDataItem) {\n\t\t\t\t\t\t\tseries.setPrivate(\"endIndex\", series.dataItems.indexOf(endDataItem) + 1);\n\t\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseries._markDirtyAxes();\t// must be outside\n\t\t\t}\n\t\t})\n\t}\n\n\n\tprotected _prepareAxisItems() {\n\t\tconst renderer = this.get(\"renderer\");\n\t\tconst len = this.dataItems.length;\n\n\t\tlet startIndex = this.startIndex();\n\t\tif (startIndex > 0) {\n\t\t\tstartIndex--;\n\t\t}\n\n\t\tlet endIndex = this.endIndex();\n\t\tif (endIndex < len) {\n\t\t\tendIndex++;\n\t\t}\n\n\t\tlet maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\")!, 1 / Number.MAX_SAFE_INTEGER);\n\n\t\tlet frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));\n\t\tstartIndex = Math.floor(startIndex / frequency) * frequency;\n\t\tthis._frequency = frequency;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tthis.dataItems[j].hide();\n\t\t}\n\n\t\tlet f = this.dataItems[startIndex].get(\"index\", 0);\n\n\t\tfor (let i = startIndex; i < endIndex; i = i + frequency) {\n\t\t\tlet dataItem = this.dataItems[i];\n\n\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\tif (dataItem.isHidden()) {\n\t\t\t\tdataItem.show();\n\t\t\t}\n\n\t\t\tthis._prepareDataItem(dataItem, f, frequency);\n\t\t\tf++;\n\t\t}\n\n\t\tthis._updateGhost();\n\t}\n\n\n\tpublic _prepareDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, fillIndex?: number, count?: number) {\n\t\tlet renderer = this.get(\"renderer\");\n\n\t\tlet categoryLocation = dataItem.get(\"categoryLocation\", 0);\n\t\tlet endCategoryLocation = dataItem.get(\"endCategoryLocation\", 1);\n\n\t\tlet index: number | undefined = dataItem.get(\"index\");\n\n\t\tif (!$type.isNumber(index)) {\n\t\t\tindex = this.categoryToIndex(dataItem.get(\"category\")!);\n\t\t}\n\n\t\tlet position = this.indexToPosition(index, categoryLocation);\n\n\t\tlet endCategory = dataItem.get(\"endCategory\")!;\n\t\tlet endIndex: number;\n\t\tif (endCategory) {\n\t\t\tendIndex = this.categoryToIndex(endCategory);\n\t\t\tif (!$type.isNumber(endIndex)) {\n\t\t\t\tendIndex = index;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tendIndex = index;\n\t\t}\n\n\t\tlet endPosition = this.indexToPosition(endIndex, endCategoryLocation);\n\n\t\tlet fillEndIndex: number;\n\t\tlet fillEndPosition: number;\n\n\t\tif (dataItem.get(\"isRange\")) {\n\t\t\tfillEndIndex = endIndex;\n\t\t}\n\t\telse {\n\t\t\tfillEndIndex = index + this._frequency - 1;\n\t\t}\n\n\t\tfillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);\n\n\t\trenderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n\t\trenderer.updateGrid(dataItem.get(\"grid\"), position, endPosition);\n\t\trenderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n\t\trenderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n\n\t\tthis._processBullet(dataItem);\n\t\trenderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n\n\t\tconst fillRule = this.get(\"fillRule\");\n\t\tif (fillRule) {\n\t\t\tfillRule(dataItem, fillIndex)\n\t\t}\n\t}\n\n\tpublic startIndex() {\n\t\tlet len = this.dataItems.length;\n\t\treturn Math.min(Math.max(this.getPrivate(\"startIndex\", 0), 0), len - 1);\n\t}\n\n\tpublic endIndex() {\n\t\tlet len = this.dataItems.length;\n\t\treturn Math.max(1, Math.min(this.getPrivate(\"endIndex\", len), len));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic baseValue(): any {\n\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic basePosition() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific category index.\n\t *\n\t * @param   value  Index\n\t * @return         X coordinate\n\t */\n\tpublic getX(value: string): number {\n\t\tlet axisDataItem = this._itemMap[value];\n\t\tif (axisDataItem) {\n\t\t\treturn this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * Returns Y coordinate in pixels corresponding to specific category index.\n\t *\n\t * @param   value  Index\n\t * @return         Y coordinate\n\t */\n\tpublic getY(value: string): number {\n\t\tlet axisDataItem = this._itemMap[value];\n\t\tif (axisDataItem) {\n\t\t\treturn this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get(\"index\", 0)));\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\tconst category = dataItem.get(field as any);\n\t\tconst axisDataItem = this._itemMap[category];\n\n\t\tif (axisDataItem) {\n\t\t\treturn this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\tconst category = dataItem.get(field as any);\n\t\tconst axisDataItem = this._itemMap[category];\n\t\tif (axisDataItem) {\n\t\t\treturn this.indexToPosition(axisDataItem.get(\"index\", 0), cellLocation);\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, cellLocation: number, _axisLocation?: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));\n\t}\n\n\t/**\n\t * Converts category index to a relative position.\n\t *\n\t * `location` indicates relative position within category: 0 - start, 1 - end.\n\t *\n\t * If not set, will use middle (0.5) of the category.\n\t *\n\t * @param   index     Index\n\t * @param   location  Location\n\t * @return            Index\n\t */\n\tpublic indexToPosition(index: number, location?: number): number {\n\t\tif (!$type.isNumber(location)) {\n\t\t\tlocation = 0.5;\n\t\t}\n\n\t\tlet len = this.dataItems.length;\n\n\t\tlet startLocation = this.get(\"startLocation\", 0);\n\t\tlet endLocation = this.get(\"endLocation\", 1);\n\n\t\tlen -= startLocation;\n\t\tlen -= (1 - endLocation);\n\n\t\tlet position = (index + location - startLocation) / len;\n\n\t\tlet dataItem = this.dataItems[index];\n\t\tif (dataItem) {\n\t\t\tposition += dataItem.get(\"deltaPosition\", 0);\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Returns an index of a category.\n\t *\n\t * @param   category  Category to look up\n\t * @return            Index\n\t */\n\tpublic categoryToIndex(category: string): number {\n\t\tlet dataItem = this._itemMap[category];\n\t\tif (dataItem) {\n\t\t\treturn dataItem.get(\"index\")!;\n\t\t}\n\t\treturn NaN;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic dataItemToPosition(dataItem: DataItem<this[\"_dataItemSettings\"]>): number {\n\t\treturn this.indexToPosition(dataItem.get(\"index\")!);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic roundAxisPosition(position: number, location: number): number {\n\t\treturn this.indexToPosition(this.axisPositionToIndex(position), location);\n\t}\n\n\t/**\n\t * Returns an index of the category that corresponds to specific pixel\n\t * position within axis.\n\t *\n\t * @param position  Position (px)\n\t * @return Category index\n\t */\n\tpublic axisPositionToIndex(position: number): number {\n\t\tlet len = this.dataItems.length;\n\t\treturn $math.fitToRange(Math.floor(position * len), 0, len - 1);//$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\t//@todo number formatter + tag\n\t\tconst dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\t\tif (dataItem) {\n\t\t\tconst label = dataItem.get(\"label\")\n\t\t\tif(label){\n\t\t\t\treturn populateString(label, this.get(\"tooltipText\", \"\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _updateTooltipText(tooltip: Tooltip, position: number) {\n\t\ttooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);\n\t\ttooltip.label.text.markDirtyText();\n\t}\t\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tif (this.dataItems.length > 0) {\n\t\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\t\tlet index = this.axisPositionToIndex(position);\n\t\t\t// try simple first\n\t\t\tlet seriesDataItem = series.dataItems[index];\n\t\t\tlet axisDataItem = this.dataItems[index];\n\t\t\tlet category = axisDataItem.get(\"category\");\n\n\t\t\tif (seriesDataItem && axisDataItem) {\n\t\t\t\tif (seriesDataItem.get(fieldName) === category) {\n\t\t\t\t\treturn seriesDataItem;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if not found, try looking\n\t\t\tfor (let i = 0, len = series.dataItems.length; i < len; i++) {\n\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\tif (dataItem.get(fieldName) === category) {\n\t\t\t\t\treturn dataItem;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` indexes.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start index\n\t * @param  end       End index\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToIndexes(start: number, end: number, duration?: number) {\n\t\tlet len = this.dataItems.length;\n\t\tthis.zoom(start / len, end / len, duration);\n\t}\n\n\tpublic zoomToCategories(startCategory: string, endCategory: string, duration?: number) {\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);\n\t}\n}\n"],"mappings":";AAEA,SAASA,IAAI,QAAiE,QAAQ;AAEtF,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,KAAK,MAAM,yBAAyB;AAChD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAClD,SAASC,cAAc,QAAQ,mCAAmC;AAyFlE;;;;;;AAMA,IAAAC,YAAA,0BAAAC,MAAA;EAA0DC,SAAA,CAAAF,YAAA,EAAAC,MAAA;EAA1D,SAAAD,aAAA;IAAA,IAAAG,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IASCC,MAAA,CAAAC,cAAA,CAAAJ,KAAA;;;;aAA+B;;IAE/BG,MAAA,CAAAC,cAAA,CAAAJ,KAAA;;;;aAA2E;;;EAyc5E;;;;;WAvcC,SAAAK,CAAA;MACC,IAAI,CAACC,SAAS,CAACC,SAAS,GAAGZ,MAAM,CAACa,SAAS,CAAC,IAAI,CAACF,SAAS,CAACC,SAAS,EAAE,CAAC,MAAM,CAAC,CAAC;MAC/E,IAAI,CAACE,MAAM,CAACC,IAAI,CAAC,UAAU,CAAC;MAC5B,IAAI,CAACC,aAAa,CAAC,MAAM,EAAE,UAAU,CAAC;MACtC,IAAI,CAACC,MAAM,CAAC,UAAU,CAAC;MACvBd,MAAA,CAAAe,SAAA,CAAMC,SAAS,CAAAC,IAAA,MAAE;IAClB;;;;;;WAEA,SAAAV,CAAA;MAAA,IAAAL,KAAA;MACCF,MAAA,CAAAe,SAAA,CAAMG,gBAAgB,CAAAD,IAAA,MAAE;MAExB,IAAME,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MACjC,IAAIC,CAAC,GAAG,CAAC;MACT,IAAI,IAAI,CAACC,YAAY,EAAE;QACtB7B,MAAM,CAAC8B,IAAI,CAAC,IAAI,CAACJ,SAAS,EAAE,UAACK,QAAQ;UACpCA,QAAQ,CAACC,MAAM,CAAC,OAAO,EAAEJ,CAAC,CAAC;UAC3BpB,KAAI,CAACyB,QAAQ,CAACF,QAAQ,CAACG,GAAG,CAAC,UAAU,CAAW,CAAC,GAAGH,QAAQ;UAC5DH,CAAC,EAAE;QACJ,CAAC,CAAC;QAEF,IAAI,CAACT,aAAa,CAAC,eAAe,EAAEM,GAAG,CAAC;;MAGzC,IAAI,CAACN,aAAa,CAAC,YAAY,EAAEgB,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,KAAK,CAAC,IAAI,CAACH,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,GAAGT,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;MACrF,IAAI,CAACN,aAAa,CAAC,UAAU,EAAEgB,IAAI,CAACG,GAAG,CAACH,IAAI,CAACE,KAAK,CAAC,IAAI,CAACH,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,GAAGT,GAAG,CAAC,EAAEA,GAAG,CAAC,CAAC;MAEnF,IAAI,IAAI,CAACc,UAAU,IAAI,IAAI,CAACV,YAAY,IAAK,IAAI,CAACW,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,CAACA,OAAO,CAAC,KAAK,CAAC,IAAI,IAAI,CAACC,cAAc,CAAC,UAAU,CAAC,IAAI,IAAI,CAACA,cAAc,CAAC,YAAY,CAAC,IAAI,IAAI,CAACA,cAAc,CAAC,OAAO,CAAC,IAAI,IAAI,CAACA,cAAc,CAAC,QAAQ,CAAE,EAAE;QACpO,IAAI,IAAI,CAACf,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;UAC9B,IAAI,CAACe,kBAAkB,EAAE;UACzB,IAAI,CAACC,iBAAiB,EAAE;UACxB,IAAI,CAACC,iBAAiB,EAAE;;;IAG3B;;;;;;WAEA,SAAA/B,CAAA;MAAA,IAAAL,KAAA;MACCR,MAAM,CAAC8B,IAAI,CAAC,IAAI,CAACe,MAAM,EAAE,UAACA,MAAM;QAC/B,IAAIC,aAAa,GAAGtC,KAAI,CAACkB,SAAS,CAAClB,KAAI,CAACuC,UAAU,EAAE,CAAC,CAACb,GAAG,CAAC,UAAU,CAAC;QACrE,IAAIc,WAAW,GAAGxC,KAAI,CAACkB,SAAS,CAAClB,KAAI,CAACyC,QAAQ,EAAE,GAAG,CAAC,CAAC,CAACf,GAAG,CAAC,UAAU,CAAC;QAErE,IAAIgB,QAAQ,GAAGL,MAAM,CAACX,GAAG,CAAC,UAAU,CAAC;QACrC,IAAIiB,KAAK,GAAGN,MAAM,CAACX,GAAG,CAAC,OAAO,CAAC;QAC/B,IAAIkB,KAAK,GAAGP,MAAM,CAACX,GAAG,CAAC,OAAO,CAAC;QAE/B,IAAIiB,KAAK,YAAY9C,YAAY,IAAI+C,KAAK,YAAY/C,YAAY,EAAE;UACnEwC,MAAM,CAACQ,cAAc,EAAE;SACvB,MACI,IAAIH,QAAQ,KAAK1C,KAAI,EAAE;UAC3B,IAAI8C,GAAG,SAAoB;UAC3B,IAAIC,OAAO,SAAoB;UAC/B,IAAIC,SAAS,GAAGJ,KAAK;UACrB,IAAID,KAAK,KAAKD,QAAQ,EAAE;YACvB,IAAIL,MAAM,CAACX,GAAG,CAAC,gBAAgB,CAAC,EAAE;cACjCoB,GAAG,GAAG,WAAW;;YAElB,IAAIT,MAAM,CAACX,GAAG,CAAC,oBAAoB,CAAC,EAAE;cACrCqB,OAAO,GAAG,eAAe;;WAE1B,MACI,IAAIH,KAAK,KAAKF,QAAQ,EAAE;YAC5B,IAAIL,MAAM,CAACX,GAAG,CAAC,gBAAgB,CAAC,EAAE;cACjCoB,GAAG,GAAG,WAAW;;YAElB,IAAIT,MAAM,CAACX,GAAG,CAAC,oBAAoB,CAAC,EAAE;cACrCqB,OAAO,GAAG,eAAe;;YAE1BC,SAAS,GAAGL,KAAK;;UAGlB,IAAIK,SAAS,CAACC,SAAS,IAAI,WAAW,EAAE;YAEvC,IAAIH,GAAG,IAAIC,OAAO,EAAE;cACnB,IAAIG,aAAa,SAAyC;cAC1D,IAAIC,WAAW,SAAyC;cAExD,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEH,GAAG,GAAGoB,MAAM,CAACnB,SAAS,CAACC,MAAM,EAAEC,CAAC,GAAGH,GAAG,EAAEG,CAAC,EAAE,EAAE;gBAC5D,IAAIG,QAAQ,GAAGc,MAAM,CAACnB,SAAS,CAACE,CAAC,CAAC;gBAClC,IAAI0B,GAAG,EAAE;kBACR,IAAIvB,QAAQ,CAACG,GAAG,CAACoB,GAAU,CAAC,KAAKR,aAAa,EAAE;oBAC/CY,aAAa,GAAG3B,QAAQ;oBACxB;;;gBAGF,IAAIwB,OAAO,EAAE;kBACZ,IAAIxB,QAAQ,CAACG,GAAG,CAACqB,OAAc,CAAC,KAAKT,aAAa,EAAE;oBACnDY,aAAa,GAAG3B,QAAQ;oBACxB;;;;cAKH,KAAK,IAAIH,CAAC,GAAGiB,MAAM,CAACnB,SAAS,CAACC,MAAM,GAAG,CAAC,EAAEC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;gBACtD,IAAIG,QAAQ,GAAGc,MAAM,CAACnB,SAAS,CAACE,CAAC,CAAC;gBAClC,IAAI0B,GAAG,EAAE;kBACR,IAAIvB,QAAQ,CAACG,GAAG,CAACoB,GAAU,CAAC,KAAKN,WAAW,EAAE;oBAC7CW,WAAW,GAAG5B,QAAQ;oBACtB;;;gBAGF,IAAIwB,OAAO,EAAE;kBACZ,IAAIxB,QAAQ,CAACG,GAAG,CAACqB,OAAc,CAAC,KAAKP,WAAW,EAAE;oBACjDW,WAAW,GAAG5B,QAAQ;oBACtB;;;;cAKH,IAAI2B,aAAa,EAAE;gBAClBb,MAAM,CAACe,UAAU,CAAC,YAAY,EAAEf,MAAM,CAACnB,SAAS,CAACmC,OAAO,CAACH,aAAa,CAAC,CAAC;;cAGzE,IAAIC,WAAW,EAAE;gBAChBd,MAAM,CAACe,UAAU,CAAC,UAAU,EAAEf,MAAM,CAACnB,SAAS,CAACmC,OAAO,CAACF,WAAW,CAAC,GAAG,CAAC,CAAC;;;;UAI3Ed,MAAM,CAACQ,cAAc,EAAE,CAAC,CAAC;;MAE3B,CAAC,CAAC;IACH;;;;;;;WAGA,SAAAxC,CAAA;MACC,IAAMiD,QAAQ,GAAG,IAAI,CAAC5B,GAAG,CAAC,UAAU,CAAC;MACrC,IAAMT,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MAEjC,IAAIoB,UAAU,GAAG,IAAI,CAACA,UAAU,EAAE;MAClC,IAAIA,UAAU,GAAG,CAAC,EAAE;QACnBA,UAAU,EAAE;;MAGb,IAAIE,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;MAC9B,IAAIA,QAAQ,GAAGxB,GAAG,EAAE;QACnBwB,QAAQ,EAAE;;MAGX,IAAIc,QAAQ,GAAGD,QAAQ,CAACE,UAAU,EAAE,GAAG7B,IAAI,CAACC,GAAG,CAAC0B,QAAQ,CAAC5B,GAAG,CAAC,iBAAiB,CAAE,EAAE,CAAC,GAAG+B,MAAM,CAACC,gBAAgB,CAAC;MAE9G,IAAIC,SAAS,GAAGhC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACG,GAAG,CAACb,GAAG,EAAEU,IAAI,CAACiC,IAAI,CAAC,CAACnB,QAAQ,GAAGF,UAAU,IAAIgB,QAAQ,CAAC,CAAC,CAAC;MACzFhB,UAAU,GAAGZ,IAAI,CAACkC,KAAK,CAACtB,UAAU,GAAGoB,SAAS,CAAC,GAAGA,SAAS;MAC3D,IAAI,CAACG,UAAU,GAAGH,SAAS;MAE3B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9C,GAAG,EAAE8C,CAAC,EAAE,EAAE;QAC7B,IAAI,CAAC7C,SAAS,CAAC6C,CAAC,CAAC,CAACC,IAAI,EAAE;;MAGzB,IAAIC,CAAC,GAAG,IAAI,CAAC/C,SAAS,CAACqB,UAAU,CAAC,CAACb,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;MAElD,KAAK,IAAIN,CAAC,GAAGmB,UAAU,EAAEnB,CAAC,GAAGqB,QAAQ,EAAErB,CAAC,GAAGA,CAAC,GAAGuC,SAAS,EAAE;QACzD,IAAIpC,QAAQ,GAAG,IAAI,CAACL,SAAS,CAACE,CAAC,CAAC;QAEhC,IAAI,CAAC8C,aAAa,CAAC3C,QAAQ,EAAE,EAAE,CAAC;QAEhC,IAAIA,QAAQ,CAAC4C,QAAQ,EAAE,EAAE;UACxB5C,QAAQ,CAAC6C,IAAI,EAAE;;QAGhB,IAAI,CAACC,gBAAgB,CAAC9C,QAAQ,EAAE0C,CAAC,EAAEN,SAAS,CAAC;QAC7CM,CAAC,EAAE;;MAGJ,IAAI,CAACK,YAAY,EAAE;IACpB;;;;;;WAGA,SAAAjE,CAAwBkB,QAA6C,EAAEgD,SAAkB,EAAEC,KAAc;MACxG,IAAIlB,QAAQ,GAAG,IAAI,CAAC5B,GAAG,CAAC,UAAU,CAAC;MAEnC,IAAI+C,gBAAgB,GAAGlD,QAAQ,CAACG,GAAG,CAAC,kBAAkB,EAAE,CAAC,CAAC;MAC1D,IAAIgD,mBAAmB,GAAGnD,QAAQ,CAACG,GAAG,CAAC,qBAAqB,EAAE,CAAC,CAAC;MAEhE,IAAIiD,KAAK,GAAuBpD,QAAQ,CAACG,GAAG,CAAC,OAAO,CAAC;MAErD,IAAI,CAACjC,KAAK,CAACmF,QAAQ,CAACD,KAAK,CAAC,EAAE;QAC3BA,KAAK,GAAG,IAAI,CAACE,eAAe,CAACtD,QAAQ,CAACG,GAAG,CAAC,UAAU,CAAE,CAAC;;MAGxD,IAAIoD,QAAQ,GAAG,IAAI,CAACC,eAAe,CAACJ,KAAK,EAAEF,gBAAgB,CAAC;MAE5D,IAAIjC,WAAW,GAAGjB,QAAQ,CAACG,GAAG,CAAC,aAAa,CAAE;MAC9C,IAAIe,QAAgB;MACpB,IAAID,WAAW,EAAE;QAChBC,QAAQ,GAAG,IAAI,CAACoC,eAAe,CAACrC,WAAW,CAAC;QAC5C,IAAI,CAAC/C,KAAK,CAACmF,QAAQ,CAACnC,QAAQ,CAAC,EAAE;UAC9BA,QAAQ,GAAGkC,KAAK;;OAEjB,MACI;QACJlC,QAAQ,GAAGkC,KAAK;;MAGjB,IAAIK,WAAW,GAAG,IAAI,CAACD,eAAe,CAACtC,QAAQ,EAAEiC,mBAAmB,CAAC;MAErE,IAAIO,YAAoB;MACxB,IAAIC,eAAuB;MAE3B,IAAI3D,QAAQ,CAACG,GAAG,CAAC,SAAS,CAAC,EAAE;QAC5BuD,YAAY,GAAGxC,QAAQ;OACvB,MACI;QACJwC,YAAY,GAAGN,KAAK,GAAG,IAAI,CAACb,UAAU,GAAG,CAAC;;MAG3CoB,eAAe,GAAG,IAAI,CAACH,eAAe,CAACE,YAAY,EAAEP,mBAAmB,CAAC;MAEzEpB,QAAQ,CAAC6B,WAAW,CAAC5D,QAAQ,CAACG,GAAG,CAAC,OAAO,CAAC,EAAEoD,QAAQ,EAAEE,WAAW,EAAER,KAAK,CAAC;MACzElB,QAAQ,CAAC8B,UAAU,CAAC7D,QAAQ,CAACG,GAAG,CAAC,MAAM,CAAC,EAAEoD,QAAQ,EAAEE,WAAW,CAAC;MAChE1B,QAAQ,CAAC+B,UAAU,CAAC9D,QAAQ,CAACG,GAAG,CAAC,MAAM,CAAC,EAAEoD,QAAQ,EAAEE,WAAW,EAAER,KAAK,CAAC;MACvElB,QAAQ,CAACgC,UAAU,CAAC/D,QAAQ,CAACG,GAAG,CAAC,UAAU,CAAC,EAAEoD,QAAQ,EAAEI,eAAe,CAAC;MAExE,IAAI,CAACK,cAAc,CAAChE,QAAQ,CAAC;MAC7B+B,QAAQ,CAACkC,YAAY,CAACjE,QAAQ,CAACG,GAAG,CAAC,QAAQ,CAAC,EAAEoD,QAAQ,EAAEE,WAAW,CAAC;MAEpE,IAAMS,QAAQ,GAAG,IAAI,CAAC/D,GAAG,CAAC,UAAU,CAAC;MACrC,IAAI+D,QAAQ,EAAE;QACbA,QAAQ,CAAClE,QAAQ,EAAEgD,SAAS,CAAC;;IAE/B;;;;;;WAEA,SAAAlE,CAAA;MACC,IAAIY,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MAC/B,OAAOQ,IAAI,CAACG,GAAG,CAACH,IAAI,CAACC,GAAG,CAAC,IAAI,CAAC8D,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEzE,GAAG,GAAG,CAAC,CAAC;IACxE;;;;;;WAEA,SAAAZ,CAAA;MACC,IAAIY,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MAC/B,OAAOQ,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACG,GAAG,CAAC,IAAI,CAAC4D,UAAU,CAAC,UAAU,EAAEzE,GAAG,CAAC,EAAEA,GAAG,CAAC,CAAC;IACpE;;EAEA;;;;;;;WAGA,SAAAZ,CAAA,GAEA;;EAEA;;;;;;;WAGA,SAAAA,CAAA;MACC,OAAO,CAAC;IACT;;EAEA;;;;;;;;;;WAMA,SAAAA,CAAYA,KAAa;MACxB,IAAIsF,YAAY,GAAG,IAAI,CAAClE,QAAQ,CAACpB,KAAK,CAAC;MACvC,IAAIsF,YAAY,EAAE;QACjB,OAAO,IAAI,CAACrF,SAAS,CAACgD,QAAQ,CAACsC,oBAAoB,CAAC,IAAI,CAACb,eAAe,CAACY,YAAY,CAACjE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;;MAExG,OAAOmE,GAAG;IACX;;EAEA;;;;;;;;;;WAMA,SAAAxF,CAAYA,KAAa;MACxB,IAAIsF,YAAY,GAAG,IAAI,CAAClE,QAAQ,CAACpB,KAAK,CAAC;MACvC,IAAIsF,YAAY,EAAE;QACjB,OAAO,IAAI,CAACrF,SAAS,CAACgD,QAAQ,CAACsC,oBAAoB,CAAC,IAAI,CAACb,eAAe,CAACY,YAAY,CAACjE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;;MAExG,OAAOmE,GAAG;IACX;;EAEA;;;;;;;WAGA,SAAAxF,CAA4BkB,QAAqC,EAAEuE,KAAa,EAAEC,YAAoB,EAAEC,aAAsB;MAC7H,IAAMC,QAAQ,GAAG1E,QAAQ,CAACG,GAAG,CAACoE,KAAY,CAAC;MAC3C,IAAMH,YAAY,GAAG,IAAI,CAAClE,QAAQ,CAACwE,QAAQ,CAAC;MAE5C,IAAIN,YAAY,EAAE;QACjB,OAAO,IAAI,CAACZ,eAAe,CAACY,YAAY,CAACjE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,EAAEqE,YAAY,CAAC;;MAExE,OAAOF,GAAG;IACX;;EAEA;;;;;;;WAGA,SAAAxF,CAA8BkB,QAAqC,EAAEuE,KAAa,EAAEC,YAAoB,EAAEC,aAAsB;MAC/H,OAAO,IAAI,CAAC1F,SAAS,CAACgD,QAAQ,CAACsC,oBAAoB,CAAC,IAAI,CAACM,oBAAoB,CAAC3E,QAAQ,EAAEuE,KAAK,EAAEC,YAAY,EAAEC,aAAa,CAAC,CAAC;IAC7H;;EAEA;;;;;;;WAGA,SAAA3F,CAA4BkB,QAAqC,EAAEuE,KAAa,EAAEC,YAAoB,EAAEC,aAAsB;MAC7H,IAAMC,QAAQ,GAAG1E,QAAQ,CAACG,GAAG,CAACoE,KAAY,CAAC;MAC3C,IAAMH,YAAY,GAAG,IAAI,CAAClE,QAAQ,CAACwE,QAAQ,CAAC;MAC5C,IAAIN,YAAY,EAAE;QACjB,OAAO,IAAI,CAACZ,eAAe,CAACY,YAAY,CAACjE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,EAAEqE,YAAY,CAAC;;MAExE,OAAOF,GAAG;IACX;;EAEA;;;;;;;WAGA,SAAAxF,CAA8BkB,QAAqC,EAAEuE,KAAa,EAAEC,YAAoB,EAAEC,aAAsB;MAC/H,OAAO,IAAI,CAAC1F,SAAS,CAACgD,QAAQ,CAACsC,oBAAoB,CAAC,IAAI,CAACO,oBAAoB,CAAC5E,QAAQ,EAAEuE,KAAK,EAAEC,YAAY,EAAEC,aAAa,CAAC,CAAC;IAC7H;;EAEA;;;;;;;;;;;;;;;WAWA,SAAA3F,CAAuBsE,KAAa,EAAEyB,QAAiB;MACtD,IAAI,CAAC3G,KAAK,CAACmF,QAAQ,CAACwB,QAAQ,CAAC,EAAE;QAC9BA,QAAQ,GAAG,GAAG;;MAGf,IAAInF,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MAE/B,IAAIkF,aAAa,GAAG,IAAI,CAAC3E,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;MAChD,IAAI4E,WAAW,GAAG,IAAI,CAAC5E,GAAG,CAAC,aAAa,EAAE,CAAC,CAAC;MAE5CT,GAAG,IAAIoF,aAAa;MACpBpF,GAAG,IAAK,CAAC,GAAGqF,WAAY;MAExB,IAAIxB,QAAQ,GAAG,CAACH,KAAK,GAAGyB,QAAQ,GAAGC,aAAa,IAAIpF,GAAG;MAEvD,IAAIM,QAAQ,GAAG,IAAI,CAACL,SAAS,CAACyD,KAAK,CAAC;MACpC,IAAIpD,QAAQ,EAAE;QACbuD,QAAQ,IAAIvD,QAAQ,CAACG,GAAG,CAAC,eAAe,EAAE,CAAC,CAAC;;MAG7C,OAAOoD,QAAQ;IAChB;;EAEA;;;;;;;;;;WAMA,SAAAzE,CAAuB4F,QAAgB;MACtC,IAAI1E,QAAQ,GAAG,IAAI,CAACE,QAAQ,CAACwE,QAAQ,CAAC;MACtC,IAAI1E,QAAQ,EAAE;QACb,OAAOA,QAAQ,CAACG,GAAG,CAAC,OAAO,CAAE;;MAE9B,OAAOmE,GAAG;IACX;;EAEA;;;;;;;WAGA,SAAAxF,CAA0BkB,QAA6C;MACtE,OAAO,IAAI,CAACwD,eAAe,CAACxD,QAAQ,CAACG,GAAG,CAAC,OAAO,CAAE,CAAC;IACpD;;EAEA;;;;;;;WAGA,SAAArB,CAAyByE,QAAgB,EAAEsB,QAAgB;MAC1D,OAAO,IAAI,CAACrB,eAAe,CAAC,IAAI,CAACwB,mBAAmB,CAACzB,QAAQ,CAAC,EAAEsB,QAAQ,CAAC;IAC1E;;EAEA;;;;;;;;;;;WAOA,SAAA/F,CAA2ByE,QAAgB;MAC1C,IAAI7D,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MAC/B,OAAOzB,KAAK,CAAC8G,UAAU,CAAC7E,IAAI,CAACkC,KAAK,CAACiB,QAAQ,GAAG7D,GAAG,CAAC,EAAE,CAAC,EAAEA,GAAG,GAAG,CAAC,CAAC,CAAC;IACjE;;EAEA;;;;;;;;;;WAMA,SAAAZ,CAAsByE,QAAgB;MACrC;MACA,IAAMvD,QAAQ,GAAG,IAAI,CAACL,SAAS,CAAC,IAAI,CAACqF,mBAAmB,CAACzB,QAAQ,CAAC,CAAC;MACnE,IAAIvD,QAAQ,EAAE;QACb,IAAMkF,KAAK,GAAGlF,QAAQ,CAACG,GAAG,CAAC,OAAO,CAAC;QACnC,IAAG+E,KAAK,EAAC;UACR,OAAO7G,cAAc,CAAC6G,KAAK,EAAE,IAAI,CAAC/E,GAAG,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;;;IAG5D;;;;;;WAEA,SAAArB,CAA6BqG,OAAgB,EAAE5B,QAAgB;MAC9D4B,OAAO,CAACC,YAAY,CAAC,IAAI,CAACzF,SAAS,CAAC,IAAI,CAACqF,mBAAmB,CAACzB,QAAQ,CAAC,CAAC,CAAC;MACxE4B,OAAO,CAACD,KAAK,CAACG,IAAI,CAACC,aAAa,EAAE;IACnC;;EAEA;;;;;;;;;;;WAOA,SAAAxG,CAAqBgC,MAAgB,EAAEyC,QAAgB;MACtD,IAAI,IAAI,CAAC5D,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;QAC9B,IAAI2F,SAAS,GAAS,IAAI,CAACpB,UAAU,CAAC,MAAM,CAAE,GAAG,IAAI,CAAChE,GAAG,CAAC,UAAU,CAAC,CAACgE,UAAU,CAAC,QAAQ,CAAG;QAC5F,IAAIf,KAAK,GAAG,IAAI,CAAC4B,mBAAmB,CAACzB,QAAQ,CAAC;QAC9C;QACA,IAAIiC,cAAc,GAAG1E,MAAM,CAACnB,SAAS,CAACyD,KAAK,CAAC;QAC5C,IAAIgB,YAAY,GAAG,IAAI,CAACzE,SAAS,CAACyD,KAAK,CAAC;QACxC,IAAIsB,QAAQ,GAAGN,YAAY,CAACjE,GAAG,CAAC,UAAU,CAAC;QAE3C,IAAIqF,cAAc,IAAIpB,YAAY,EAAE;UACnC,IAAIoB,cAAc,CAACrF,GAAG,CAACoF,SAAS,CAAC,KAAKb,QAAQ,EAAE;YAC/C,OAAOc,cAAc;;;QAIvB;QACA,KAAK,IAAI3F,CAAC,GAAG,CAAC,EAAEH,GAAG,GAAGoB,MAAM,CAACnB,SAAS,CAACC,MAAM,EAAEC,CAAC,GAAGH,GAAG,EAAEG,CAAC,EAAE,EAAE;UAC5D,IAAIG,QAAQ,GAAGc,MAAM,CAACnB,SAAS,CAACE,CAAC,CAAC;UAClC,IAAIG,QAAQ,CAACG,GAAG,CAACoF,SAAS,CAAC,KAAKb,QAAQ,EAAE;YACzC,OAAO1E,QAAQ;;;;IAInB;;EAEA;;;;;;;;;;;;;WASA,SAAAlB,CAAqB2G,KAAa,EAAEC,GAAW,EAAEC,QAAiB;MACjE,IAAIjG,GAAG,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM;MAC/B,IAAI,CAACgG,IAAI,CAACH,KAAK,GAAG/F,GAAG,EAAEgG,GAAG,GAAGhG,GAAG,EAAEiG,QAAQ,CAAC;IAC5C;;;;;;WAEA,SAAA7G,CAAwBiC,aAAqB,EAAEE,WAAmB,EAAE0E,QAAiB;MACpF,IAAI,CAACE,aAAa,CAAC,IAAI,CAACvC,eAAe,CAACvC,aAAa,CAAC,EAAE,IAAI,CAACuC,eAAe,CAACrC,WAAW,CAAC,GAAG,CAAC,EAAE0E,QAAQ,CAAC;IACzG;;EAldA/G,MAAA,CAAAC,cAAA,CAAAP,YAAA;;;;WAAkC;;EAClCM,MAAA,CAAAC,cAAA,CAAAP,YAAA;;;;WAA0CN,IAAI,CAAC8H,UAAU,CAACC,MAAM,CAAC,CAACzH,YAAY,CAACoD,SAAS,CAAC;;EAkd1F,OAAApD,YAAC;CAAA,CApdyDN,IAAI;SAAjDM,YAAY"},"metadata":{},"sourceType":"module"}