{"ast":null,"code":"/** @ignore */\n\n/** */\nimport * as $math from \"./Math\";\n/**\r\n * @ignore\r\n */\n\nexport function segmentedLine(display, segments) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n\n        for (var g = 0, len_1 = groups.length; g < len_1; g++) {\n          line(display, groups[g]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function line(display, points) {\n  for (var p = 0, len = points.length; p < len; p++) {\n    var point = points[p];\n    display.lineTo(point.x, point.y);\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function moveTo(display, point) {\n  display.moveTo(point.x, point.y);\n}\n/**\r\n * @ignore\r\n */\n\nexport function clear(display) {\n  display.clear();\n}\n/**\r\n * @ignore\r\n */\n\nexport function smoothedSegmentedline(display, segments, tensionX, tensionY) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n\n        for (var g = 0, len_2 = groups.length; g < len_2; g++) {\n          var points = groups[g];\n\n          if (points.length > 0) {\n            display.lineTo(points[0].x, points[0].y);\n          }\n\n          smoothedLine(display, points, tensionX, tensionY);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function smoothedLine(display, points, tensionX, tensionY) {\n  for (var i = points.length - 1; i > 0; i--) {\n    var p0 = points[i];\n    var p1 = points[i - 1];\n\n    if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n      points.splice(i - 1, 1);\n    }\n  }\n\n  if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n    line(display, points);\n    return;\n  }\n\n  tensionX = 1 - tensionX + 0.00001;\n  tensionY = 1 - tensionY + 0.00001;\n  var first = points[0];\n  var last = points[points.length - 1];\n  var closed = false;\n\n  if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n    closed = true;\n  } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n  var path = \"\";\n\n  for (var i = 0, len = points.length - 1; i < len; i++) {\n    var p0 = points[i - 1];\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n\n    if (i === 0) {\n      if (closed) {\n        p0 = points[len - 2];\n      } else {\n        p0 = points[0];\n      }\n    } else if (i == len - 1) {\n      if (closed) {\n        p3 = points[1];\n      } else {\n        p3 = p2;\n      }\n    }\n\n    var controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n    var controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n    display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n  }\n\n  return path;\n}","map":{"version":3,"sources":["../../../../../src/.internal/core/util/Draw.ts"],"names":[],"mappings":"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","sourcesContent":["/** @ignore *//** */\n\nimport type { IPoint } from \"./IPoint\"\nimport * as $math from \"./Math\";\nimport type { IGraphics } from \"../render/backend/Renderer\";\n\n/**\n * @ignore\n */\nexport function segmentedLine(display: IGraphics, segments: Array<Array<Array<IPoint>>>) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tline(display, groups[g]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function line(display: IGraphics, points: Array<IPoint>) {\n\tfor (let p = 0, len = points.length; p < len; p++) {\n\t\tconst point = points[p];\n\t\tdisplay.lineTo(point.x, point.y);\n\t}\n}\n\n/**\n * @ignore\n */\nexport function moveTo(display: IGraphics, point: IPoint) {\n\tdisplay.moveTo(point.x, point.y);\n}\n\n/**\n * @ignore\n */\nexport function clear(display: IGraphics) {\n\tdisplay.clear();\n}\n\n/**\n * @ignore\n */\nexport function smoothedSegmentedline(display: IGraphics, segments: Array<Array<Array<IPoint>>>, tensionX: number, tensionY: number) {\n\tfor (let s = 0, len = segments.length; s < len; s++) {\n\t\tconst groups = segments[s];\n\t\tif (groups.length > 0) {\n\t\t\tlet firstGroup = groups[0];\n\t\t\tif (firstGroup.length > 0) {\n\t\t\t\tlet firstPoint = firstGroup[0];\n\t\t\t\tdisplay.moveTo(firstPoint.x, firstPoint.y);\n\t\t\t\tfor (let g = 0, len = groups.length; g < len; g++) {\n\t\t\t\t\tconst points = groups[g];\n\t\t\t\t\tif (points.length > 0) {\n\t\t\t\t\t\tdisplay.lineTo(points[0].x, points[0].y)\n\t\t\t\t\t}\n\t\t\t\t\tsmoothedLine(display, points, tensionX, tensionY);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @ignore\n */\nexport function smoothedLine(display: IGraphics, points: Array<IPoint>, tensionX: number, tensionY: number) {\n\n\tfor (let i = points.length - 1; i > 0; i--) {\n\t\tlet p0 = points[i];\n\t\tlet p1 = points[i - 1];\n\n\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\tpoints.splice(i - 1, 1);\n\t\t}\n\t}\n\n\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\tline(display, points);\n\t\treturn;\n\t}\n\n\ttensionX = 1 - tensionX + 0.00001;\n\ttensionY = 1 - tensionY + 0.00001;\n\n\tlet first = points[0];\n\tlet last = points[points.length - 1];\n\n\tlet closed: boolean = false;\n\n\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\tclosed = true;\n\t}\n\n\t// Can't moveTo here, as it wont be possible to have fill then.\n\tlet path: string = \"\";\n\n\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\tlet p0: IPoint = points[i - 1];\n\n\t\tlet p1: IPoint = points[i];\n\n\t\tlet p2: IPoint = points[i + 1];\n\n\t\tlet p3: IPoint = points[i + 2];\n\n\t\tif (i === 0) {\n\t\t\tif (closed) {\n\t\t\t\tp0 = points[len - 2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp0 = points[0];\n\t\t\t}\n\t\t} else if (i == len - 1) {\n\t\t\tif (closed) {\n\t\t\t\tp3 = points[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp3 = p2;\n\t\t\t}\n\t\t}\n\n\n\t\tlet controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n\t\tlet controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n\n\t\tdisplay.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n\t}\n\n\treturn path;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}