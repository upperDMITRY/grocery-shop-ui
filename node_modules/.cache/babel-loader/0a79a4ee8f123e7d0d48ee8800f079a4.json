{"ast":null,"code":"import { isNumber } from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\n\nexport function round(value, precision, floor) {\n  if (!isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\n\nexport function ceil(value, precision) {\n  if (!isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\nexport function fitToRange(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Returns sine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function sin(angle) {\n  return Math.sin(RADIANS * angle);\n}\n/**\r\n * Returns tan of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function tan(angle) {\n  return Math.tan(RADIANS * angle);\n}\n/**\r\n * Returns cosine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\n\nexport function cos(angle) {\n  return Math.cos(RADIANS * angle);\n} // 0 to 360\n\nexport function normalizeAngle(value) {\n  value = value % 360;\n\n  if (value < 0) {\n    value += 360;\n  }\n\n  return value;\n} // TODO this doesn't work properly for skewing, and it's probably broken for rotation too\n\nexport function getArcBounds(cx, cy, startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    left: cx + minX,\n    top: cy + minY,\n    right: cx + maxX,\n    bottom: cy + maxY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\n\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\nexport function mergeBounds(bounds) {\n  var len = bounds.length;\n\n  if (len > 0) {\n    var bound = bounds[0];\n    var left = bound.left;\n    var top_1 = bound.top;\n    var right = bound.right;\n    var bottom = bound.bottom;\n\n    if (len > 1) {\n      for (var i = 1; i < len; i++) {\n        bound = bounds[i];\n        left = Math.min(bound.left, left);\n        right = Math.max(bound.right, right);\n        top_1 = Math.min(bound.top, top_1);\n        bottom = Math.max(bound.bottom, bottom);\n      }\n    }\n\n    return {\n      left: left,\n      right: right,\n      top: top_1,\n      bottom: bottom\n    };\n  }\n\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n}\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n\n  return value;\n}\nexport function inBounds(point, bounds) {\n  if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n    return true;\n  }\n\n  return false;\n}\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return normalizeAngle(angle);\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nexport function getPointOnLine(pointA, pointB, position) {\n  return {\n    x: pointA.x + (pointB.x - pointA.x) * position,\n    y: pointA.y + (pointB.y - pointA.y) * position\n  };\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\n\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\nexport function boundsOverlap(bounds1, bounds2) {\n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}","map":{"version":3,"sources":["../../../../../src/.internal/core/util/Math.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IPoint } from \"./IPoint\";\nimport { isNumber } from \"./Type\";\nimport type { IBounds } from \"./IBounds\";\n\n/**\n * ============================================================================\n * CONSTANTS\n * ============================================================================\n * @hidden\n */\nexport const PI = Math.PI;\nexport const HALFPI = PI / 2;\nexport const RADIANS = PI / 180;\nexport const DEGREES = 180 / PI;\n\n/**\n * Rounds the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\n * @return Rounded value\n */\nexport function round(value: number, precision?: number, floor?: boolean): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\n\t\tlet rounded = Math.round(value);\n\t\tif (floor) {\n\t\t\tif (rounded - value == 0.5) {\n\t\t\t\trounded--;\n\t\t\t}\n\t\t}\n\t\treturn rounded;\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.round(value * d) / d;\n\t}\n}\n\n\n/**\n * Ceils the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @return Rounded value\n */\nexport function ceil(value: number, precision: number): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\t\treturn Math.ceil(value);\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.ceil(value * d) / d;\n\t}\n}\n\n\n/**\n * [getCubicControlPointA description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\n}\n\n/**\n * [getCubicControlPointB description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointB(p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\n}\n\n\nexport function fitToRange(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns sine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function sin(angle: number): number {\n\treturn Math.sin(RADIANS * angle);\n}\n\n/**\n * Returns tan of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function tan(angle: number): number {\n\treturn Math.tan(RADIANS * angle);\n}\n\n/**\n * Returns cosine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Cosine\n */\nexport function cos(angle: number): number {\n\treturn Math.cos(RADIANS * angle);\n}\n\n// 0 to 360\nexport function normalizeAngle(value: number): number {\n\tvalue = value % 360;\n\tif (value < 0) {\n\t\tvalue += 360;\n\t}\n\treturn value;\n}\n\n// TODO this doesn't work properly for skewing, and it's probably broken for rotation too\nexport function getArcBounds(cx: number, cy: number, startAngle: number, endAngle: number, radius: number): IBounds {\n\n\tlet minX = Number.MAX_VALUE;\n\tlet minY = Number.MAX_VALUE;\n\tlet maxX = -Number.MAX_VALUE;\n\tlet maxY = -Number.MAX_VALUE;\n\n\tlet bpoints = [];\n\n\tbpoints.push(getArcPoint(radius, startAngle));\n\tbpoints.push(getArcPoint(radius, endAngle));\n\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\n\t\tif (angle >= startAngle && angle <= endAngle) {\n\t\t\tbpoints.push(getArcPoint(radius, angle));\n\t\t}\n\t}\n\n\tfor (let i = 0; i < bpoints.length; i++) {\n\t\tlet pt = bpoints[i];\n\t\tif (pt.x < minX) { minX = pt.x; }\n\t\tif (pt.y < minY) { minY = pt.y; }\n\t\tif (pt.x > maxX) { maxX = pt.x; }\n\t\tif (pt.y > maxY) { maxY = pt.y; }\n\t}\n\n\treturn ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });\n}\n\n/**\n * Returns point on arc\n *\n * @param center point\n * @param radius\n * @param arc\n * @return {boolean}\n */\nexport function getArcPoint(radius: number, arc: number) {\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\n}\n\n\nexport function mergeBounds(bounds: IBounds[]): IBounds {\n\tconst len = bounds.length;\n\n\tif (len > 0) {\n\t\tlet bound = bounds[0];\n\t\tlet left = bound.left;\n\t\tlet top = bound.top;\n\t\tlet right = bound.right;\n\t\tlet bottom = bound.bottom;\n\n\t\tif (len > 1) {\n\t\t\tfor (let i = 1; i < len; i++) {\n\t\t\t\tbound = bounds[i];\n\t\t\t\tleft = Math.min(bound.left, left);\n\t\t\t\tright = Math.max(bound.right, right);\n\t\t\t\ttop = Math.min(bound.top, top);\n\t\t\t\tbottom = Math.max(bound.bottom, bottom);\n\t\t\t}\n\t\t}\n\n\t\treturn { left, right, top, bottom };\n\t}\n\treturn { left: 0, right: 0, top: 0, bottom: 0 };\n}\n\n\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\n\n\tif (startAngle > endAngle) {\n\t\tlet temp: number = startAngle;\n\t\tstartAngle = endAngle;\n\t\tendAngle = temp;\n\t}\n\n\tvalue = normalizeAngle(value);\n\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n\tif (value < startAngle) {\n\t\tvalue += 360 * (count + 1);\n\t}\n\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\n\n\tif (value > endAngle) {\n\n\t\tif (value - 360 > startAngle) {\n\t\t\tvalue -= 360;\n\t\t}\n\t\telse {\n\t\t\tif (value < maxEnd) {\n\t\t\t\tvalue = endAngle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = startAngle;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value < startAngle) {\n\t\tif (value > maxStart) {\n\t\t\tvalue = startAngle;\n\t\t}\n\t\telse {\n\t\t\tvalue = endAngle;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nexport function inBounds(point: IPoint, bounds: IBounds) {\n\tif (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\n\tif (!point2) {\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\n\t}\n\tlet diffX: number = point2.x - point1.x;\n\tlet diffY: number = point2.y - point1.y;\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\n\tif (angle < 0) {\n\t\tangle += 360;\n\t}\n\treturn normalizeAngle(angle);\n}\n\n/**\n * [getPointOnQuadraticCurve description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param pointA        [description]\n * @param pointB        [description]\n * @param controlPoint  [description]\n * @param position      [description]\n * @return [description]\n */\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n\treturn { x: x, y: y };\n}\n\nexport function getPointOnLine(pointA: IPoint, pointB: IPoint, position: number): IPoint {\n\treturn { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };\n}\n\n\n/**\n * Returns the closest value from the array of values to the reference value.\n *\n * @param values  Array of values\n * @param value   Reference value\n * @return Closes value from the array\n */\nexport function closest(values: number[], referenceValue: number): number {\n\treturn values.reduce(function(prev, curr) {\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\n\t});\n}\n\nexport function boundsOverlap (bounds1:IBounds, bounds2:IBounds) {  \n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}