{"ast":null,"code":"import { Color } from \"./Color\";\nimport * as $type from \"./Type\";\n\nvar TextFormatter =\n/** @class */\nfunction () {\n  function TextFormatter() {}\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n\n  Object.defineProperty(TextFormatter, \"escape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text) {\n      return text.replace(/\\[\\[/g, this.prefix + \"1\").replace(/([^\\/]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").replace(/\\]\\]/g, this.prefix + \"2\").replace(/\\{\\{/g, this.prefix + \"3\").replace(/\\}\\}/g, this.prefix + \"4\").replace(/\\'\\'/g, this.prefix + \"5\");\n    }\n  });\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n  Object.defineProperty(TextFormatter, \"unescape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text) {\n      return text.replace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").replace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").replace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").replace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").replace(new RegExp(this.prefix + \"5\", \"g\"), \"'\");\n    }\n  });\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n\n  Object.defineProperty(TextFormatter, \"cleanUp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text) {\n      return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n    }\n  });\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n\n  Object.defineProperty(TextFormatter, \"chunk\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text, quotedBlocks, noFormatting) {\n      if (quotedBlocks === void 0) {\n        quotedBlocks = false;\n      }\n\n      if (noFormatting === void 0) {\n        noFormatting = false;\n      } // Init result\n\n\n      var res = []; // Replace double (escaped) square spaces and quotes with temporary codes\n\n      text = this.escape(text); // Deal with style blocks\n\n      var chunks = quotedBlocks ? text.split(\"'\") : [text];\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // Empty?\n\n        if (chunk === \"\") {\n          continue;\n        }\n\n        if (i % 2 === 0) {\n          // Text outside quotes\n          // Parse for style blocks which are \"text\" chunks, the rest chunks are\n          // \"value\"\n          chunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n          chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Placeholder?\n\n            if (chunk2 === $type.PLACEHOLDER) {\n              continue;\n            } // Empty?\n\n\n            if (chunk2 === \"\") {\n              continue;\n            } // Block or value\n\n\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"value\",\n                \"text\": chunk2\n              });\n            } else {\n              res.push({\n                \"type\": noFormatting ? \"value\" : \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        } else {\n          // A text within doublequotes\n          // All chunks are \"text\"\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Empty?\n\n            if (chunk2 === \"\") {\n              continue;\n            } // Block or text\n\n\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"text\",\n                \"text\": chunk2\n              });\n            } else if (this.isImage(chunk2)) {\n              res.push({\n                \"type\": \"image\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            } else {\n              res.push({\n                \"type\": \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        }\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore\r\n   * @param  text  Format\r\n   * @return true if it is an image\r\n   */\n\n  Object.defineProperty(TextFormatter, \"isImage\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(text) {\n      return text.match(/img[ ]?:/) ? true : false;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"getTextStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function value(style) {\n      // let textStyle: string[] = [];\n      // let textFill: string | undefined;\n      var format = {};\n\n      if (style == \"\" || style == \"[ ]\") {\n        return {};\n      } // TODO: cache\n      // let cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n      // if (cached) {\n      // \treturn cached;\n      // }\n      // Pre-process quoted text\n\n\n      var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\n      if (q) {\n        for (var i = 0; i < q.length; i++) {\n          style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n        }\n      } // Get style parts\n\n\n      var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi); // Empty?\n\n      if (!b) {\n        return {};\n      } //console.log(b)\n      // Check each part\n\n\n      for (var i = 0; i < b.length; i++) {\n        if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n          format.fontWeight = b[i];\n        } else if (b[i] == \"/\") {// Just closing tag\n          // Do nothing\n        } else if (!b[i].match(/:/)) {\n          // Color\n          format.fill = Color.fromString(b[i]);\n        } else {\n          var p = b[i].split(/:[ ]*/);\n          format[p[0]] = p[1]; //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n          //b[i] = b[i].replace(/\\+/g, \" \");\n        }\n      } // TODO: cache\n      // registry.setCache(\"translateStyleShortcuts_\" + style, res);\n\n\n      return format;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"prefix\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"__amcharts__\"\n  });\n  return TextFormatter;\n}();\n\nexport { TextFormatter };","map":{"version":3,"sources":["../../../../../src/.internal/core/util/TextFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import { Color } from \"./Color\"\nimport type { ITextStyle } from \"../render/backend/Renderer\"\nimport * as $type from \"./Type\";\n\n/**\n * Defines an interface for an object that holds a chunk of text.\n */\nexport interface ITextChunk {\n\n\t/**\n\t * Type of the chunk.\n\t */\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\n\n\t/**\n\t * Text.\n\t */\n\t\"text\": string\n\n}\n\nexport class TextFormatter {\n\n\tpublic static prefix = \"__amcharts__\";\n\n\t/**\n\t * Replaces brackets with temporary placeholders.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Escaped text\n\t */\n\tpublic static escape(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, this.prefix + \"1\").\n\t\t\treplace(/([^\\/]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").\n\t\t\treplace(/\\]\\]/g, this.prefix + \"2\").\n\t\t\treplace(/\\{\\{/g, this.prefix + \"3\").\n\t\t\treplace(/\\}\\}/g, this.prefix + \"4\").\n\t\t\treplace(/\\'\\'/g, this.prefix + \"5\");\n\t}\n\n\t/**\n\t * Replaces placeholders back to brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Escaped text\n\t * @return Unescaped text\n\t */\n\tpublic static unescape(text: string): string {\n\t\treturn text.\n\t\t\treplace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").\n\t\t\treplace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").\n\t\t\treplace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").\n\t\t\treplace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").\n\t\t\treplace(new RegExp(this.prefix + \"5\", \"g\"), \"'\");\n\t}\n\n\t/**\n\t * Cleans up the text text for leftover double square brackets.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text  Input text\n\t * @return Cleaned up text\n\t */\n\tpublic static cleanUp(text: string): string {\n\t\treturn text.\n\t\t\treplace(/\\[\\[/g, \"[\").\n\t\t\treplace(/\\]\\]/g, \"]\").\n\t\t\treplace(/\\{\\{/g, \"{\").\n\t\t\treplace(/\\}\\}/g, \"}\").\n\t\t\treplace(/\\'\\'/g, \"'\");\n\t}\n\n\t/**\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\n\t *\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\n\t * also single out text blocks enclosed within single quotes that no\n\t * formatting should be applied to, and they should be displayed as is.\n\t *\n\t * Default for the above is `false`, so that you can use single quote in text\n\t * without escaping it.\n\t *\n\t * If enabled, single quotes can be escaped by doubling it - adding two\n\t * single quotes, which will be replaced by a one single quote in the final\n\t * output.\n\t *\n\t * @ignore Exclude from docs\n\t * @param text          Text to chunk\n\t * @param quotedBlocks  Use quoted blocks\n\t * @param noFormatting  Formatting blocks will be treated as regular text\n\t * @return Array of string chunks\n\t */\n\tpublic static chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\n\n\t\t// Init result\n\t\tlet res: ITextChunk[] = [];\n\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\n\t\ttext = this.escape(text);\n\n\t\t// Deal with style blocks\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\n\t\t\tlet chunk = chunks[i];\n\n\t\t\t// Empty?\n\t\t\tif (chunk === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((i % 2) === 0) {\n\n\t\t\t\t// Text outside quotes\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\n\t\t\t\t// \"value\"\n\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Placeholder?\n\t\t\t\t\tif (chunk2 === $type.PLACEHOLDER) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or value\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"value\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// A text within doublequotes\n\t\t\t\t// All chunks are \"text\"\n\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n\n\t\t\t\t\t// Empty?\n\t\t\t\t\tif (chunk2 === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Block or text\n\t\t\t\t\tif ((i2 % 2) === 0) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\t\t\"text\": chunk2\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.isImage(chunk2)) {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"image\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres.push({\n\t\t\t\t\t\t\t\"type\": \"format\",\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Checks if supplied format contains image information and should be\n\t * formatted as such.\n\t * I.e.: `[img: myImage.png]`\n\t *\n\t * @ignore\n\t * @param  text  Format\n\t * @return true if it is an image\n\t */\n\tpublic static isImage(text: string): boolean {\n\t\treturn text.match(/img[ ]?:/) ? true : false;\n\t}\n\n\tpublic static getTextStyle(style: string): ITextStyle {\n\n\t\t// let textStyle: string[] = [];\n\t\t// let textFill: string | undefined;\n\t\tlet format: ITextStyle = {};\n\n\t\tif (style == \"\" || style == \"[ ]\") {\n\t\t\treturn {};\n\t\t}\n\n\t\t// TODO: cache\n\t\t// let cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n\t\t// if (cached) {\n\t\t// \treturn cached;\n\t\t// }\n\n\t\t// Pre-process quoted text\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\t\tif (q) {\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n\t\t\t}\n\t\t}\n\n\t\t// Get style parts\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n\n\t\t// Empty?\n\t\tif (!b) {\n\t\t\treturn {};\n\t\t}\n\n\t\t//console.log(b)\n\n\t\t// Check each part\n\t\tfor (let i: number = 0; i < b.length; i++) {\n\n\t\t\tif (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n\t\t\t\t(<any>format).fontWeight = b[i];\n\t\t\t}\n\t\t\telse if (b[i] == \"/\") {\n\t\t\t\t// Just closing tag\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\telse if (!b[i].match(/:/)) {\n\t\t\t\t// Color\n\t\t\t\tformat.fill = Color.fromString(b[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst p = b[i].split(/:[ ]*/);\n\t\t\t\t(<any>format)[p[0]] = p[1];\n\t\t\t\t//textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n\t\t\t\t//b[i] = b[i].replace(/\\+/g, \" \");\n\t\t\t}\n\n\t\t}\n\n\t\t// TODO: cache\n\t\t// registry.setCache(\"translateStyleShortcuts_\" + style, res);\n\n\t\treturn format;\n\t}\n\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}