{"ast":null,"code":"import { __extends, __read } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Axis } from \"./Axis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport { MultiDisposer } from \"../../../core/util/Disposer\";\n/**\r\n * Creates a value axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info\r\n * @important\r\n */\nvar ValueAxis = /** @class */function (_super) {\n  __extends(ValueAxis, _super);\n  function ValueAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    Object.defineProperty(_this, \"_dirtyExtremes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_dirtySelectionExtremes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_deltaMinMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_minReal\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_maxReal\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_baseValue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_syncDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"markDirtyExtremes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._dirtyExtremes = true;\n      this.markDirty();\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"markDirtySelectionExtremes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._dirtySelectionExtremes = true;\n      this.markDirty();\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.setPrivateRaw(\"name\", \"value\");\n      this.addTag(\"value\");\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_prepareChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      _super.prototype._prepareChildren.call(this);\n      if (this.isDirty(\"syncWithAxis\")) {\n        var previousValue = this._prevSettings.syncWithAxis;\n        if (previousValue) {\n          if (this._syncDp) {\n            this._syncDp.dispose();\n          }\n        }\n        var syncWithAxis = this.get(\"syncWithAxis\");\n        if (syncWithAxis) {\n          this._syncDp = new MultiDisposer([syncWithAxis.onPrivate(\"selectionMinFinal\", function () {\n            _this._dirtySelectionExtremes = true;\n          }), syncWithAxis.onPrivate(\"selectionMaxFinal\", function () {\n            _this._dirtySelectionExtremes = true;\n          })]);\n        }\n      }\n      //if (this._dirtyExtremes || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\")) {\n      if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\") || this.isDirty(\"numberFormat\")) {\n        this._getMinMax();\n        this._dirtyExtremes = false;\n      }\n      if (this._dirtySelectionExtremes && !this._isPanning) {\n        this._getSelectionMinMax();\n        this._dirtySelectionExtremes = false;\n      }\n      this._groupData();\n      if (this._sizeDirty || this._valuesDirty || this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"min\") || this.isPrivateDirty(\"selectionMax\") || this.isPrivateDirty(\"selectionMin\") || this.isPrivateDirty(\"max\") || this.isPrivateDirty(\"step\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"logarithmic\")) {\n        this._handleRangeChange();\n        this._prepareAxisItems();\n        this._updateAxisRanges();\n      }\n      this._baseValue = this.baseValue();\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_groupData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_formatText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var numberFormat = this.get(\"numberFormat\");\n      var formatter = this.getNumberFormatter();\n      var text = \"\";\n      if (numberFormat) {\n        text = formatter.format(value, numberFormat);\n      } else {\n        text = formatter.format(value, undefined, this.getPrivate(\"stepDecimalPlaces\"));\n      }\n      return text;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var logarithmic = this.get(\"logarithmic\");\n        var step = this.getPrivate(\"step\");\n        var selectionMin = this.getPrivate(\"selectionMin\");\n        var selectionMax = this.getPrivate(\"selectionMax\") + step;\n        var value = selectionMin - step;\n        var i = 0;\n        if (logarithmic) {\n          value = selectionMin;\n        }\n        while (value < selectionMax) {\n          var dataItem = void 0;\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n            this._dataItems.push(dataItem);\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n          this._createAssets(dataItem, []);\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n          dataItem.setRaw(\"value\", value);\n          var label = dataItem.get(\"label\");\n          if (label) {\n            label.set(\"text\", this._formatText(value));\n          }\n          this._prepareDataItem(dataItem);\n          if (!logarithmic) {\n            value += step;\n          } else {\n            var differencePower = Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E;\n            if (differencePower > 1) {\n              value = Math.pow(10, Math.log(min) * Math.LOG10E + i);\n            } else {\n              value += step;\n            }\n          }\n          var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n          if (stepPower < 1) {\n            // exponent is less then 1 too. Count decimals of exponent\n            var decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;\n            // round value to avoid floating point issues\n            value = $math.round(value, decCount);\n          }\n          i++;\n        }\n        for (var j = i; j < this.dataItems.length; j++) {\n          this.dataItems[j].hide();\n        }\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n        this._updateGhost();\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_prepareDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, count) {\n      var renderer = this.get(\"renderer\");\n      var value = dataItem.get(\"value\");\n      var endValue = dataItem.get(\"endValue\");\n      var position = this.valueToPosition(value);\n      var endPosition = position;\n      var fillEndPosition = this.valueToPosition(value + this.getPrivate(\"step\"));\n      if ($type.isNumber(endValue)) {\n        endPosition = this.valueToPosition(endValue);\n        fillEndPosition = endPosition;\n      }\n      renderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n      var grid = dataItem.get(\"grid\");\n      renderer.updateGrid(grid, position, endPosition);\n      if (grid) {\n        if (value == this.get(\"baseValue\", 0)) {\n          grid.addTag(\"base\");\n          grid._applyThemes();\n        } else if (grid.hasTag(\"base\")) {\n          grid.removeTag(\"base\");\n          grid._applyThemes();\n        }\n      }\n      renderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n      renderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n      this._processBullet(dataItem);\n      renderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n      if (!dataItem.get(\"isRange\")) {\n        var fillRule = this.get(\"fillRule\");\n        if (fillRule) {\n          fillRule(dataItem);\n        }\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var selectionMin = this.positionToValue(this.get(\"start\", 0));\n      var selectionMax = this.positionToValue(this.get(\"end\", 1));\n      var gridCount = this.get(\"renderer\").gridCount();\n      var minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n      var stepDecimalPlaces = $utils.decimalPlaces(minMaxStep.step);\n      this.setPrivateRaw(\"stepDecimalPlaces\", stepDecimalPlaces);\n      selectionMin = $math.round(selectionMin, stepDecimalPlaces);\n      selectionMax = $math.round(selectionMax, stepDecimalPlaces);\n      minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n      var step = minMaxStep.step;\n      selectionMin = minMaxStep.min;\n      selectionMax = minMaxStep.max;\n      if (this.getPrivate(\"selectionMin\") !== selectionMin || this.getPrivate(\"selectionMax\") !== selectionMax || this.getPrivate(\"step\") !== step) {\n        this.setPrivateRaw(\"selectionMin\", selectionMin);\n        this.setPrivateRaw(\"selectionMax\", selectionMax);\n        this.setPrivateRaw(\"step\", step);\n      }\n    }\n  });\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"positionToValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n      if (!this.get(\"logarithmic\")) {\n        return position * (max - min) + min;\n      } else {\n        return Math.pow(Math.E, (position * (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E) + Math.log(min) * Math.LOG10E) / Math.LOG10E);\n      }\n    }\n  });\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"valueToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n      if (!this.get(\"logarithmic\")) {\n        return (value - min) / (max - min);\n      } else {\n        if (value <= 0) {\n          var treatZeroAs = this.get(\"treatZeroAs\");\n          if ($type.isNumber(treatZeroAs)) {\n            value = treatZeroAs;\n          }\n        }\n        return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"valueToFinalPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var min = this.getPrivate(\"minFinal\");\n      var max = this.getPrivate(\"maxFinal\");\n      if (!this.get(\"logarithmic\")) {\n        return (value - min) / (max - min);\n      } else {\n        if (value <= 0) {\n          var treatZeroAs = this.get(\"treatZeroAs\");\n          if ($type.isNumber(treatZeroAs)) {\n            value = treatZeroAs;\n          }\n        }\n        return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n      }\n    }\n  });\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, location, baseValue) {\n      value = baseValue + (value - baseValue) * location;\n      var position = this.valueToPosition(value);\n      return this._settings.renderer.positionToCoordinate(position);\n    }\n  });\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, location, baseValue) {\n      value = baseValue + (value - baseValue) * location;\n      var position = this.valueToPosition(value);\n      return this._settings.renderer.positionToCoordinate(position);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      var value = dataItem.get(field);\n      var stackToItem = dataItem.get(\"stackToItemX\");\n      if (stackToItem) {\n        var series = dataItem.component;\n        value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);\n      } else {\n        value = this._baseValue + (value - this._baseValue) * axisLocation;\n      }\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      var value = dataItem.get(field);\n      var stackToItem = dataItem.get(\"stackToItemY\");\n      if (stackToItem) {\n        var series = dataItem.component;\n        value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);\n      } else {\n        value = this._baseValue + (value - this._baseValue) * axisLocation;\n      }\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * Returns relative position of axis' `baseValue`.\r\n   *\r\n   * @return  Base value position\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"basePosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.valueToPosition(this.baseValue());\n    }\n  });\n  /**\r\n   * Base value of the [[ValueAxis]], which determines positive and negative\r\n   * values.\r\n   *\r\n   * @return Base value\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"baseValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = Math.min(this.getPrivate(\"minFinal\", -Infinity), this.getPrivate(\"selectionMin\", -Infinity));\n      var max = Math.max(this.getPrivate(\"maxFinal\", Infinity), this.getPrivate(\"selectionMax\", Infinity));\n      var baseValue = this.get(\"baseValue\", 0);\n      if (baseValue < min) {\n        baseValue = min;\n      }\n      if (baseValue > max) {\n        baseValue = max;\n      }\n      return baseValue;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"cellEndValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      return value;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"fixSmallStep\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (step) {\n      // happens because of floating point error\n      if (1 + step === 1) {\n        step *= 2;\n        return this.fixSmallStep(step);\n      }\n      return step;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_fixMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min) {\n      return min;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_fixMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (max) {\n      return max;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_calculateTotals\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this.get(\"calculateTotals\")) {\n        var series = this.series[0];\n        if (series) {\n          var startIndex = series.getPrivate(\"startIndex\", 0);\n          if (series.dataItems.length > 0) {\n            if (startIndex > 0) {\n              startIndex--;\n            }\n            var endIndex = series.getPrivate(\"endIndex\", series.dataItems.length);\n            if (endIndex < series.dataItems.length) {\n              endIndex++;\n            }\n            var field_1;\n            var vc_1;\n            if (series.get(\"yAxis\") == this) {\n              field_1 = \"valueY\";\n              vc_1 = \"vcy\";\n            } else if (series.get(\"xAxis\") == this) {\n              field_1 = \"valueX\";\n              vc_1 = \"vcx\";\n            }\n            var fieldWorking_1 = field_1 + \"Working\";\n            if (field_1) {\n              var _loop_1 = function (i) {\n                var sum = 0;\n                var total = 0;\n                $array.each(this_1.series, function (series) {\n                  if (!series.get(\"excludeFromTotal\")) {\n                    var dataItem = series.dataItems[i];\n                    if (dataItem) {\n                      var value = dataItem.get(fieldWorking_1) * series.get(vc_1);\n                      if (value != undefined) {\n                        sum += value;\n                        total += Math.abs(value);\n                      }\n                    }\n                  }\n                });\n                $array.each(this_1.series, function (series) {\n                  if (!series.get(\"excludeFromTotal\")) {\n                    var dataItem = series.dataItems[i];\n                    if (dataItem) {\n                      var value = dataItem.get(fieldWorking_1) * series.get(vc_1);\n                      if (value != undefined) {\n                        dataItem.set(field_1 + \"Total\", total);\n                        dataItem.set(field_1 + \"Sum\", sum);\n                        dataItem.set(field_1 + \"TotalPercent\", value / total * 100);\n                      }\n                    }\n                  }\n                });\n              };\n              var this_1 = this;\n              for (var i = startIndex; i < endIndex; i++) {\n                _loop_1(i);\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_getSelectionMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _a;\n      var _this = this;\n      var min = this.getPrivate(\"minFinal\");\n      var max = this.getPrivate(\"maxFinal\");\n      var minDefined = this.get(\"min\");\n      var maxDefined = this.get(\"max\");\n      var extraMin = this.get(\"extraMin\", 0);\n      var extraMax = this.get(\"extraMax\", 0);\n      var gridCount = this.get(\"renderer\").gridCount();\n      var strictMinMax = this.get(\"strictMinMax\", false);\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var selectionMin_1 = max;\n        var selectionMax_1 = min;\n        $array.each(this.series, function (series) {\n          if (!series.get(\"ignoreMinMax\")) {\n            var seriesMin = void 0;\n            var seriesMax = void 0;\n            if (series.get(\"xAxis\") === _this) {\n              seriesMin = series.getPrivate(\"selectionMinX\", series.getPrivate(\"minX\"));\n              seriesMax = series.getPrivate(\"selectionMaxX\", series.getPrivate(\"maxX\"));\n            } else if (series.get(\"yAxis\") === _this) {\n              seriesMin = series.getPrivate(\"selectionMinY\", series.getPrivate(\"minY\"));\n              seriesMax = series.getPrivate(\"selectionMaxY\", series.getPrivate(\"maxY\"));\n            }\n            if (!series.isHidden() && !series.isShowing()) {\n              if ($type.isNumber(seriesMin)) {\n                selectionMin_1 = Math.min(selectionMin_1, seriesMin);\n              }\n              if ($type.isNumber(seriesMax)) {\n                selectionMax_1 = Math.max(selectionMax_1, seriesMax);\n              }\n            }\n          }\n        });\n        if (selectionMin_1 > selectionMax_1) {\n          _a = __read([selectionMax_1, selectionMin_1], 2), selectionMin_1 = _a[0], selectionMax_1 = _a[1];\n        }\n        if ($type.isNumber(minDefined)) {\n          if (strictMinMax) {\n            selectionMin_1 = minDefined;\n          } else {\n            selectionMin_1 = min;\n          }\n        } else if (strictMinMax) {\n          if ($type.isNumber(this._minReal)) {\n            selectionMin_1 = this._minReal;\n          }\n        }\n        if ($type.isNumber(maxDefined)) {\n          if (strictMinMax) {\n            selectionMax_1 = maxDefined;\n          } else {\n            selectionMax_1 = max;\n          }\n        } else if (strictMinMax) {\n          if ($type.isNumber(this._maxReal)) {\n            selectionMax_1 = this._maxReal;\n          }\n        }\n        if (selectionMin_1 === selectionMax_1) {\n          selectionMin_1 -= this._deltaMinMax;\n          selectionMax_1 += this._deltaMinMax;\n          var minMaxStep2 = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount, strictMinMax);\n          selectionMin_1 = minMaxStep2.min;\n          selectionMax_1 = minMaxStep2.max;\n        }\n        var minMaxStep = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount);\n        selectionMin_1 = minMaxStep.min;\n        selectionMax_1 = minMaxStep.max;\n        selectionMin_1 -= (selectionMax_1 - selectionMin_1) * extraMin;\n        selectionMax_1 += (selectionMax_1 - selectionMin_1) * extraMax;\n        selectionMin_1 = $math.fitToRange(selectionMin_1, min, max);\n        selectionMax_1 = $math.fitToRange(selectionMax_1, min, max);\n        // do it for the second time !important\t\t\t\n        minMaxStep = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount, true);\n        if (!strictMinMax) {\n          selectionMin_1 = minMaxStep.min;\n          selectionMax_1 = minMaxStep.max;\n        }\n        var syncWithAxis = this.get(\"syncWithAxis\");\n        if (syncWithAxis) {\n          minMaxStep = this._syncAxes(selectionMin_1, selectionMax_1, minMaxStep.step, syncWithAxis.getPrivate(\"selectionMinFinal\", syncWithAxis.getPrivate(\"minFinal\", 0)), syncWithAxis.getPrivate(\"selectionMaxFinal\", syncWithAxis.getPrivate(\"maxFinal\", 1)), syncWithAxis.getPrivate(\"selectionStepFinal\", syncWithAxis.getPrivate(\"step\", 1)));\n          selectionMin_1 = minMaxStep.min;\n          selectionMax_1 = minMaxStep.max;\n        }\n        if (strictMinMax) {\n          if ($type.isNumber(minDefined)) {\n            selectionMin_1 = Math.max(selectionMin_1, minDefined);\n          }\n          if ($type.isNumber(maxDefined)) {\n            selectionMax_1 = Math.min(selectionMax_1, maxDefined);\n          }\n        }\n        var start = this.valueToFinalPosition(selectionMin_1);\n        var end = this.valueToFinalPosition(selectionMax_1);\n        this.setPrivateRaw(\"selectionMinFinal\", selectionMin_1);\n        this.setPrivateRaw(\"selectionMaxFinal\", selectionMax_1);\n        this.setPrivateRaw(\"selectionStepFinal\", minMaxStep.step);\n        this.zoom(start, end);\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_getMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n      var minDefined = this.get(\"min\");\n      var maxDefined = this.get(\"max\");\n      var min = Infinity;\n      var max = -Infinity;\n      var extraMin = this.get(\"extraMin\", 0);\n      var extraMax = this.get(\"extraMax\", 0);\n      var minDiff = Infinity;\n      $array.each(this.series, function (series) {\n        if (!series.get(\"ignoreMinMax\")) {\n          var seriesMin = void 0;\n          var seriesMax = void 0;\n          if (series.get(\"xAxis\") === _this) {\n            seriesMin = series.getPrivate(\"minX\");\n            seriesMax = series.getPrivate(\"maxX\");\n          } else if (series.get(\"yAxis\") === _this) {\n            seriesMin = series.getPrivate(\"minY\");\n            seriesMax = series.getPrivate(\"maxY\");\n          }\n          if ($type.isNumber(seriesMin) && $type.isNumber(seriesMax)) {\n            min = Math.min(min, seriesMin);\n            max = Math.max(max, seriesMax);\n            var diff = seriesMax - seriesMin;\n            if (diff <= 0) {\n              diff = Math.abs(seriesMax / 100);\n            }\n            if (diff < minDiff) {\n              minDiff = diff;\n            }\n          }\n        }\n      });\n      if (this.get(\"logarithmic\")) {\n        var treatZeroAs = this.get(\"treatZeroAs\");\n        if ($type.isNumber(treatZeroAs)) {\n          if (min <= 0) {\n            min = treatZeroAs;\n          }\n        }\n        if (min <= 0) {\n          new Error(\"Logarithmic value axis can not have values <= 0.\");\n        }\n      }\n      if (min === 0 && max === 0) {\n        max = 0.9;\n        min = -0.9;\n      }\n      if ($type.isNumber(minDefined)) {\n        min = minDefined;\n      }\n      if ($type.isNumber(maxDefined)) {\n        max = maxDefined;\n      }\n      // meaning no min/max found on series/ranges and no min/max was defined\n      if (min === Infinity && max === -Infinity) {\n        return;\n      }\n      // adapter\n      var minAdapted = this.adapters.fold(\"min\", min);\n      var maxAdapted = this.adapters.fold(\"max\", max);\n      if ($type.isNumber(minAdapted)) {\n        min = minAdapted;\n      }\n      if ($type.isNumber(maxAdapted)) {\n        max = maxAdapted;\n      }\n      // DateAxis does some magic here\n      min = this._fixMin(min);\n      max = this._fixMax(max);\n      // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\n      if (max - min <= 1 / Math.pow(10, 15)) {\n        if (max - min !== 0) {\n          this._deltaMinMax = (max - min) / 2;\n        } else {\n          // the number by which we need to raise 10 to get difference\n          var exponent = Math.log(Math.abs(max)) * Math.LOG10E;\n          // here we find a number which is power of 10 and has the same count of numbers as difference has\n          var power = Math.pow(10, Math.floor(exponent));\n          // reduce this number by 10 times\n          power = power / 10;\n          this._deltaMinMax = power;\n        }\n        min -= this._deltaMinMax;\n        max += this._deltaMinMax;\n      }\n      // add extras\n      min -= (max - min) * extraMin;\n      max += (max - min) * extraMax;\n      this._minReal = min;\n      this._maxReal = max;\n      var strict = this.get(\"strictMinMax\");\n      if ($type.isNumber(maxDefined)) {\n        strict = true;\n      }\n      var gridCount = this.get(\"renderer\").gridCount();\n      var minMaxStep = this._adjustMinMax(min, max, gridCount, strict);\n      min = minMaxStep.min;\n      max = minMaxStep.max;\n      // do it for the second time with strict true (importat!)\n      minMaxStep = this._adjustMinMax(min, max, gridCount, true);\n      min = minMaxStep.min;\n      max = minMaxStep.max;\n      // return min max if strict\n      if (this.get(\"strictMinMax\")) {\n        if ($type.isNumber(minDefined)) {\n          min = minDefined;\n        } else {\n          min = this._minReal;\n        }\n        if ($type.isNumber(maxDefined)) {\n          max = maxDefined;\n        } else {\n          max = this._maxReal;\n        }\n        if (max - min <= 0.00000001) {\n          min -= this._deltaMinMax;\n          max += this._deltaMinMax;\n        }\n        min -= (max - min) * extraMin;\n        max += (max - min) * extraMax;\n      }\n      minAdapted = this.adapters.fold(\"min\", min);\n      maxAdapted = this.adapters.fold(\"max\", max);\n      if ($type.isNumber(minAdapted)) {\n        min = minAdapted;\n      }\n      if ($type.isNumber(maxAdapted)) {\n        max = maxAdapted;\n      }\n      if (minDiff == Infinity) {\n        minDiff = max - min;\n      }\n      var syncWithAxis = this.get(\"syncWithAxis\");\n      if (syncWithAxis) {\n        minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate(\"minFinal\", syncWithAxis.getPrivate(\"min\", 0)), syncWithAxis.getPrivate(\"maxFinal\", syncWithAxis.getPrivate(\"max\", 1)), syncWithAxis.getPrivate(\"step\", 1));\n        min = minMaxStep.min;\n        max = minMaxStep.max;\n      }\n      this.setPrivateRaw(\"maxZoomFactor\", (max - min) / minDiff * this.get(\"maxZoomFactor\", 100));\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        if (this.getPrivate(\"minFinal\") !== min || this.getPrivate(\"maxFinal\") !== max) {\n          this.setPrivate(\"minFinal\", min);\n          this.setPrivate(\"maxFinal\", max);\n          var duration = this.get(\"interpolationDuration\", 0);\n          var easing = this.get(\"interpolationEasing\");\n          this.animatePrivate({\n            key: \"min\",\n            to: min,\n            duration: duration,\n            easing: easing\n          });\n          this.animatePrivate({\n            key: \"max\",\n            to: max,\n            duration: duration,\n            easing: easing\n          });\n        }\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, strictMode) {\n      var logarithmic = this.get(\"logarithmic\");\n      // will fail if 0\n      if (gridCount <= 1) {\n        gridCount = 1;\n      }\n      gridCount = Math.round(gridCount);\n      var initialMin = min;\n      var initialMax = max;\n      var difference = max - min;\n      // in case min and max is the same, use max\n      if (difference === 0) {\n        difference = Math.abs(max);\n      }\n      // the number by which we need to raise 10 to get difference\n      var exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n      // here we find a number which is power of 10 and has the same count of numbers as difference has\n      var power = Math.pow(10, Math.floor(exponent));\n      // reduce this number by 10 times\n      power = power / 10;\n      var extra = power;\n      if (strictMode) {\n        extra = 0;\n      }\n      if (!logarithmic) {\n        // round down min\n        if (strictMode) {\n          min = Math.floor(min / power) * power;\n          // round up max\n          max = Math.ceil(max / power) * power;\n        } else {\n          min = Math.ceil(min / power) * power - extra;\n          // round up max\n          max = Math.floor(max / power) * power + extra;\n        }\n        // don't let min go below 0 if real min is >= 0\n        if (min < 0 && initialMin >= 0) {\n          min = 0;\n        }\n        // don't let max go above 0 if real max is <= 0\n        if (max > 0 && initialMax <= 0) {\n          max = 0;\n        }\n      }\n      // logarithmic\n      else {\n        if (min <= 0) {\n          //throw Error(\"Logarithmic value axis can not have values <= 0.\");\n          min = this.get(\"baseValue\", 0);\n        }\n        if (min === Infinity) {\n          min = 1;\n        }\n        if (max === -Infinity) {\n          max = 10;\n        }\n        min = Math.pow(10, Math.floor(Math.log(Math.abs(min)) * Math.LOG10E));\n        max = Math.pow(10, Math.ceil(Math.log(Math.abs(max)) * Math.LOG10E));\n        if (this.get(\"strictMinMax\")) {\n          var minDefined = this.get(\"min\");\n          var maxDefined = this.get(\"max\");\n          if ($type.isNumber(minDefined) && minDefined > 0) {\n            min = minDefined;\n          }\n          if ($type.isNumber(maxDefined) && maxDefined > 0) {\n            max = maxDefined;\n          }\n        }\n      }\n      exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n      power = Math.pow(10, Math.floor(exponent));\n      power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance\n      // approximate difference between two grid lines\n      var step = Math.ceil(difference / gridCount / power) * power;\n      var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n      // the step should divide by  2, 5, and 10.\n      var stepDivisor = Math.ceil(step / stepPower); // number 0 - 10\n      if (stepDivisor > 5) {\n        stepDivisor = 10;\n      } else if (stepDivisor <= 5 && stepDivisor > 2) {\n        stepDivisor = 5;\n      }\n      // now get real step\n      step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n      var maxPrecision = this.get(\"maxPrecision\");\n      if ($type.isNumber(maxPrecision)) {\n        var ceiledStep = $math.ceil(step, maxPrecision);\n        if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {\n          step = ceiledStep;\n        }\n      }\n      var decCount = 0;\n      // in case numbers are smaller than 1\n      if (stepPower < 1) {\n        // exponent is less then 1 too. Count decimals of exponent\n        decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;\n        // round step\n        step = $math.round(step, decCount);\n      }\n      if (!logarithmic) {\n        // final min and max\n        var minCount = Math.floor(min / step);\n        min = $math.round(step * minCount, decCount);\n        var maxCount = void 0;\n        if (!strictMode) {\n          maxCount = Math.ceil(max / step);\n        } else {\n          maxCount = Math.floor(max / step);\n        }\n        if (maxCount === minCount) {\n          maxCount++;\n        }\n        max = $math.round(step * maxCount, decCount);\n        if (max < initialMax) {\n          max = max + step;\n        }\n        if (min > initialMin) {\n          min = min - step;\n        }\n      }\n      step = this.fixSmallStep(step);\n      return {\n        min: min,\n        max: max,\n        step: step\n      };\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var numberFormat = this.get(\"tooltipNumberFormat\", this.get(\"numberFormat\"));\n      var formatter = this.getNumberFormatter();\n      var extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n      var decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n      var value = $math.round(this.positionToValue(position), decimals);\n      if (numberFormat) {\n        return formatter.format(value, numberFormat);\n      } else {\n        return formatter.format(value, undefined, decimals);\n        //label.set(\"text\", this.getNumberFormatter().format(value, undefined, this.getPrivate(\"stepDecimalPlaces\")));\n      }\n      // //@todo number formatter + tag\n      // return $math.round(this.positionToValue(position), this.getPrivate(\"stepDecimalPlaces\")).toString();\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series, position) {\n      var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      var value = this.positionToValue(position);\n      var index = undefined;\n      var oldDiff;\n      $array.each(series.dataItems, function (dataItem, i) {\n        var diff = Math.abs(dataItem.get(fieldName) - value);\n        if (index === undefined || diff < oldDiff) {\n          index = i;\n          oldDiff = diff;\n        }\n      });\n      if (index != null) {\n        return series.dataItems[index];\n      }\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` values.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start value\r\n   * @param  end       End value\r\n   * @param  duration  Duration in milliseconds\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"zoomToValues\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration) {\n      var min = this.getPrivate(\"minFinal\", 0);\n      var max = this.getPrivate(\"maxFinal\", 0);\n      if (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n        this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n      }\n    }\n  });\n  /**\r\n   * Syncs with a target axis.\r\n   *\r\n   * @param  min  Min\r\n   * @param  max  Max\r\n   * @param  step Step\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"_syncAxes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, step, syncMin, syncMax, syncStep) {\n      var axis = this.get(\"syncWithAxis\");\n      if (axis) {\n        var count = Math.round(syncMax - syncMin) / syncStep;\n        var currentCount = Math.round((max - min) / step);\n        var gridCount = this.get(\"renderer\").gridCount();\n        if ($type.isNumber(count) && $type.isNumber(currentCount)) {\n          var synced = false;\n          var c = 0;\n          var diff = (max - min) * 0.01;\n          var omin = min;\n          var omax = max;\n          var ostep = step;\n          while (synced != true) {\n            synced = this._checkSync(omin, omax, ostep, count);\n            c++;\n            if (c > 500) {\n              synced = true;\n            }\n            if (!synced) {\n              if (c / 3 == Math.round(c / 3)) {\n                omin = min - diff * c;\n                if (min >= 0 && omin < 0) {\n                  omin = 0;\n                }\n              } else {\n                omax = max + diff * c;\n                if (omax <= 0 && omax > 0) {\n                  omax = 0;\n                }\n              }\n              var minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);\n              omin = minMaxStep.min;\n              omax = minMaxStep.max;\n              ostep = minMaxStep.step;\n            } else {\n              min = omin;\n              max = omax;\n              step = ostep;\n            }\n          }\n        }\n      }\n      return {\n        min: min,\n        max: max,\n        step: step\n      };\n    }\n  });\n  /**\r\n   * Returns `true` if axis needs to be resunced with some other axis.\r\n   */\n  Object.defineProperty(ValueAxis.prototype, \"_checkSync\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, step, count) {\n      var currentCount = (max - min) / step;\n      for (var i = 1; i < count; i++) {\n        if ($math.round(currentCount / i, 1) == count || currentCount * i == count) {\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n  Object.defineProperty(ValueAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"ValueAxis\"\n  });\n  Object.defineProperty(ValueAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Axis.classNames.concat([ValueAxis.className])\n  });\n  return ValueAxis;\n}(Axis);\nexport { ValueAxis };","map":{"version":3,"names":["DataItem","Axis","$type","$array","$math","$utils","MultiDisposer","ValueAxis","_super","__extends","_this","apply","arguments","Object","defineProperty","value","_dirtyExtremes","markDirty","_dirtySelectionExtremes","_settings","themeTags","mergeTags","setPrivateRaw","addTag","prototype","_afterNew","call","_prepareChildren","isDirty","previousValue","_prevSettings","syncWithAxis","_syncDp","dispose","get","onPrivate","_sizeDirty","_valuesDirty","isPrivateDirty","_getMinMax","_isPanning","_getSelectionMinMax","_groupData","_handleRangeChange","_prepareAxisItems","_updateAxisRanges","_baseValue","baseValue","numberFormat","formatter","getNumberFormatter","text","format","undefined","getPrivate","min","max","isNumber","logarithmic","step","selectionMin","selectionMax","i","dataItem","dataItems","length","_dataItems","push","processDataItem","_createAssets","isHidden","show","setRaw","label","set","_formatText","_prepareDataItem","differencePower","Math","log","LOG10E","pow","stepPower","floor","abs","decCount","round","j","hide","each","series","inited","_markDirtyAxes","_updateGhost","count","renderer","endValue","position","valueToPosition","endPosition","fillEndPosition","updateLabel","grid","updateGrid","_applyThemes","hasTag","removeTag","updateTick","updateFill","_processBullet","updateBullet","fillRule","positionToValue","gridCount","minMaxStep","_adjustMinMax","stepDecimalPlaces","decimalPlaces","E","treatZeroAs","location","positionToCoordinate","field","_cellLocation","axisLocation","getDataItemPositionX","stackToItem","component","getStackedXValueWorking","getDataItemPositionY","getStackedYValueWorking","Infinity","fixSmallStep","startIndex","endIndex","field_1","vc_1","fieldWorking_1","sum","total","this_1","minDefined","maxDefined","extraMin","extraMax","strictMinMax","selectionMin_1","selectionMax_1","seriesMin","seriesMax","isShowing","_a","__read","_minReal","_maxReal","_deltaMinMax","minMaxStep2","fitToRange","_syncAxes","start","valueToFinalPosition","end","zoom","minDiff","diff","Error","minAdapted","adapters","fold","maxAdapted","_fixMin","_fixMax","exponent","power","strict","setPrivate","duration","easing","animatePrivate","key","to","strictMode","initialMin","initialMax","difference","extra","ceil","stepDivisor","maxPrecision","ceiledStep","Number","MAX_VALUE","minCount","maxCount","extraDecimals","decimals","fieldName","index","oldDiff","syncMin","syncMax","syncStep","axis","currentCount","synced","c","omin","omax","ostep","_checkSync","classNames","concat","className"],"sources":["../../../../../../src/.internal/charts/xy/axes/ValueAxis.ts"],"sourcesContent":["import { DataItem } from \"../../../core/render/Component\";\nimport type { AxisRenderer } from \"./AxisRenderer\";\nimport { Axis, IAxisSettings, IAxisPrivate, IAxisDataItem, IAxisEvents } from \"./Axis\";\nimport type { IXYSeriesDataItem, XYSeries } from \"../series/XYSeries\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport { MultiDisposer } from \"../../../core/util/Disposer\";\n//import * as $order from \"../../../core/util/Order\";\n\nexport interface IValueAxisSettings<R extends AxisRenderer> extends IAxisSettings<R> {\n\n\t/**\n\t * Override minimum value for the axis scale.\n\t *\n\t * NOTE: the axis might modify the minimum value to fit into its scale better,\n\t * unless `strictMinMax` is set to `true`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Custom_scope} for more info\n\t */\n\tmin?: number;\n\n\t/**\n\t * Override maximum value for the axis scale.\n\t *\n\t * NOTE: the axis might modify the maximum value to fit into its scale better,\n\t * unless `strictMinMax` is set to `true`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Custom_scope} for more info\n\t */\n\tmax?: number;\n\n\t/**\n\t * Force axis scale to be precisely at values as set in `min` and/or `max`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Custom_scope} for more info\n\t */\n\tstrictMinMax?: boolean;\n\n\t/**\n\t * If set to `true` axis will use logarithmic scale.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Logarithmic_scale} for more info\n\t */\n\tlogarithmic?: boolean;\n\n\t/**\n\t * Treat zero values as some other value.\n\t *\n\t * Useful in situations where zero would result in error, i.e. logarithmic\n\t * scale.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Logarithmic_scale} for more info\n\t */\n\ttreatZeroAs?: number;\n\n\t/**\n\t * Relative extension to the automatically-calculated minimum value of the\n\t * axis scale.\n\t *\n\t * E..g. `0.1` will extend the scale by 10%, so if max value is `1000` and\n\t * minimum value is `0`, the new minimum value will be `-100`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Relative_scope_extension} for more info\n\t */\n\textraMin?: number;\n\n\t/**\n\t * Relative extension to the automatically-calculated maximum value of the\n\t * axis scale.\n\t *\n\t * E..g. `0.1` will extend the scale by 10%, so if max value is `1000`, the\n\t * axis will now show maximum value of `1100`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Relative_scope_extension} for more info\n\t */\n\textraMax?: number;\n\n\t/**\n\t * Base value, which indicates the threshold between \"positive\" and \"negative\"\n\t * values.\n\t *\n\t * @default 0\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Base_value} for more info\n\t */\n\tbaseValue?: number;\n\n\t/**\n\t * Maximum number of decimals to allow in axis labels.\n\t *\n\t * This setting not only affects formatting of the labels, but also where and\n\t * how many grid/labels are placed on the axis.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Label_format} for more info\n\t */\n\tmaxPrecision?: number;\n\n\t/**\n\t * A function that can be used to specify how to configure axis fills.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_fills} for more info\n\t */\n\tfillRule?: (dataItem: DataItem<IValueAxisDataItem>) => void;\n\n\t/**\n\t * Number format to use for axis labels.\n\t *\n\t * If not set, will use format set in global number formatter.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Label_format} for more info\n\t */\n\tnumberFormat?: string;\n\n\t/**\n\t * A numeric format used for numbers displayed in axis tooltip.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Tooltip_number_format} for more info\n\t */\n\ttooltipNumberFormat?: string | Intl.NumberFormatOptions;\n\n\t/**\n\t * If set, will use greater precision for the axis fooltip than the one for\n\t * axis' actual labels.\n\t *\n\t * E.g. if axis displays labels with one decimal (`1.0`, `1.1`, `1.2`) setting\n\t * this setting to `1` would allow two decimals in axis tooltip, e.g. `1.15`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Tooltip_number_format} for more info\n\t */\n\textraTooltipPrecision?: number;\n\n\t/**\n\t * If your series relies on dynamically calculated values, like value\n\t * changes, percents, or total sums, set this to `true`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Calculated_values} for more info\n\t */\n\tcalculateTotals?: boolean;\n\n\t/**\n\t * This setting can be set to an instance of another [[ValueAxis]].\n\t *\n\t * If set the grid of this axis will be synced with grid of the target axis.\n\t *\n\t * NOTE: this is not 100% guaranteed to work. In some rare cases perfect\n\t * sync might not be possible.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Syncing_grid} for more info\n\t */\n\tsyncWithAxis?: ValueAxis<AxisRenderer>;\n\n}\n\nexport interface IValueAxisDataItem extends IAxisDataItem {\n\n\t/**\n\t * Value of the data item.\n\t */\n\tvalue?: number;\n\n\t/**\n\t * End value for axis items that span multiple values, like axis ranges.\n\t */\n\tendValue?: number;\n\n}\n\nexport interface IMinMaxStep {\n\tmin: number;\n\tmax: number;\n\tstep: number;\n}\n\nexport interface IValueAxisPrivate extends IAxisPrivate {\n\tmin?: number;\n\tmax?: number;\n\tminFinal?: number;\n\tmaxFinal?: number;\n\tselectionMin?: number;\n\tselectionMax?: number;\n\tselectionMinFinal?: number;\n\tselectionMaxFinal?: number;\n\tselectionStepFinal?: number;\n\tstep?: number;\n\tstepDecimalPlaces?: number;\n}\n\nexport interface IValueAxisEvents extends IAxisEvents {\n\n}\n\n/**\n * Creates a value axis.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info\n * @important\n */\nexport class ValueAxis<R extends AxisRenderer> extends Axis<R> {\n\tpublic static className: string = \"ValueAxis\";\n\tpublic static classNames: Array<string> = Axis.classNames.concat([ValueAxis.className]);\n\n\tdeclare public _settings: IValueAxisSettings<R>;\n\tdeclare public _privateSettings: IValueAxisPrivate;\n\tdeclare public _dataItemSettings: IValueAxisDataItem;\n\tdeclare public _events: IValueAxisEvents;\n\n\tprotected _dirtyExtremes: boolean = false;\n\tprotected _dirtySelectionExtremes: boolean = false;\n\tprotected _deltaMinMax: number = 1;\n\tprotected _minReal: number | undefined;\n\tprotected _maxReal: number | undefined;\n\n\tprotected _baseValue: number = 0;\n\tprotected _syncDp?: MultiDisposer;\n\n\t/**\n\t * @ignore\n\t */\n\tpublic markDirtyExtremes() {\n\t\tthis._dirtyExtremes = true;\n\t\tthis.markDirty();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic markDirtySelectionExtremes() {\n\t\tthis._dirtySelectionExtremes = true;\n\t\tthis.markDirty();\n\t}\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\t\tthis.setPrivateRaw(\"name\", \"value\");\n\t\tthis.addTag(\"value\");\n\t\tsuper._afterNew();\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tif (this.isDirty(\"syncWithAxis\")) {\n\t\t\tlet previousValue = this._prevSettings.syncWithAxis;\n\t\t\tif (previousValue) {\n\t\t\t\tif (this._syncDp) {\n\t\t\t\t\tthis._syncDp.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet syncWithAxis = this.get(\"syncWithAxis\");\n\t\t\tif (syncWithAxis) {\n\t\t\t\tthis._syncDp = new MultiDisposer([\n\t\t\t\t\tsyncWithAxis.onPrivate(\"selectionMinFinal\", () => {\n\t\t\t\t\t\tthis._dirtySelectionExtremes = true;\n\t\t\t\t\t}),\n\t\t\t\t\tsyncWithAxis.onPrivate(\"selectionMaxFinal\", () => {\n\t\t\t\t\t\tthis._dirtySelectionExtremes = true;\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t}\n\t\t}\n\n\t\t//if (this._dirtyExtremes || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\")) {\n\t\tif (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\") || this.isDirty(\"numberFormat\")) {\n\t\t\tthis._getMinMax();\n\t\t\tthis._dirtyExtremes = false;\n\t\t}\n\n\t\tif (this._dirtySelectionExtremes && !this._isPanning) {\n\t\t\tthis._getSelectionMinMax();\n\t\t\tthis._dirtySelectionExtremes = false;\n\t\t}\n\n\t\tthis._groupData();\n\n\t\tif (this._sizeDirty || this._valuesDirty || this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"min\") || this.isPrivateDirty(\"selectionMax\") || this.isPrivateDirty(\"selectionMin\") || this.isPrivateDirty(\"max\") || this.isPrivateDirty(\"step\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"logarithmic\")) {\n\t\t\tthis._handleRangeChange();\n\t\t\tthis._prepareAxisItems();\n\t\t\tthis._updateAxisRanges();\n\t\t}\n\n\t\tthis._baseValue = this.baseValue();\n\n\t}\n\n\tprotected _groupData() {\n\n\t}\n\n\tprotected _formatText(value: number) {\n\t\tconst numberFormat = this.get(\"numberFormat\");\n\t\tconst formatter = this.getNumberFormatter();\n\n\t\tlet text = \"\";\n\n\t\tif (numberFormat) {\n\t\t\ttext = formatter.format(value, numberFormat);\n\t\t}\n\t\telse {\n\t\t\ttext = formatter.format(value, undefined, this.getPrivate(\"stepDecimalPlaces\"));\n\t\t}\n\t\treturn text;\n\t}\n\n\tprotected _prepareAxisItems() {\n\t\tconst min = this.getPrivate(\"min\");\n\t\tconst max = this.getPrivate(\"max\");\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\n\t\t\tconst logarithmic = this.get(\"logarithmic\");\n\t\t\tconst step = this.getPrivate(\"step\")!;\n\t\t\tconst selectionMin = this.getPrivate(\"selectionMin\")!;\n\t\t\tconst selectionMax = this.getPrivate(\"selectionMax\")! + step;\n\n\t\t\tlet value = selectionMin - step;\n\t\t\tlet i = 0;\n\n\t\t\tif (logarithmic) {\n\t\t\t\tvalue = selectionMin;\n\t\t\t}\n\n\t\t\twhile (value < selectionMax) {\n\t\t\t\tlet dataItem: DataItem<this[\"_dataItemSettings\"]>;\n\t\t\t\tif (this.dataItems.length < i + 1) {\n\t\t\t\t\tdataItem = new DataItem(this, undefined, {});\n\t\t\t\t\tthis._dataItems.push(dataItem);\n\t\t\t\t\tthis.processDataItem(dataItem);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdataItem = this.dataItems[i];\n\t\t\t\t}\n\n\t\t\t\tthis._createAssets(dataItem, []);\n\n\t\t\t\tif (dataItem.isHidden()) {\n\t\t\t\t\tdataItem.show();\n\t\t\t\t}\n\n\t\t\t\tdataItem.setRaw(\"value\", value);\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.set(\"text\", this._formatText(value));\n\t\t\t\t}\n\n\t\t\t\tthis._prepareDataItem(dataItem);\n\n\t\t\t\tif (!logarithmic) {\n\t\t\t\t\tvalue += step;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet differencePower = Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E;\n\t\t\t\t\tif (differencePower > 1) {\n\t\t\t\t\t\tvalue = Math.pow(10, Math.log(min) * Math.LOG10E + i);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue += step;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n\t\t\t\tif (stepPower < 1) {\n\t\t\t\t\t// exponent is less then 1 too. Count decimals of exponent\n\t\t\t\t\tlet decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;\n\t\t\t\t\t// round value to avoid floating point issues\n\t\t\t\t\tvalue = $math.round(value, decCount);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tfor (let j = i; j < this.dataItems.length; j++) {\n\t\t\t\tthis.dataItems[j].hide();\n\t\t\t}\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (series.inited) {\n\t\t\t\t\tseries._markDirtyAxes();\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis._updateGhost();\n\t\t}\n\t}\n\n\n\tpublic _prepareDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, count?: number) {\n\t\tlet renderer = this.get(\"renderer\");\n\t\tlet value = dataItem.get(\"value\")!;\n\t\tlet endValue = dataItem.get(\"endValue\");\n\n\t\tlet position = this.valueToPosition(value);\n\n\t\tlet endPosition = position;\n\t\tlet fillEndPosition = this.valueToPosition(value + this.getPrivate(\"step\")!);\n\n\t\tif ($type.isNumber(endValue)) {\n\t\t\tendPosition = this.valueToPosition(endValue);\n\t\t\tfillEndPosition = endPosition;\n\t\t}\n\n\t\trenderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n\n\t\tconst grid = dataItem.get(\"grid\");\n\t\trenderer.updateGrid(grid, position, endPosition);\n\t\tif (grid) {\n\t\t\tif (value == this.get(\"baseValue\", 0)) {\n\t\t\t\tgrid.addTag(\"base\");\n\t\t\t\tgrid._applyThemes();\n\t\t\t}\n\t\t\telse if (grid.hasTag(\"base\")) {\n\t\t\t\tgrid.removeTag(\"base\");\n\t\t\t\tgrid._applyThemes();\n\t\t\t}\n\t\t}\n\n\t\trenderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n\t\trenderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n\t\tthis._processBullet(dataItem);\n\t\trenderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n\n\t\tif (!dataItem.get(\"isRange\")) {\n\t\t\tconst fillRule = this.get(\"fillRule\");\n\t\t\tif (fillRule) {\n\t\t\t\tfillRule(dataItem)\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprotected _handleRangeChange() {\n\t\tlet selectionMin: number = this.positionToValue(this.get(\"start\", 0));\n\t\tlet selectionMax: number = this.positionToValue(this.get(\"end\", 1));\n\n\t\tconst gridCount = this.get(\"renderer\").gridCount();\n\t\tlet minMaxStep: IMinMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n\t\tlet stepDecimalPlaces = $utils.decimalPlaces(minMaxStep.step);\n\t\tthis.setPrivateRaw(\"stepDecimalPlaces\", stepDecimalPlaces);\n\n\t\tselectionMin = $math.round(selectionMin, stepDecimalPlaces);\n\t\tselectionMax = $math.round(selectionMax, stepDecimalPlaces);\n\n\t\tminMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n\t\tlet step = minMaxStep.step;\n\t\tselectionMin = minMaxStep.min;\n\t\tselectionMax = minMaxStep.max;\n\n\t\tif (this.getPrivate(\"selectionMin\") !== selectionMin || this.getPrivate(\"selectionMax\") !== selectionMax || this.getPrivate(\"step\") !== step) {\n\t\t\tthis.setPrivateRaw(\"selectionMin\", selectionMin);\n\t\t\tthis.setPrivateRaw(\"selectionMax\", selectionMax);\n\t\t\tthis.setPrivateRaw(\"step\", step);\n\t\t}\n\t}\n\n\t/**\n\t * Converts a relative position to a corresponding numeric value from axis\n\t * scale.\n\t *\n\t * @param   position  Relative position\n\t * @return            Value\n\t */\n\tpublic positionToValue(position: number): number {\n\t\tconst min = this.getPrivate(\"min\")!;\n\t\tconst max = this.getPrivate(\"max\")!;\n\n\t\tif (!this.get(\"logarithmic\")) {\n\t\t\treturn position * (max - min) + min;\n\t\t}\n\t\telse {\n\t\t\treturn Math.pow(Math.E, (position * ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E)) + Math.log(min) * Math.LOG10E) / Math.LOG10E);\n\t\t}\n\t}\n\n\t/**\n\t * Convers value to a relative position on axis.\n\t *\n\t * @param   value  Value\n\t * @return         Relative position\n\t */\n\tpublic valueToPosition(value: number): number {\n\n\t\tconst min = this.getPrivate(\"min\")!;\n\t\tconst max = this.getPrivate(\"max\")!;\n\n\t\tif (!this.get(\"logarithmic\")) {\n\t\t\treturn (value - min) / (max - min);\n\t\t}\n\t\telse {\n\t\t\tif (value <= 0) {\n\t\t\t\tlet treatZeroAs = this.get(\"treatZeroAs\");\n\t\t\t\tif ($type.isNumber(treatZeroAs)) {\n\t\t\t\t\tvalue = treatZeroAs;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic valueToFinalPosition(value: number): number {\n\n\t\tconst min = this.getPrivate(\"minFinal\")!;\n\t\tconst max = this.getPrivate(\"maxFinal\")!;\n\n\t\tif (!this.get(\"logarithmic\")) {\n\t\t\treturn (value - min) / (max - min);\n\t\t}\n\t\telse {\n\t\t\tif (value <= 0) {\n\t\t\t\tlet treatZeroAs = this.get(\"treatZeroAs\");\n\t\t\t\tif ($type.isNumber(treatZeroAs)) {\n\t\t\t\t\tvalue = treatZeroAs;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));\n\t\t}\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific value.\n\t *\n\t * @param   value     Numeric value\n\t * @param   location  Location\n\t * @param   baseValue Base value\n\t * @return            X coordinate\n\t */\n\tpublic getX(value: number, location: number, baseValue: number) {\n\t\tvalue = baseValue + (value - baseValue) * location;\n\n\t\tconst position = this.valueToPosition(value);\n\t\treturn this._settings.renderer.positionToCoordinate(position);\n\t}\n\n\t/**\n\t * Returns X coordinate in pixels corresponding to specific value.\n\t *\n\t * @param   value     Numeric value\n\t * @param   location  Location\n\t * @param   baseValue Base value\n\t * @return            X coordinate\n\t */\n\tpublic getY(value: number, location: number, baseValue: number) {\n\t\tvalue = baseValue + (value - baseValue) * location;\n\n\t\tconst position = this.valueToPosition(value)\n\t\treturn this._settings.renderer.positionToCoordinate(position);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateX(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionX(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number) {\n\t\tlet value = dataItem.get(field as any);\n\n\t\tconst stackToItem = dataItem.get(\"stackToItemX\");\n\t\tif (stackToItem) {\n\t\t\tconst series = dataItem.component as XYSeries;\n\t\t\tvalue = value * axisLocation + series.getStackedXValueWorking(dataItem, field);\n\t\t}\n\t\telse {\n\t\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\t}\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemCoordinateY(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number): number {\n\t\treturn this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getDataItemPositionY(dataItem: DataItem<IXYSeriesDataItem>, field: string, _cellLocation: number, axisLocation: number): number {\n\t\tlet value = dataItem.get(field as any);\n\n\t\tconst stackToItem = dataItem.get(\"stackToItemY\");\n\t\tif (stackToItem) {\n\t\t\tconst series = dataItem.component as XYSeries;\n\t\t\tvalue = value * axisLocation + series.getStackedYValueWorking(dataItem, field);\n\t\t}\n\t\telse {\n\t\t\tvalue = this._baseValue + (value - this._baseValue) * axisLocation;\n\t\t}\n\n\t\treturn this.valueToPosition(value);\n\t}\n\n\t/**\n\t * Returns relative position of axis' `baseValue`.\n\t *\n\t * @return  Base value position\n\t */\n\tpublic basePosition(): number {\n\t\treturn this.valueToPosition(this.baseValue());\n\t}\n\n\t/**\n\t * Base value of the [[ValueAxis]], which determines positive and negative\n\t * values.\n\t *\n\t * @return Base value\n\t */\n\tpublic baseValue(): number {\n\t\tconst min = Math.min(this.getPrivate(\"minFinal\", -Infinity), this.getPrivate(\"selectionMin\", -Infinity));\n\t\tconst max = Math.max(this.getPrivate(\"maxFinal\", Infinity), this.getPrivate(\"selectionMax\", Infinity));\n\t\tlet baseValue = this.get(\"baseValue\", 0);\n\n\t\tif (baseValue < min) {\n\t\t\tbaseValue = min;\n\t\t}\n\n\t\tif (baseValue > max) {\n\t\t\tbaseValue = max\n\t\t}\n\n\t\treturn baseValue;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic cellEndValue(value: number): number {\n\t\treturn value;\n\t}\n\n\tprotected fixSmallStep(step: number): number {\n\t\t// happens because of floating point error\n\t\tif (1 + step === 1) {\n\t\t\tstep *= 2;\n\t\t\treturn this.fixSmallStep(step);\n\t\t}\n\t\treturn step;\n\t}\n\n\tprotected _fixMin(min: number) {\n\t\treturn min;\n\t}\n\n\tprotected _fixMax(max: number) {\n\t\treturn max;\n\t}\n\n\tpublic _calculateTotals() {\n\t\tif (this.get(\"calculateTotals\")) {\n\t\t\tlet series = this.series[0];\n\t\t\tif (series) {\n\t\t\t\tlet startIndex = series.getPrivate(\"startIndex\", 0);\n\n\t\t\t\tif (series.dataItems.length > 0) {\n\n\t\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t\tstartIndex--;\n\t\t\t\t\t}\n\t\t\t\t\tlet endIndex = series.getPrivate(\"endIndex\", series.dataItems.length);\n\t\t\t\t\tif (endIndex < series.dataItems.length) {\n\t\t\t\t\t\tendIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet field: string | undefined;\n\t\t\t\t\tlet vc: string | undefined;\n\n\t\t\t\t\tif (series.get(\"yAxis\") == this) {\n\t\t\t\t\t\tfield = \"valueY\";\n\t\t\t\t\t\tvc = \"vcy\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (series.get(\"xAxis\") == this) {\n\t\t\t\t\t\tfield = \"valueX\";\n\t\t\t\t\t\tvc = \"vcx\";\n\t\t\t\t\t}\n\n\t\t\t\t\tlet fieldWorking = field + \"Working\";\n\n\t\t\t\t\tif (field) {\n\t\t\t\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\t\t\t\tlet sum = 0;\n\t\t\t\t\t\t\tlet total = 0;\n\n\t\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\t\tif (!series.get(\"excludeFromTotal\")) {\n\t\t\t\t\t\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\t\t\t\t\t\tif (dataItem) {\n\t\t\t\t\t\t\t\t\t\tlet value = dataItem.get(fieldWorking as any) * series.get(vc as any);\n\n\t\t\t\t\t\t\t\t\t\tif (value != undefined) {\n\t\t\t\t\t\t\t\t\t\t\tsum += value;\n\t\t\t\t\t\t\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t$array.each(this.series, (series) => {\n\t\t\t\t\t\t\t\tif (!series.get(\"excludeFromTotal\")) {\n\t\t\t\t\t\t\t\t\tlet dataItem = series.dataItems[i];\n\t\t\t\t\t\t\t\t\tif (dataItem) {\n\t\t\t\t\t\t\t\t\t\tlet value = dataItem.get(fieldWorking as any) * series.get(vc as any);\n\n\t\t\t\t\t\t\t\t\t\tif (value != undefined) {\n\t\t\t\t\t\t\t\t\t\t\tdataItem.set((field + \"Total\") as any, total);\n\t\t\t\t\t\t\t\t\t\t\tdataItem.set((field + \"Sum\") as any, sum);\n\t\t\t\t\t\t\t\t\t\t\tdataItem.set((field + \"TotalPercent\") as any, value / total * 100);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _getSelectionMinMax() {\n\t\tconst min = this.getPrivate(\"minFinal\");\n\t\tconst max = this.getPrivate(\"maxFinal\");\n\n\t\tconst minDefined = this.get(\"min\");\n\t\tconst maxDefined = this.get(\"max\");\n\n\t\tconst extraMin = this.get(\"extraMin\", 0);\n\t\tconst extraMax = this.get(\"extraMax\", 0);\n\n\t\tconst gridCount = this.get(\"renderer\").gridCount();\n\n\t\tconst strictMinMax = this.get(\"strictMinMax\", false);\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\n\t\t\tlet selectionMin = max;\n\t\t\tlet selectionMax = min;\n\n\t\t\t$array.each(this.series, (series) => {\n\t\t\t\tif (!series.get(\"ignoreMinMax\")) {\n\t\t\t\t\tlet seriesMin: number | undefined;\n\t\t\t\t\tlet seriesMax: number | undefined;\n\t\t\t\t\tif (series.get(\"xAxis\") === this) {\n\t\t\t\t\t\tseriesMin = series.getPrivate(\"selectionMinX\", series.getPrivate(\"minX\"));\n\t\t\t\t\t\tseriesMax = series.getPrivate(\"selectionMaxX\", series.getPrivate(\"maxX\"));\n\t\t\t\t\t}\n\t\t\t\t\telse if (series.get(\"yAxis\") === this) {\n\t\t\t\t\t\tseriesMin = series.getPrivate(\"selectionMinY\", series.getPrivate(\"minY\"));\n\t\t\t\t\t\tseriesMax = series.getPrivate(\"selectionMaxY\", series.getPrivate(\"maxY\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (!series.isHidden() && !series.isShowing()) {\n\t\t\t\t\t\tif ($type.isNumber(seriesMin)) {\n\t\t\t\t\t\t\tselectionMin = Math.min(selectionMin, seriesMin);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ($type.isNumber(seriesMax)) {\n\t\t\t\t\t\t\tselectionMax = Math.max(selectionMax, seriesMax);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (selectionMin > selectionMax) {\n\t\t\t\t[selectionMin, selectionMax] = [selectionMax, selectionMin]\n\t\t\t}\n\n\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\tif (strictMinMax) {\n\t\t\t\t\tselectionMin = minDefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tselectionMin = min;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strictMinMax) {\n\t\t\t\tif ($type.isNumber(this._minReal)) {\n\t\t\t\t\tselectionMin = this._minReal;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\tif (strictMinMax) {\n\t\t\t\t\tselectionMax = maxDefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tselectionMax = max;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strictMinMax) {\n\t\t\t\tif ($type.isNumber(this._maxReal)) {\n\t\t\t\t\tselectionMax = this._maxReal;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selectionMin === selectionMax) {\n\t\t\t\tselectionMin -= this._deltaMinMax;\n\t\t\t\tselectionMax += this._deltaMinMax;\n\n\t\t\t\tlet minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);\n\t\t\t\tselectionMin = minMaxStep2.min;\n\t\t\t\tselectionMax = minMaxStep2.max;\n\t\t\t}\n\n\t\t\tlet minMaxStep: IMinMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);\n\n\t\t\tselectionMin = minMaxStep.min;\n\t\t\tselectionMax = minMaxStep.max;\n\n\t\t\tselectionMin -= (selectionMax - selectionMin) * extraMin;\n\t\t\tselectionMax += (selectionMax - selectionMin) * extraMax;\n\n\t\t\tselectionMin = $math.fitToRange(selectionMin, min, max);\n\t\t\tselectionMax = $math.fitToRange(selectionMax, min, max);\n\n\t\t\t// do it for the second time !important\t\t\t\n\t\t\tminMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n\t\t\tif (!strictMinMax) {\n\t\t\t\tselectionMin = minMaxStep.min;\n\t\t\t\tselectionMax = minMaxStep.max;\n\t\t\t}\n\n\t\t\tconst syncWithAxis = this.get(\"syncWithAxis\");\n\t\t\tif (syncWithAxis) {\n\t\t\t\tminMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate(\"selectionMinFinal\", syncWithAxis.getPrivate(\"minFinal\", 0)), syncWithAxis.getPrivate(\"selectionMaxFinal\", syncWithAxis.getPrivate(\"maxFinal\", 1)), syncWithAxis.getPrivate(\"selectionStepFinal\", syncWithAxis.getPrivate(\"step\", 1)));\n\n\t\t\t\tselectionMin = minMaxStep.min;\n\t\t\t\tselectionMax = minMaxStep.max;\n\t\t\t}\n\n\t\t\tif (strictMinMax) {\n\t\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\t\tselectionMin = Math.max(selectionMin, minDefined);\n\t\t\t\t}\n\t\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\t\tselectionMax = Math.min(selectionMax, maxDefined);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet start = this.valueToFinalPosition(selectionMin);\n\t\t\tlet end = this.valueToFinalPosition(selectionMax);\n\n\t\t\tthis.setPrivateRaw(\"selectionMinFinal\", selectionMin);\n\t\t\tthis.setPrivateRaw(\"selectionMaxFinal\", selectionMax);\n\t\t\tthis.setPrivateRaw(\"selectionStepFinal\", minMaxStep.step);\n\n\t\t\tthis.zoom(start, end);\n\t\t}\n\t}\n\n\n\tprotected _getMinMax() {\n\t\tlet minDefined = this.get(\"min\");\n\t\tlet maxDefined = this.get(\"max\");\n\n\t\tlet min = Infinity;\n\t\tlet max = -Infinity;\n\n\t\tlet extraMin = this.get(\"extraMin\", 0);\n\t\tlet extraMax = this.get(\"extraMax\", 0);\n\t\tlet minDiff = Infinity;\n\n\t\t$array.each(this.series, (series) => {\n\t\t\tif (!series.get(\"ignoreMinMax\")) {\n\t\t\t\tlet seriesMin: number | undefined;\n\t\t\t\tlet seriesMax: number | undefined;\n\t\t\t\tif (series.get(\"xAxis\") === this) {\n\t\t\t\t\tseriesMin = series.getPrivate(\"minX\");\n\t\t\t\t\tseriesMax = series.getPrivate(\"maxX\");\n\t\t\t\t}\n\t\t\t\telse if (series.get(\"yAxis\") === this) {\n\t\t\t\t\tseriesMin = series.getPrivate(\"minY\");\n\t\t\t\t\tseriesMax = series.getPrivate(\"maxY\");\n\t\t\t\t}\n\n\t\t\t\tif ($type.isNumber(seriesMin) && $type.isNumber(seriesMax)) {\n\t\t\t\t\tmin = Math.min(min, seriesMin);\n\t\t\t\t\tmax = Math.max(max, seriesMax);\n\n\t\t\t\t\tlet diff = seriesMax - seriesMin;\n\n\t\t\t\t\tif (diff <= 0) {\n\t\t\t\t\t\tdiff = Math.abs(seriesMax / 100);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (diff < minDiff) {\n\t\t\t\t\t\tminDiff = diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (this.get(\"logarithmic\")) {\n\t\t\tlet treatZeroAs = this.get(\"treatZeroAs\");\n\t\t\tif ($type.isNumber(treatZeroAs)) {\n\t\t\t\tif (min <= 0) {\n\t\t\t\t\tmin = treatZeroAs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min <= 0) {\n\t\t\t\tnew Error(\"Logarithmic value axis can not have values <= 0.\");\n\t\t\t}\n\t\t}\n\n\t\tif (min === 0 && max === 0) {\n\t\t\tmax = 0.9;\n\t\t\tmin = -0.9;\n\t\t}\n\n\t\tif ($type.isNumber(minDefined)) {\n\t\t\tmin = minDefined;\n\t\t}\n\t\tif ($type.isNumber(maxDefined)) {\n\t\t\tmax = maxDefined;\n\t\t}\n\n\t\t// meaning no min/max found on series/ranges and no min/max was defined\n\t\tif (min === Infinity && max === -Infinity) {\n\t\t\treturn;\n\t\t}\n\n\t\t// adapter\n\t\tlet minAdapted = this.adapters.fold(\"min\", min);\n\t\tlet maxAdapted = this.adapters.fold(\"max\", max);\n\n\t\tif ($type.isNumber(minAdapted)) {\n\t\t\tmin = minAdapted;\n\t\t}\n\n\t\tif ($type.isNumber(maxAdapted)) {\n\t\t\tmax = maxAdapted;\n\t\t}\n\n\t\t// DateAxis does some magic here\n\t\tmin = this._fixMin(min);\n\t\tmax = this._fixMax(max);\n\n\t\t// this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\n\t\tif (max - min <= 1 / Math.pow(10, 15)) {\n\t\t\tif (max - min !== 0) {\n\t\t\t\tthis._deltaMinMax = (max - min) / 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// the number by which we need to raise 10 to get difference\n\t\t\t\tlet exponent: number = Math.log(Math.abs(max)) * Math.LOG10E;\n\n\t\t\t\t// here we find a number which is power of 10 and has the same count of numbers as difference has\n\t\t\t\tlet power = Math.pow(10, Math.floor(exponent));\n\n\t\t\t\t// reduce this number by 10 times\n\t\t\t\tpower = power / 10;\n\n\t\t\t\tthis._deltaMinMax = power;\n\t\t\t}\n\n\t\t\tmin -= this._deltaMinMax;\n\t\t\tmax += this._deltaMinMax;\n\t\t}\n\n\t\t// add extras\n\t\tmin -= (max - min) * extraMin;\n\t\tmax += (max - min) * extraMax;\n\n\t\tthis._minReal = min;\n\t\tthis._maxReal = max;\n\n\t\tlet strict = this.get(\"strictMinMax\");\n\t\tif ($type.isNumber(maxDefined)) {\n\t\t\tstrict = true;\n\t\t}\n\n\t\tlet gridCount = this.get(\"renderer\").gridCount();\n\n\t\tlet minMaxStep: IMinMaxStep = this._adjustMinMax(min, max, gridCount, strict);\n\n\t\tmin = minMaxStep.min;\n\t\tmax = minMaxStep.max;\n\n\t\t// do it for the second time with strict true (importat!)\n\t\tminMaxStep = this._adjustMinMax(min, max, gridCount, true);\n\n\t\tmin = minMaxStep.min;\n\t\tmax = minMaxStep.max;\n\n\t\t// return min max if strict\n\t\tif (this.get(\"strictMinMax\")) {\n\t\t\tif ($type.isNumber(minDefined)) {\n\t\t\t\tmin = minDefined;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin = this._minReal;\n\t\t\t}\n\n\t\t\tif ($type.isNumber(maxDefined)) {\n\t\t\t\tmax = maxDefined;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax = this._maxReal;\n\t\t\t}\n\n\t\t\tif (max - min <= 0.00000001) {\n\t\t\t\tmin -= this._deltaMinMax;\n\t\t\t\tmax += this._deltaMinMax;\n\t\t\t}\n\n\t\t\tmin -= (max - min) * extraMin;\n\t\t\tmax += (max - min) * extraMax;\n\t\t}\n\n\t\tminAdapted = this.adapters.fold(\"min\", min);\n\t\tmaxAdapted = this.adapters.fold(\"max\", max);\n\n\t\tif ($type.isNumber(minAdapted)) {\n\t\t\tmin = minAdapted;\n\t\t}\n\n\t\tif ($type.isNumber(maxAdapted)) {\n\t\t\tmax = maxAdapted;\n\t\t}\n\n\t\tif (minDiff == Infinity) {\n\t\t\tminDiff = (max - min)\n\t\t}\n\n\t\tconst syncWithAxis = this.get(\"syncWithAxis\");\n\t\tif (syncWithAxis) {\n\t\t\tminMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate(\"minFinal\", syncWithAxis.getPrivate(\"min\", 0)), syncWithAxis.getPrivate(\"maxFinal\", syncWithAxis.getPrivate(\"max\", 1)), syncWithAxis.getPrivate(\"step\", 1));\n\t\t\tmin = minMaxStep.min;\n\t\t\tmax = minMaxStep.max;\n\t\t}\n\n\t\tthis.setPrivateRaw(\"maxZoomFactor\", (max - min) / minDiff * this.get(\"maxZoomFactor\", 100));\n\n\t\tif ($type.isNumber(min) && $type.isNumber(max)) {\n\t\t\tif (this.getPrivate(\"minFinal\") !== min || this.getPrivate(\"maxFinal\") !== max) {\n\t\t\t\tthis.setPrivate(\"minFinal\", min);\n\t\t\t\tthis.setPrivate(\"maxFinal\", max);\n\n\t\t\t\tconst duration = this.get(\"interpolationDuration\", 0);\n\t\t\t\tconst easing = this.get(\"interpolationEasing\");\n\n\t\t\t\tthis.animatePrivate({ key: \"min\", to: min, duration, easing });\n\t\t\t\tthis.animatePrivate({ key: \"max\", to: max, duration, easing });\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprotected _adjustMinMax(min: number, max: number, gridCount: number, strictMode?: boolean): IMinMaxStep {\n\t\tconst logarithmic = this.get(\"logarithmic\");\n\t\t// will fail if 0\n\t\tif (gridCount <= 1) {\n\t\t\tgridCount = 1;\n\t\t}\n\n\t\tgridCount = Math.round(gridCount);\n\n\t\tlet initialMin: number = min;\n\t\tlet initialMax: number = max;\n\n\t\tlet difference = max - min;\n\n\t\t// in case min and max is the same, use max\n\t\tif (difference === 0) {\n\t\t\tdifference = Math.abs(max);\n\t\t}\n\n\t\t// the number by which we need to raise 10 to get difference\n\t\tlet exponent: number = Math.log(Math.abs(difference)) * Math.LOG10E;\n\n\t\t// here we find a number which is power of 10 and has the same count of numbers as difference has\n\t\tlet power = Math.pow(10, Math.floor(exponent));\n\n\t\t// reduce this number by 10 times\n\t\tpower = power / 10;\n\n\t\tlet extra: number = power;\n\t\tif (strictMode) {\n\t\t\textra = 0;\n\t\t}\n\n\t\tif (!logarithmic) {\n\t\t\t// round down min\n\t\t\tif (strictMode) {\n\t\t\t\tmin = Math.floor(min / power) * power;\n\t\t\t\t// round up max\n\t\t\t\tmax = Math.ceil(max / power) * power;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin = Math.ceil(min / power) * power - extra;\n\t\t\t\t// round up max\n\t\t\t\tmax = Math.floor(max / power) * power + extra;\n\t\t\t}\n\n\t\t\t// don't let min go below 0 if real min is >= 0\n\t\t\tif (min < 0 && initialMin >= 0) {\n\t\t\t\tmin = 0;\n\t\t\t}\n\t\t\t// don't let max go above 0 if real max is <= 0\n\t\t\tif (max > 0 && initialMax <= 0) {\n\t\t\t\tmax = 0;\n\t\t\t}\n\t\t}\n\t\t// logarithmic\n\t\telse {\n\t\t\tif (min <= 0) {\n\t\t\t\t//throw Error(\"Logarithmic value axis can not have values <= 0.\");\n\t\t\t\tmin = this.get(\"baseValue\", 0);\n\t\t\t}\n\n\t\t\tif (min === Infinity) {\n\t\t\t\tmin = 1;\n\t\t\t}\n\n\t\t\tif (max === -Infinity) {\n\t\t\t\tmax = 10;\n\t\t\t}\n\n\t\t\tmin = Math.pow(10, Math.floor(Math.log(Math.abs(min)) * Math.LOG10E));\n\t\t\tmax = Math.pow(10, Math.ceil(Math.log(Math.abs(max)) * Math.LOG10E));\n\n\t\t\tif (this.get(\"strictMinMax\")) {\n\t\t\t\tlet minDefined = this.get(\"min\");\n\t\t\t\tlet maxDefined = this.get(\"max\");\n\t\t\t\tif ($type.isNumber(minDefined) && minDefined > 0) {\n\t\t\t\t\tmin = minDefined;\n\t\t\t\t}\n\t\t\t\tif ($type.isNumber(maxDefined) && maxDefined > 0) {\n\t\t\t\t\tmax = maxDefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\texponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n\t\tpower = Math.pow(10, Math.floor(exponent));\n\t\tpower = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance\n\n\t\t// approximate difference between two grid lines\n\t\tlet step = Math.ceil((difference / gridCount) / power) * power;\n\t\tlet stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n\n\t\t// the step should divide by  2, 5, and 10.\n\t\tlet stepDivisor: number = Math.ceil(step / stepPower); // number 0 - 10\n\n\n\t\tif (stepDivisor > 5) {\n\t\t\tstepDivisor = 10;\n\t\t}\n\t\telse if (stepDivisor <= 5 && stepDivisor > 2) {\n\t\t\tstepDivisor = 5;\n\t\t}\n\n\t\t// now get real step\n\t\tstep = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n\n\t\tlet maxPrecision = this.get(\"maxPrecision\");\n\t\tif ($type.isNumber(maxPrecision)) {\n\t\t\tlet ceiledStep = $math.ceil(step, maxPrecision);\n\t\t\tif (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {\n\t\t\t\tstep = ceiledStep;\n\t\t\t}\n\t\t}\n\n\t\tlet decCount: number = 0;\n\t\t// in case numbers are smaller than 1\n\t\tif (stepPower < 1) {\n\t\t\t// exponent is less then 1 too. Count decimals of exponent\n\t\t\tdecCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;\n\t\t\t// round step\n\t\t\tstep = $math.round(step, decCount);\n\t\t}\n\t\tif (!logarithmic) {\n\t\t\t// final min and max\n\t\t\tlet minCount = Math.floor(min / step);\n\n\t\t\tmin = $math.round(step * minCount, decCount);\n\n\t\t\tlet maxCount: number;\n\n\t\t\tif (!strictMode) {\n\t\t\t\tmaxCount = Math.ceil(max / step);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmaxCount = Math.floor(max / step);\n\t\t\t}\n\n\t\t\tif (maxCount === minCount) {\n\t\t\t\tmaxCount++;\n\t\t\t}\n\n\t\t\tmax = $math.round(step * maxCount, decCount);\n\n\t\t\tif (max < initialMax) {\n\t\t\t\tmax = max + step;\n\t\t\t}\n\n\t\t\tif (min > initialMin) {\n\t\t\t\tmin = min - step;\n\t\t\t}\n\t\t}\n\n\t\tstep = this.fixSmallStep(step);\n\n\t\treturn { min: min, max: max, step: step };\n\t}\n\n\t/**\n\t * Returns text to be used in an axis tooltip for specific relative position.\n\t *\n\t * @param   position  Position\n\t * @return            Tooltip text\n\t */\n\tpublic getTooltipText(position: number): string | undefined {\n\t\tconst numberFormat = this.get(\"tooltipNumberFormat\", this.get(\"numberFormat\"));\n\t\tconst formatter = this.getNumberFormatter();\n\t\tconst extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n\t\tconst decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n\t\tconst value = $math.round(this.positionToValue(position), decimals);\n\n\t\tif (numberFormat) {\n\t\t\treturn formatter.format(value, numberFormat);\n\t\t}\n\t\telse {\n\t\t\treturn formatter.format(value, undefined, decimals);\n\t\t\t//label.set(\"text\", this.getNumberFormatter().format(value, undefined, this.getPrivate(\"stepDecimalPlaces\")));\n\t\t}\n\n\t\t// //@todo number formatter + tag\n\t\t// return $math.round(this.positionToValue(position), this.getPrivate(\"stepDecimalPlaces\")).toString();\n\t}\n\n\t/**\n\t * Returns a data item from series that is closest to the `position`.\n\t *\n\t * @param   series    Series\n\t * @param   position  Relative position\n\t * @return            Data item\n\t */\n\tpublic getSeriesItem(series: XYSeries, position: number): DataItem<IXYSeriesDataItem> | undefined {\n\t\tlet fieldName = <any>(this.getPrivate(\"name\")! + this.get(\"renderer\").getPrivate(\"letter\")!);\n\t\tlet value = this.positionToValue(position);\n\n\t\tlet index: number | undefined = undefined;\n\t\tlet oldDiff: number;\n\t\t$array.each(series.dataItems, (dataItem, i) => {\n\t\t\tconst diff = Math.abs(dataItem.get(fieldName) - value);\n\t\t\tif (index === undefined || diff < oldDiff) {\n\t\t\t\tindex = i;\n\t\t\t\toldDiff = diff;\n\t\t\t}\n\t\t});\n\n\t\tif (index != null) {\n\t\t\treturn series.dataItems[index];\n\t\t}\n\t}\n\n\t/**\n\t * Zooms the axis to specific `start` and `end` values.\n\t *\n\t * Optional `duration` specifies duration of zoom animation in milliseconds.\n\t *\n\t * @param  start     Start value\n\t * @param  end       End value\n\t * @param  duration  Duration in milliseconds\n\t */\n\tpublic zoomToValues(start: number, end: number, duration?: number) {\n\t\tconst min = this.getPrivate(\"minFinal\", 0);\n\t\tconst max = this.getPrivate(\"maxFinal\", 0);\n\t\tif (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n\t\t\tthis.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Syncs with a target axis.\n\t *\n\t * @param  min  Min\n\t * @param  max  Max\n\t * @param  step Step\n\t */\n\tprotected _syncAxes(min: number, max: number, step: number, syncMin: number, syncMax: number, syncStep: number) {\n\t\tlet axis = this.get(\"syncWithAxis\");\n\t\tif (axis) {\n\t\t\tlet count: number = Math.round(syncMax - syncMin) / syncStep;\n\t\t\tlet currentCount = Math.round((max - min) / step);\n\n\t\t\tlet gridCount = this.get(\"renderer\").gridCount();\n\n\t\t\tif ($type.isNumber(count) && $type.isNumber(currentCount)) {\n\t\t\t\tlet synced = false;\n\t\t\t\tlet c = 0\n\t\t\t\tlet diff = (max - min) * 0.01;\n\t\t\t\tlet omin = min;\n\t\t\t\tlet omax = max;\n\t\t\t\tlet ostep = step;\n\n\t\t\t\twhile (synced != true) {\n\t\t\t\t\tsynced = this._checkSync(omin, omax, ostep, count);\n\t\t\t\t\tc++;\n\t\t\t\t\tif (c > 500) {\n\t\t\t\t\t\tsynced = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!synced) {\n\t\t\t\t\t\tif (c / 3 == Math.round(c / 3)) {\n\t\t\t\t\t\t\tomin = min - diff * c;\n\t\t\t\t\t\t\tif (min >= 0 && omin < 0) {\n\t\t\t\t\t\t\t\tomin = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tomax = max + diff * c;\n\t\t\t\t\t\t\tif (omax <= 0 && omax > 0) {\n\t\t\t\t\t\t\t\tomax = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);\n\t\t\t\t\t\tomin = minMaxStep.min;\n\t\t\t\t\t\tomax = minMaxStep.max;\n\t\t\t\t\t\tostep = minMaxStep.step;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmin = omin;\n\t\t\t\t\t\tmax = omax;\n\t\t\t\t\t\tstep = ostep;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { min: min, max: max, step: step };\n\t}\n\n\t/**\n\t * Returns `true` if axis needs to be resunced with some other axis.\n\t */\n\tprotected _checkSync(min: number, max: number, step: number, count: number): boolean {\n\t\tlet currentCount = (max - min) / step;\n\t\tfor (let i = 1; i < count; i++) {\n\t\t\tif ($math.round(currentCount / i, 1) == count || currentCount * i == count) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}