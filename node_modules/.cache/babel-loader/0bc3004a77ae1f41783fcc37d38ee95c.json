{"ast":null,"code":"import * as $type from \"./Type\";\nimport * as $object from \"./Object\";\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\nvar JSONParser = /** @class */function () {\n  function JSONParser() {}\n  /**\r\n   * Parses JSON string.\r\n   *\r\n   * @param   input    JSON\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n  Object.defineProperty(JSONParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options);\n      try {\n        if ($type.isString(input)) {\n          var data = JSON.parse(input);\n          if (options.reverse && $type.isArray(data)) {\n            data.reverse();\n          }\n          return data;\n        } else if ($type.isArray(input) || $type.isObject(input)) {\n          return input;\n        } else {\n          throw \"Unable to parse JSON data\";\n        }\n      } catch (e) {\n        return undefined;\n      }\n    }\n  });\n  Object.defineProperty(JSONParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        reverse: false\n      };\n      if (!options) {\n        options = {};\n      }\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return JSONParser;\n}();\nexport { JSONParser };\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\nvar CSVParser = /** @class */function () {\n  function CSVParser() {}\n  /**\r\n   * Parses CSV string.\r\n   *\r\n   * @param   input    CSV\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n  Object.defineProperty(CSVParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options);\n      // Get CSV data as array\n      var data = this.CSVToArray(input, options.delimiter);\n      // Init resuling array\n      var res = [],\n        cols = [],\n        col,\n        i;\n      // Skip rows\n      for (i = 0; i < options.skipRows; i++) {\n        data.shift();\n      }\n      // First row holds column names?\n      if (options.useColumnNames) {\n        cols = data.shift();\n        // Normalize column names\n        for (var x = 0; x < cols.length; x++) {\n          // trim\n          col = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n          // Check for empty\n          if (\"\" === col) {\n            col = \"col\" + x;\n          }\n          cols[x] = col;\n        }\n      }\n      // Iterate through the result set\n      var row;\n      while (true) {\n        row = options.reverse ? data.pop() : data.shift();\n        if (!row) {\n          break;\n        }\n        if (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n          continue;\n        }\n        var dataPoint = {};\n        for (i = 0; i < row.length; i++) {\n          col = undefined === cols[i] ? \"col\" + i : cols[i];\n          dataPoint[col] = row[i];\n        }\n        res.push(dataPoint);\n      }\n      return res;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n  Object.defineProperty(CSVParser, \"CSVToArray\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (data, delimiter) {\n      // Check to see if the delimiter is defined. If not,\n      // then default to comma.\n      delimiter = delimiter || ',';\n      // Create a regular expression to parse the CSV values.\n      var objPattern = new RegExp(\n      // Delimiters.\n      \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n      // Quoted fields.\n      \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n      // Standard fields.\n      \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\");\n      // Create an array to hold our data. Give the array\n      // a default empty first row.\n      var arrData = [[]];\n      // Create an array to hold our individual pattern\n      // matching groups.\n      var arrMatches = null;\n      // Keep looping over the regular expression matches\n      // until we can no longer find a match.\n      while (true) {\n        arrMatches = objPattern.exec(data);\n        if (!arrMatches) {\n          break;\n        }\n        // Get the delimiter that was found.\n        var strMatchedDelimiter = arrMatches[1];\n        // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n        if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n          // Since we have reached a new row of data,\n          // add an empty row to our data array.\n          arrData.push([]);\n        }\n        // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n        var strMatchedValue = void 0;\n        if (arrMatches[2]) {\n          // We found a quoted value. When we capture\n          // this value, unescape any double quotes.\n          strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n        } else {\n          // We found a non-quoted value.\n          strMatchedValue = arrMatches[3];\n        }\n        // Now that we have our value string, let's add\n        // it to the data array.\n        arrData[arrData.length - 1].push(strMatchedValue);\n      }\n      // Return the parsed data.\n      return arrData;\n    }\n  });\n  Object.defineProperty(CSVParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        delimiter: \",\",\n        reverse: false,\n        skipRows: 0,\n        skipEmpty: true,\n        useColumnNames: false\n      };\n      if (!options) {\n        options = {};\n      }\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return CSVParser;\n}();\nexport { CSVParser };","map":{"version":3,"names":["$type","$object","JSONParser","value","input","options","_applyDefaults","isString","data","JSON","parse","reverse","isArray","isObject","e","undefined","normalized","defaults","each","key","val","CSVParser","CSVToArray","delimiter","res","cols","col","i","skipRows","shift","useColumnNames","x","length","replace","row","pop","skipEmpty","dataPoint","push","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","strMatchedValue"],"sources":["../../../../../src/.internal/core/util/DataParser.ts"],"sourcesContent":["import * as $type from \"./Type\"\nimport * as $object from \"./Object\"\n\nexport interface IJSONParserOptions {\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class JSONParser {\n\n\t/**\n\t * Parses JSON string.\n\t * \n\t * @param   input    JSON\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: IJSONParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\t\ttry {\n\t\t\tif ($type.isString(input)) {\n\t\t\t\tlet data  = JSON.parse(input);\n\t\t\t\tif (options.reverse && $type.isArray(data)) {\n\t\t\t\t\tdata.reverse();\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if ($type.isArray(input) || $type.isObject(input)) {\n\t\t\t\treturn input;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow(\"Unable to parse JSON data\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprotected static _applyDefaults(options?: IJSONParserOptions): IJSONParserOptions {\n\t\tconst normalized: IJSONParserOptions = {};\n\t\tconst defaults = {\n\t\t\treverse: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\t}\n}\n\n\nexport interface ICSVParserOptions {\n\n\t/**\n\t * Delimiter used for columns.\n\t * \n\t * @default \",\"\n\t */\n\tdelimiter?: string;\n\n\t/**\n\t * Reverse the order of parsed data.\n\t */\n\treverse?: boolean;\n\n\t/**\n\t * Skip first X rows.\n\t *\n\t * @default 0\n\t */\n\tskipRows?: number;\n\n\t/**\n\t * Skip empty rows.\n\t *\n\t * @default true\n\t */\n\tskipEmpty?: boolean;\n\n\t/**\n\t * Use the first row to name the columns.\n\t * \n\t * @default false\n\t */\n\tuseColumnNames?: boolean;\n\n}\n\n/**\n * Tool to parse JSON string into structured data.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\n * @important\n */\nexport class CSVParser {\n\n\t/**\n\t * Parses CSV string.\n\t * \n\t * @param   input    CSV\n\t * @param   options  Options\n\t * @return           Data\n\t */\n\tpublic static parse(input: string, options?: ICSVParserOptions): any {\n\t\toptions = this._applyDefaults(options);\n\n\t\t// Get CSV data as array\n\t\tlet data = this.CSVToArray(input, options.delimiter!);\n\n\t\t// Init resuling array\n\t\tlet res: any[] = [],\n\t\t\tcols: string[] = [],\n\t\t\tcol: string,\n\t\t\ti: number;\n\n\t\t// Skip rows\n\t\tfor (i = 0; i < options.skipRows!; i++) {\n\t\t\tdata.shift();\n\t\t}\n\n\t\t// First row holds column names?\n\t\tif (options.useColumnNames) {\n\t\t\tcols = data.shift();\n\n\t\t\t// Normalize column names\n\t\t\tfor (let x = 0; x < cols.length; x++) {\n\t\t\t\t// trim\n\t\t\t\tcol = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n\n\t\t\t\t// Check for empty\n\t\t\t\tif (\"\" === col) {\n\t\t\t\t\tcol = \"col\" + x;\n\t\t\t\t}\n\n\t\t\t\tcols[x] = col;\n\t\t\t}\n\t\t}\n\n\t\t// Iterate through the result set\n\t\tlet row;\n\t\twhile (true) {\n\t\t\trow = options.reverse ? data.pop() : data.shift();\n\n\t\t\tif (!row) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet dataPoint: any = {};\n\t\t\tfor (i = 0; i < row.length; i++) {\n\t\t\t\tcol = undefined === cols[i] ? \"col\" + i : cols[i];\n\t\t\t\tdataPoint[col] = row[i];\n\t\t\t}\n\t\t\tres.push(dataPoint);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic static CSVToArray(data: string, delimiter: string): any[] {\n\n\t\t// Check to see if the delimiter is defined. If not,\n\t\t// then default to comma.\n\t\tdelimiter = (delimiter || ',');\n\n\t\t// Create a regular expression to parse the CSV values.\n\t\tlet objPattern = new RegExp(\n\t\t\t(\n\t\t\t\t// Delimiters.\n\t\t\t\t\"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n\t\t\t\t// Quoted fields.\n\t\t\t\t\"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n\t\t\t\t// Standard fields.\n\t\t\t\t\"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"\n\t\t\t),\n\t\t\t\"gi\"\n\t\t);\n\n\n\t\t// Create an array to hold our data. Give the array\n\t\t// a default empty first row.\n\t\tlet arrData: any[] = [\n\t\t\t[]\n\t\t];\n\n\t\t// Create an array to hold our individual pattern\n\t\t// matching groups.\n\t\tlet arrMatches = null;\n\n\t\t// Keep looping over the regular expression matches\n\t\t// until we can no longer find a match.\n\t\twhile (true) {\n\t\t\tarrMatches = objPattern.exec(data);\n\n\t\t\tif (!arrMatches) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Get the delimiter that was found.\n\t\t\tlet strMatchedDelimiter = arrMatches[1];\n\n\t\t\t// Check to see if the given delimiter has a length\n\t\t\t// (is not the start of string) and if it matches\n\t\t\t// field delimiter. If id does not, then we know\n\t\t\t// that this delimiter is a row delimiter.\n\t\t\tif (\n\t\t\t\tstrMatchedDelimiter.length &&\n\t\t\t\t(strMatchedDelimiter !== delimiter)\n\t\t\t) {\n\n\t\t\t\t// Since we have reached a new row of data,\n\t\t\t\t// add an empty row to our data array.\n\t\t\t\tarrData.push([]);\n\n\t\t\t}\n\n\t\t\t// Now that we have our delimiter out of the way,\n\t\t\t// let's check to see which kind of value we\n\t\t\t// captured (quoted or unquoted).\n\t\t\tlet strMatchedValue;\n\t\t\tif (arrMatches[2]) {\n\n\t\t\t\t// We found a quoted value. When we capture\n\t\t\t\t// this value, unescape any double quotes.\n\t\t\t\tstrMatchedValue = arrMatches[2].replace(\n\t\t\t\t\tnew RegExp(\"\\\"\\\"\", \"g\"),\n\t\t\t\t\t\"\\\"\"\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// We found a non-quoted value.\n\t\t\t\tstrMatchedValue = arrMatches[3];\n\n\t\t\t}\n\n\t\t\t// Now that we have our value string, let's add\n\t\t\t// it to the data array.\n\t\t\tarrData[arrData.length - 1].push(strMatchedValue);\n\t\t}\n\n\t\t// Return the parsed data.\n\t\treturn (arrData);\n\t}\n\n\tprotected static _applyDefaults(options?: ICSVParserOptions): ICSVParserOptions {\n\t\tconst normalized: ICSVParserOptions = {};\n\t\tconst defaults = {\n\t\t\tdelimiter: \",\",\n\t\t\treverse: false,\n\t\t\tskipRows: 0,\n\t\t\tskipEmpty: true,\n\t\t\tuseColumnNames: false\n\t\t};\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\t$object.each(defaults, (key, val) => {\n\t\t\tnormalized[key] = options![key] || val;\n\t\t});\n\t\treturn normalized;\n\n\t}\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}